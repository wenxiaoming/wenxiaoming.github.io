<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="graphics vulkan," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="0x1 总体介绍Graphics中各种图形的渲染是通过许多小的三角形的渲染拼接组成的，Mesh的过程是把需要渲染的图形划分成许多小三角形的过程.Escher中的mesh过程需要把Rectangle, Circle, Ring, Sphere等形状的显示对象划分成小三角形，然后把小三角形的数据通过Vulkan API来驱动GPU显示. 下图是escher中mesh相关类的类图  下面简单介绍一下这些">
<meta name="keywords" content="graphics vulkan">
<meta property="og:type" content="article">
<meta property="og:title" content="Mesh support in escher">
<meta property="og:url" content="http://yoursite.com/2019/02/16/Mesh-support-in-Escher/index.html">
<meta property="og:site_name" content="Kevin Wen&#39;s Blog">
<meta property="og:description" content="0x1 总体介绍Graphics中各种图形的渲染是通过许多小的三角形的渲染拼接组成的，Mesh的过程是把需要渲染的图形划分成许多小三角形的过程.Escher中的mesh过程需要把Rectangle, Circle, Ring, Sphere等形状的显示对象划分成小三角形，然后把小三角形的数据通过Vulkan API来驱动GPU显示. 下图是escher中mesh相关类的类图  下面简单介绍一下这些">
<meta property="og:image" content="http://yoursite.com/2019/02/16/Mesh-support-in-Escher/mesh_class_diagram.png">
<meta property="og:image" content="http://yoursite.com/2019/02/16/Mesh-support-in-Escher/roundedrect.jpg">
<meta property="og:updated_time" content="2019-06-02T14:31:47.117Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mesh support in escher">
<meta name="twitter:description" content="0x1 总体介绍Graphics中各种图形的渲染是通过许多小的三角形的渲染拼接组成的，Mesh的过程是把需要渲染的图形划分成许多小三角形的过程.Escher中的mesh过程需要把Rectangle, Circle, Ring, Sphere等形状的显示对象划分成小三角形，然后把小三角形的数据通过Vulkan API来驱动GPU显示. 下图是escher中mesh相关类的类图  下面简单介绍一下这些">
<meta name="twitter:image" content="http://yoursite.com/2019/02/16/Mesh-support-in-Escher/mesh_class_diagram.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/16/Mesh-support-in-Escher/"/>





  <title>Mesh support in escher | Kevin Wen's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kevin Wen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/16/Mesh-support-in-Escher/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Mesh support in escher</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-16T23:21:36+08:00">
                2019-02-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/02/16/Mesh-support-in-Escher/" class="leancloud_visitors" data-flag-title="Mesh support in escher">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="0x1-总体介绍"><a href="#0x1-总体介绍" class="headerlink" title="0x1 总体介绍"></a>0x1 总体介绍</h1><p>Graphics中各种图形的渲染是通过许多小的三角形的渲染拼接组成的，Mesh的过程是把需要渲染的图形划分成许多小三角形的过程.<br>Escher中的mesh过程需要把Rectangle, Circle, Ring, Sphere等形状的显示对象划分成小三角形，然后把小三角形的数据通过Vulkan API来驱动GPU显示.</p>
<p>下图是escher中mesh相关类的类图</p>
<p><img src="/2019/02/16/Mesh-support-in-Escher/mesh_class_diagram.png" alt="mesh_class_diagram"></p>
<p>下面简单介绍一下这些类</p>
<p>Mesh创建过程中，<br>MeshBuilder根据MeshSpec的设置生成对应的Mesh.<br>Mesh的vertex/index数据保存到CommandBuffer中，</p>
<p>Mesh渲染过程中，<br>对应的PageRenderer生成对应的Object，每一个Object都有对应的Mesh，这些Object挂接到Model下面.<br>然后根据Model中包含的Mesh生成ModelDisplayList，然后遍历这个ModelDisplayList，把Mesh中的vertex/index数据传入CommandBuffer中，从而让GPU渲染的时候能够访问到这些数据.</p>
<h1 id="0x2-各种shape的mesh过程"><a href="#0x2-各种shape的mesh过程" class="headerlink" title="0x2 各种shape的mesh过程"></a>0x2 各种shape的mesh过程</h1><h2 id="0x21-MeshBuilder介绍"><a href="#0x21-MeshBuilder介绍" class="headerlink" title="0x21 MeshBuilder介绍"></a>0x21 MeshBuilder介绍</h2><p>MeshBuilder提供接口把vertex data和index data保存起来.</p>
<p>其中保存的数据结构如下,<br>vertex_staging<em>buffer</em>保存vertex数据，index_staging<em>buffer</em>保存index数据.<br>vertex_staging<em>buffer</em>和index_staging<em>buffer</em>的内存空间是通过GpuUploader::Writer来分配的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> max_vertex_count_;</div><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> max_index_count_;</div><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> vertex_stride_;</div><div class="line"><span class="keyword">uint8_t</span>* vertex_staging_buffer_;</div><div class="line"><span class="keyword">uint32_t</span>* index_staging_buffer_;</div><div class="line"><span class="keyword">size_t</span> vertex_count_ = <span class="number">0</span>;</div><div class="line"><span class="keyword">size_t</span> index_count_ = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>下面是其提供设置vertex data和index data的接口.<br>注意下面的接口都返回 *this， 这是为了链式表达式的需要.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> MeshBuilder&amp; MeshBuilder::AddIndex(<span class="keyword">uint32_t</span> index) &#123;</div><div class="line">  FXL_DCHECK(index_count_ &lt; max_index_count_);</div><div class="line">  index_staging_buffer_[index_count_++] = index;</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> MeshBuilder&amp; MeshBuilder::AddVertexData(<span class="keyword">const</span> <span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size) &#123;</div><div class="line">  FXL_DCHECK(vertex_count_ &lt; max_vertex_count_);</div><div class="line">  FXL_DCHECK(size &lt;= vertex_stride_);</div><div class="line">  <span class="keyword">size_t</span> offset = vertex_stride_ * vertex_count_++;</div><div class="line">  <span class="built_in">memcpy</span>(vertex_staging_buffer_ + offset, ptr, size);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VertexT&gt;</div><div class="line">MeshBuilder&amp; MeshBuilder::AddVertex(<span class="keyword">const</span> VertexT&amp; v) &#123;</div><div class="line">  AddVertexData(&amp;v, <span class="keyword">sizeof</span>(VertexT));</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后调用Build()接口生成mesh对象.</p>
<h2 id="0x22-SimpleRectangle"><a href="#0x22-SimpleRectangle" class="headerlink" title="0x22 SimpleRectangle"></a>0x22 SimpleRectangle</h2><p>下面是生成SimpleRectangle的mesh的代码，SimpleRectangle是普通的非圆角Rectangle.<br>从这个代码中可以看到，该mesh过程会生成4个vertex数据，生成6个index数据(因为是2个三角形).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">MeshPtr <span class="title">NewSimpleRectangleMesh</span><span class="params">(MeshBuilderFactory* factory)</span> </span>&#123;</div><div class="line">  MeshSpec spec&#123;MeshAttribute::kPosition2D | MeshAttribute::kUV&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// In each vertex, the first two floats represent the position and the second</span></div><div class="line">  <span class="comment">// two are UV coordinates.</span></div><div class="line">  <span class="function">vec4 <span class="title">v0</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</div><div class="line">  <span class="function">vec4 <span class="title">v1</span><span class="params">(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>)</span></span>;</div><div class="line">  <span class="function">vec4 <span class="title">v2</span><span class="params">(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>)</span></span>;</div><div class="line">  <span class="function">vec4 <span class="title">v3</span><span class="params">(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>)</span></span>;</div><div class="line"></div><div class="line">  MeshBuilderPtr builder = factory-&gt;NewMeshBuilder(spec, <span class="number">4</span>, <span class="number">6</span>);</div><div class="line">  <span class="keyword">return</span> builder-&gt;AddVertex(v0)</div><div class="line">      .AddVertex(v1)</div><div class="line">      .AddVertex(v2)</div><div class="line">      .AddVertex(v3)</div><div class="line">      .AddIndex(<span class="number">0</span>)</div><div class="line">      .AddIndex(<span class="number">1</span>)</div><div class="line">      .AddIndex(<span class="number">2</span>)</div><div class="line">      .AddIndex(<span class="number">0</span>)</div><div class="line">      .AddIndex(<span class="number">2</span>)</div><div class="line">      .AddIndex(<span class="number">3</span>)</div><div class="line">      .Build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面的mesh过程计算好了一个通用的SimpleRectangle的mesh信息，<br>具体要显示Rectangle的时候根据具体的显示位置(top_left_position.x/y/z)和显示的大小(size.x/y)来绘制Rectangle.<br>指定显示的位置可以理解为平移，指定显示的大小可以理解为缩放.<br>这个平移/缩放过程通过设置transform矩阵来实现，在shader代码中把这个矩阵和通用SimpleRectangle的vertex坐标相乘.</p>
<p>transform矩阵的设置过程如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Object Object::NewRect(<span class="keyword">const</span> vec3&amp; top_left_position, <span class="keyword">const</span> vec2&amp; size,</div><div class="line">                       MaterialPtr material) &#123;</div><div class="line">  <span class="function">mat4 <span class="title">transform</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">  transform[<span class="number">0</span>][<span class="number">0</span>] = size.x;</div><div class="line">  transform[<span class="number">1</span>][<span class="number">1</span>] = size.y;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">0</span>] = top_left_position.x;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">1</span>] = top_left_position.y;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">2</span>] = top_left_position.z;</div><div class="line">  <span class="keyword">return</span> Object(transform, Shape(Shape::Type::kRect), <span class="built_in">std</span>::move(material));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x23-Rectangle"><a href="#0x23-Rectangle" class="headerlink" title="0x23 Rectangle"></a>0x23 Rectangle</h2><p>下面的代码生成普通Rectangle的Mesh，</p>
<p>下面函数的参数中，<br>subdivisions指定Rectangle的拆分数，<br>size指定Rectangle的大小，<br>top_left指定左上角的坐标，<br>生成mesh的时候把Rectangle分成(subdivisions*2-1)个小矩形，指定这些小矩形的vertex/index设置.</p>
<p>这个普通Rectangle的mesh和SimpleRectangle的mesh不同之处在于普通Rectangle的mesh是每一个Rectangle生成一个，不具有SimpleRectangle的mesh的通用性. 另外普通Rectangle的mesh会包括更多的小三角形.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function">MeshPtr <span class="title">NewRectangleMesh</span><span class="params">(MeshBuilderFactory* factory, <span class="keyword">const</span> MeshSpec&amp; spec,</span></span></div><div class="line">                         <span class="keyword">int</span> subdivisions, vec2 size, vec2 top_left,</div><div class="line">                         <span class="keyword">float</span> top_offset_magnitude,</div><div class="line">                         <span class="keyword">float</span> bottom_offset_magnitude) &#123;</div><div class="line">  <span class="comment">// Compute the number of vertices in the tessellated circle.</span></div><div class="line">  FXL_DCHECK(subdivisions &gt;= <span class="number">0</span>);</div><div class="line">  <span class="keyword">size_t</span> vertices_per_side = <span class="number">2</span>;</div><div class="line">  <span class="keyword">while</span> (subdivisions-- &gt; <span class="number">0</span>) &#123;</div><div class="line">    vertices_per_side *= <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">size_t</span> vertex_count = vertices_per_side * <span class="number">2</span>;</div><div class="line">  <span class="keyword">size_t</span> index_count = (vertices_per_side - <span class="number">1</span>) * <span class="number">6</span>;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> builder = factory-&gt;NewMeshBuilder(spec, vertex_count, index_count);</div><div class="line"></div><div class="line">  <span class="comment">// Generate vertex positions.</span></div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kMaxVertexSize = <span class="number">100</span>;</div><div class="line">  <span class="keyword">uint8_t</span> vertex[kMaxVertexSize];</div><div class="line">  <span class="keyword">auto</span> vertex_p =</div><div class="line">      GetVertexAttributePointers(vertex, kMaxVertexSize, spec, builder);</div><div class="line">  FXL_CHECK(vertex_p.pos2);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">float</span> vertices_per_side_reciprocal = <span class="number">1.f</span> / (vertices_per_side - <span class="number">1</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; vertices_per_side; ++i) &#123;</div><div class="line">    <span class="comment">// Build bottom vertex.</span></div><div class="line">    (*vertex_p.pos2) =</div><div class="line">        top_left + vec2(size.x * i * vertices_per_side_reciprocal, size.y);</div><div class="line">    <span class="keyword">if</span> (vertex_p.uv)</div><div class="line">      (*vertex_p.uv) = vec2(i * vertices_per_side_reciprocal, <span class="number">1.f</span>);</div><div class="line">    <span class="keyword">if</span> (vertex_p.pos_offset)</div><div class="line">      (*vertex_p.pos_offset) = vec2(<span class="number">0</span>, <span class="number">1.f</span> * bottom_offset_magnitude);</div><div class="line">    <span class="keyword">if</span> (vertex_p.perim)</div><div class="line">      (*vertex_p.perim) = i * vertices_per_side_reciprocal;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line"></div><div class="line">    <span class="comment">// Build top vertex.</span></div><div class="line">    (*vertex_p.pos2) =</div><div class="line">        top_left + vec2(size.x * i * vertices_per_side_reciprocal, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (vertex_p.uv)</div><div class="line">      (*vertex_p.uv) = vec2(i * vertices_per_side_reciprocal, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (vertex_p.pos_offset)</div><div class="line">      (*vertex_p.pos_offset) = vec2(<span class="number">0</span>, <span class="number">-1.f</span> * top_offset_magnitude);</div><div class="line">    <span class="keyword">if</span> (vertex_p.perim)</div><div class="line">      (*vertex_p.perim) = i * vertices_per_side_reciprocal;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate vertex indices.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">2</span>; i &lt; vertex_count; i += <span class="number">2</span>) &#123;</div><div class="line">    builder-&gt;AddIndex(i - <span class="number">2</span>);</div><div class="line">    builder-&gt;AddIndex(i - <span class="number">1</span>);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">    builder-&gt;AddIndex(i - <span class="number">1</span>);</div><div class="line">    builder-&gt;AddIndex(i + <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> mesh = builder-&gt;Build();</div><div class="line">  FXL_DCHECK(mesh-&gt;num_indices() == index_count);</div><div class="line">  <span class="keyword">return</span> mesh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x24-Circle"><a href="#0x24-Circle" class="headerlink" title="0x24 Circle"></a>0x24 Circle</h2><p>下面分析circle的mesh是如何生成的.</p>
<p>下面函数的参数中，<br>subdivisions指定Circle的拆分数目，<br>center指定Circle的中心点坐标.<br>radius指定Circle的半径大小.</p>
<p>生成mesh的时候是把Circle分成(subdivisions*4)个小扇形，然后计算这些小扇形的vertex/index设置.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">MeshPtr NewCircleMesh(MeshBuilderFactory* factory, const MeshSpec&amp; spec,</div><div class="line">                      int subdivisions, vec2 center, float radius,</div><div class="line">                      float offset_magnitude) &#123;</div><div class="line">  // Compute the number of vertices in the tessellated circle.</div><div class="line">  FXL_DCHECK(subdivisions &gt;= 0);</div><div class="line">  FXL_DCHECK(spec.IsValidOneBufferMesh());</div><div class="line">  size_t outer_vertex_count = 4;</div><div class="line">  while (subdivisions-- &gt; 0) &#123;</div><div class="line">    outer_vertex_count *= 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  size_t vertex_count = outer_vertex_count + 1;  // Add 1 for center vertex.</div><div class="line">  size_t index_count = outer_vertex_count * 3;</div><div class="line"></div><div class="line">  auto builder = factory-&gt;NewMeshBuilder(spec, vertex_count, index_count);</div><div class="line"></div><div class="line">  // Generate vertex positions.</div><div class="line">  constexpr size_t kMaxVertexSize = 100;</div><div class="line">  uint8_t vertex[kMaxVertexSize];</div><div class="line">  auto vertex_p =</div><div class="line">      GetVertexAttributePointers(vertex, kMaxVertexSize, spec, builder);</div><div class="line"></div><div class="line">  // Build center vertex.</div><div class="line">  FXL_CHECK(vertex_p.pos2);</div><div class="line">  (*vertex_p.pos2) = center;</div><div class="line">  if (vertex_p.uv)</div><div class="line">    (*vertex_p.uv) = vec2(0.5f, 0.5f);</div><div class="line">  if (vertex_p.pos_offset)</div><div class="line">    (*vertex_p.pos_offset) = vec2(0.f, 0.f);</div><div class="line">  // TODO: This is an undesirable singularity.  Perhaps it would be better to</div><div class="line">  // treat circles as a ring with inner radius of zero?</div><div class="line">  if (vertex_p.perim)</div><div class="line">    (*vertex_p.perim) = 0.f;</div><div class="line">  builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line"></div><div class="line">  // Outer vertices.</div><div class="line">  const float outer_vertex_count_reciprocal = 1.f / outer_vertex_count;</div><div class="line">  const float radian_step = 2 * M_PI / outer_vertex_count;</div><div class="line">  for (size_t i = 0; i &lt; outer_vertex_count; ++i) &#123;</div><div class="line">    float radians = i * radian_step;</div><div class="line"></div><div class="line">    // Direction of the current vertex from the center of the circle.</div><div class="line">    vec2 dir(sin(radians), cos(radians));</div><div class="line"></div><div class="line">    (*vertex_p.pos2) = dir * radius + center;</div><div class="line">    if (vertex_p.uv)</div><div class="line">      (*vertex_p.uv) = 0.5f * (dir + vec2(1.f, 1.f));</div><div class="line">    if (vertex_p.pos_offset)</div><div class="line">      (*vertex_p.pos_offset) = dir * offset_magnitude;</div><div class="line">    if (vertex_p.perim)</div><div class="line">      (*vertex_p.perim) = i * outer_vertex_count_reciprocal;</div><div class="line"></div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Vertex indices.</div><div class="line">  for (size_t i = 1; i &lt; outer_vertex_count; ++i) &#123;</div><div class="line">    builder-&gt;AddIndex(0);</div><div class="line">    builder-&gt;AddIndex(i + 1);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">  &#125;</div><div class="line">  builder-&gt;AddIndex(0);</div><div class="line">  builder-&gt;AddIndex(1);</div><div class="line">  builder-&gt;AddIndex(outer_vertex_count);</div><div class="line"></div><div class="line">  auto mesh = builder-&gt;Build();</div><div class="line">  FXL_DCHECK(mesh-&gt;num_indices() == index_count);</div><div class="line">  FXL_DCHECK(mesh-&gt;bounding_box() ==</div><div class="line">             BoundingBox(vec3(center.x - radius, center.y - radius, 0),</div><div class="line">                         vec3(center.x + radius, center.y + radius, 0)));</div><div class="line">  return mesh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面的mesh过程计算好了一个通用的Circle的mesh信息，<br>和SimpleRectangle的情况类似，具体绘制Circle的时候根据具体的显示位置(center_position.x/y/z)和显示的大小(radius)来绘制Circle.<br>指定显示的位置可以理解为平移，指定显示的大小可以理解为缩放.<br>这个平移/缩放过程也是通过设置transform矩阵来实现，在shader代码中把这个矩阵和通用Circle的vertex坐标相乘.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Object Object::NewCircle(<span class="keyword">const</span> vec3&amp; center_position, <span class="keyword">float</span> radius,</div><div class="line">                         MaterialPtr material) &#123;</div><div class="line">  <span class="function">mat4 <span class="title">transform</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">  transform[<span class="number">0</span>][<span class="number">0</span>] = radius;</div><div class="line">  transform[<span class="number">1</span>][<span class="number">1</span>] = radius;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">0</span>] = center_position.x;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">1</span>] = center_position.y;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">2</span>] = center_position.z;</div><div class="line">  <span class="keyword">return</span> Object(transform, Shape(Shape::Type::kCircle), <span class="built_in">std</span>::move(material));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x25-RoundRectangle"><a href="#0x25-RoundRectangle" class="headerlink" title="0x25 RoundRectangle"></a>0x25 RoundRectangle</h2><p>下面分析生成圆角Rectangle的mesh的代码.</p>
<p>该过程把圆角矩形mesh成三角形，其中的顶点分布如下图所示,</p>
<p>其中每个圆角部分被拆分成8个小扇形.</p>
<p><img src="/2019/02/16/Mesh-support-in-Escher/roundedrect.jpg" alt="RoundedRect"></p>
<p>0 ~ 12 顶点是中间部分的矩形对应的顶点.<br>13 ~ 19 顶点是左上角部分的圆角对应的顶点.<br>20 ~ 26 顶点是右上角部分的圆角对应的顶点.<br>27 ~ 33 顶点是右下角部分的圆角对应的顶点.<br>34 ~ 40 顶点是左下角部分的圆角对应的顶点.</p>
<p>NewRoundedRect是总的入口函数，其中会调用GenerateRoundedRectIndices()来根据顶点来构造三角形，调用GenerateRoundedRectVertexUVs()生成纹理坐标，最后调用GenerateRoundedRectVertexPositionsFromUVs()来生成顶点坐标.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">MeshPtr RoundedRectFactory::NewRoundedRect(</div><div class="line">    <span class="keyword">const</span> RoundedRectSpec&amp; spec, <span class="keyword">const</span> MeshSpec&amp; mesh_spec,</div><div class="line">    BatchGpuUploader* batch_gpu_uploader) &#123;</div><div class="line">  FXL_DCHECK(batch_gpu_uploader);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> index_buffer = GetIndexBuffer(spec, mesh_spec, batch_gpu_uploader);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> counts = GetRoundedRectMeshVertexAndIndexCounts(spec);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> vertex_count = counts.first;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> index_count = counts.second;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> primary_buffer_stride = mesh_spec.stride(<span class="number">0</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> secondary_buffer_stride = mesh_spec.stride(<span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> vertex_buffer_size =</div><div class="line">      vertex_count * (primary_buffer_stride + secondary_buffer_stride);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> vertex_buffer =</div><div class="line">      buffer_factory_.NewBuffer(vertex_buffer_size,</div><div class="line">                                vk::BufferUsageFlagBits::eVertexBuffer |</div><div class="line">                                    vk::BufferUsageFlagBits::eTransferDst,</div><div class="line">                                vk::MemoryPropertyFlagBits::eDeviceLocal);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> bounding_box =</div><div class="line">      BoundingBox::NewChecked(<span class="number">-0.5f</span> * vec3(spec.width, spec.height, <span class="number">0</span>),</div><div class="line">                              <span class="number">0.5f</span> * vec3(spec.width, spec.height, <span class="number">0</span>), <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (mesh_spec.vertex_buffer_count()) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</div><div class="line">      <span class="keyword">auto</span> writer = batch_gpu_uploader-&gt;AcquireWriter(vertex_buffer_size);</div><div class="line">      GenerateRoundedRectVertices(spec, mesh_spec, writer-&gt;host_ptr(),</div><div class="line">                                  writer-&gt;size());</div><div class="line">      writer-&gt;WriteBuffer(vertex_buffer, &#123;<span class="number">0</span>, <span class="number">0</span>, vertex_buffer-&gt;size()&#125;);</div><div class="line">      batch_gpu_uploader-&gt;PostWriter(<span class="built_in">std</span>::move(writer));</div><div class="line"></div><div class="line">      <span class="keyword">return</span> fxl::MakeRefCounted&lt;Mesh&gt;(</div><div class="line">          <span class="keyword">static_cast</span>&lt;ResourceRecycler*&gt;(<span class="keyword">this</span>), mesh_spec, bounding_box,</div><div class="line">          vertex_count, index_count, vertex_buffer, <span class="built_in">std</span>::move(index_buffer));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</div><div class="line">      <span class="keyword">auto</span> writer = batch_gpu_uploader-&gt;AcquireWriter(vertex_buffer_size);</div><div class="line">      GenerateRoundedRectVertices(</div><div class="line">          spec, mesh_spec, writer-&gt;host_ptr(),</div><div class="line">          vertex_count * primary_buffer_stride,</div><div class="line">          writer-&gt;host_ptr() + vertex_count * primary_buffer_stride,</div><div class="line">          vertex_count * secondary_buffer_stride);</div><div class="line">      writer-&gt;WriteBuffer(vertex_buffer, &#123;<span class="number">0</span>, <span class="number">0</span>, vertex_buffer-&gt;size()&#125;);</div><div class="line">      batch_gpu_uploader-&gt;PostWriter(<span class="built_in">std</span>::move(writer));</div><div class="line"></div><div class="line">      <span class="keyword">return</span> fxl::MakeRefCounted&lt;Mesh&gt;(</div><div class="line">          <span class="keyword">static_cast</span>&lt;ResourceRecycler*&gt;(<span class="keyword">this</span>), mesh_spec, bounding_box,</div><div class="line">          index_count, <span class="built_in">std</span>::move(index_buffer), <span class="number">0</span>, vertex_count, vertex_buffer,</div><div class="line">          <span class="number">0</span>, <span class="built_in">std</span>::move(vertex_buffer), vertex_count * primary_buffer_stride);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      FXL_CHECK(<span class="literal">false</span>) &lt;&lt; <span class="string">"unsupported vertex buffer count: "</span></div><div class="line">                       &lt;&lt; mesh_spec.vertex_buffer_count();</div><div class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的代码是构造圆角Rectangle中的三角形的过程，indices中保存的是把这些顶点拼接成三角形的顶点索引.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateRoundedRectIndices</span><span class="params">(<span class="keyword">const</span> RoundedRectSpec&amp; spec,</span></span></div><div class="line">                                <span class="keyword">const</span> MeshSpec&amp; mesh_spec, <span class="keyword">void</span>* indices_out,</div><div class="line">                                <span class="keyword">uint32_t</span> max_bytes) &#123;</div><div class="line">  TRACE_DURATION(<span class="string">"gfx"</span>, <span class="string">"escher::GenerateRoundedRectIndices"</span>);</div><div class="line"></div><div class="line">  FXL_DCHECK(max_bytes &gt;= kIndexCount * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</div><div class="line">  <span class="keyword">uint32_t</span>* indices = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;(indices_out);</div><div class="line"></div><div class="line">  <span class="comment">// Central square triangles.</span></div><div class="line">  indices[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  indices[<span class="number">1</span>] = <span class="number">4</span>;</div><div class="line">  indices[<span class="number">2</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">3</span>] = <span class="number">0</span>;</div><div class="line">  indices[<span class="number">4</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">5</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">6</span>] = <span class="number">0</span>;</div><div class="line">  indices[<span class="number">7</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">8</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">9</span>] = <span class="number">0</span>;</div><div class="line">  indices[<span class="number">10</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">11</span>] = <span class="number">4</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "Cross arm 1"  triangles.</span></div><div class="line">  indices[<span class="number">12</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">13</span>] = <span class="number">7</span>;</div><div class="line">  indices[<span class="number">14</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">15</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">16</span>] = <span class="number">6</span>;</div><div class="line">  indices[<span class="number">17</span>] = <span class="number">7</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "Cross arm 2"  triangles.</span></div><div class="line">  indices[<span class="number">18</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">19</span>] = <span class="number">9</span>;</div><div class="line">  indices[<span class="number">20</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">21</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">22</span>] = <span class="number">8</span>;</div><div class="line">  indices[<span class="number">23</span>] = <span class="number">9</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "Cross arm 3"  triangles.</span></div><div class="line">  indices[<span class="number">24</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">25</span>] = <span class="number">11</span>;</div><div class="line">  indices[<span class="number">26</span>] = <span class="number">4</span>;</div><div class="line">  indices[<span class="number">27</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">28</span>] = <span class="number">10</span>;</div><div class="line">  indices[<span class="number">29</span>] = <span class="number">11</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "Cross arm 4"  triangles.</span></div><div class="line">  indices[<span class="number">30</span>] = <span class="number">4</span>;</div><div class="line">  indices[<span class="number">31</span>] = <span class="number">5</span>;</div><div class="line">  indices[<span class="number">32</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">33</span>] = <span class="number">4</span>;</div><div class="line">  indices[<span class="number">34</span>] = <span class="number">12</span>;</div><div class="line">  indices[<span class="number">35</span>] = <span class="number">5</span>;</div><div class="line"></div><div class="line">  <span class="comment">// WARNING: here's where it gets confusing; the number of indices generated is</span></div><div class="line">  <span class="comment">// dependent on kCornerDivisions.</span></div><div class="line"></div><div class="line">  <span class="comment">// We've already generated output indices for the "cross triangles".</span></div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kCrossTriangles = <span class="number">12</span>;</div><div class="line">  <span class="comment">// Holds the position of the next index to output.</span></div><div class="line">  <span class="keyword">uint32_t</span> out = kCrossTriangles * <span class="number">3</span>;</div><div class="line">  <span class="comment">// Holds the highest index of any vertex used thus far (the central "cross"</span></div><div class="line">  <span class="comment">// consists of 13 vertices, whose indices are 0-12).</span></div><div class="line">  <span class="keyword">uint32_t</span> highest_index = <span class="number">12</span>;</div><div class="line"></div><div class="line">  <span class="comment">// These are the indices of the 4 triangles that would be output if</span></div><div class="line">  <span class="comment">// kCornerDivisions were zero.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> corner_tris[] = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">11</span>&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// For each corner, generate wedges in clockwise order.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> corner = <span class="number">0</span>; corner &lt; <span class="number">4</span>; ++corner) &#123;</div><div class="line">    <span class="comment">// Index of the vertex at the center of the current corner.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> center = corner_tris[corner * <span class="number">3</span>];</div><div class="line">    <span class="comment">// As we move clockwise around the corner, this holds the index of the</span></div><div class="line">    <span class="comment">// previous perimeter vertex.</span></div><div class="line">    <span class="keyword">uint32_t</span> prev = corner_tris[corner * <span class="number">3</span> + <span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">      indices[out++] = center;</div><div class="line">      indices[out++] = prev;</div><div class="line">      indices[out++] = prev = ++highest_index;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// One last triangle (or the only one, if kCornerDivisions == 0).</span></div><div class="line">    indices[out++] = center;</div><div class="line">    indices[out++] = prev;</div><div class="line">    indices[out++] = corner_tris[corner * <span class="number">3</span> + <span class="number">1</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  FXL_DCHECK(out == kIndexCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面函数计算这些点(0 ~ 40)对应的纹理(uv)坐标.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VertT&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateRoundedRectVertexUVs</span><span class="params">(<span class="keyword">const</span> RoundedRectSpec&amp; spec, VertT* verts)</span> </span>&#123;</div><div class="line">  TRACE_DURATION(<span class="string">"gfx"</span>, <span class="string">"escher::GenerateRoundedRectVertexUVs"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">float</span> width = spec.width;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">float</span> height = spec.height;</div><div class="line"></div><div class="line">  <span class="comment">// First compute UV coordinates of the four "corner centers".</span></div><div class="line">  verts[<span class="number">1</span>].uv =</div><div class="line">      vec2(spec.top_left_radius / width, spec.top_left_radius / height);</div><div class="line">  verts[<span class="number">2</span>].uv =</div><div class="line">      vec2(<span class="number">1.f</span> - spec.top_right_radius / width, spec.top_right_radius / height);</div><div class="line">  verts[<span class="number">3</span>].uv = vec2(<span class="number">1.f</span> - spec.bottom_right_radius / width,</div><div class="line">                     <span class="number">1.f</span> - spec.bottom_right_radius / height);</div><div class="line">  verts[<span class="number">4</span>].uv = vec2(spec.bottom_left_radius / width,</div><div class="line">                     <span class="number">1.f</span> - spec.bottom_left_radius / height);</div><div class="line"></div><div class="line">  <span class="comment">// The "center" vertex is the average of the four "corner centers".</span></div><div class="line">  verts[<span class="number">0</span>].uv =</div><div class="line">      <span class="number">0.25f</span> * ((verts[<span class="number">1</span>].uv + verts[<span class="number">2</span>].uv + verts[<span class="number">3</span>].uv + verts[<span class="number">4</span>].uv));</div><div class="line"></div><div class="line">  <span class="comment">// Next, compute UV coords for the 8 vertices where the rounded corners meet</span></div><div class="line">  <span class="comment">// the straight side sections.</span></div><div class="line">  verts[<span class="number">6</span>].uv = vec2(verts[<span class="number">1</span>].uv.x, <span class="number">0.f</span>);</div><div class="line">  verts[<span class="number">7</span>].uv = vec2(verts[<span class="number">2</span>].uv.x, <span class="number">0.f</span>);</div><div class="line">  verts[<span class="number">8</span>].uv = vec2(<span class="number">1.f</span>, verts[<span class="number">2</span>].uv.y);</div><div class="line">  verts[<span class="number">9</span>].uv = vec2(<span class="number">1.f</span>, verts[<span class="number">3</span>].uv.y);</div><div class="line">  verts[<span class="number">10</span>].uv = vec2(verts[<span class="number">3</span>].uv.x, <span class="number">1.f</span>);</div><div class="line">  verts[<span class="number">11</span>].uv = vec2(verts[<span class="number">4</span>].uv.x, <span class="number">1.f</span>);</div><div class="line">  verts[<span class="number">12</span>].uv = vec2(<span class="number">0.f</span>, verts[<span class="number">4</span>].uv.y);</div><div class="line">  verts[<span class="number">5</span>].uv = vec2(<span class="number">0.f</span>, verts[<span class="number">1</span>].uv.y);</div><div class="line"></div><div class="line">  <span class="comment">// Next, compute UV coords for the vertices that make up the rounded corners.</span></div><div class="line">  <span class="comment">// We start at index 13; indices 0-12 were computed above.</span></div><div class="line">  <span class="keyword">uint32_t</span> out = <span class="number">13</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">float</span> kPI = <span class="number">3.14159265f</span>;</div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">float</span> kAngleStep = kPI / <span class="number">2</span> / (kCornerDivisions + <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Generate UV coordinates for top-left corner.</span></div><div class="line">  <span class="keyword">float</span> angle = kPI + kAngleStep;</div><div class="line">  vec2 scale =</div><div class="line">      vec2(spec.top_left_radius / width, spec.top_left_radius / height);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">    verts[out++].uv = verts[<span class="number">1</span>].uv + vec2(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle)) * scale;</div><div class="line">    angle += kAngleStep;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate UV coordinates for top-right corner.</span></div><div class="line">  angle = <span class="number">1.5f</span> * kPI + kAngleStep;</div><div class="line">  scale = vec2(spec.top_right_radius / width, spec.top_right_radius / height);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">    verts[out++].uv = verts[<span class="number">2</span>].uv + vec2(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle)) * scale;</div><div class="line">    angle += kAngleStep;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate UV coordinates for bottom-right corner.</span></div><div class="line">  angle = kAngleStep;</div><div class="line">  scale =</div><div class="line">      vec2(spec.bottom_right_radius / width, spec.bottom_right_radius / height);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">    verts[out++].uv = verts[<span class="number">3</span>].uv + vec2(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle)) * scale;</div><div class="line">    angle += kAngleStep;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate UV coordinates for bottom-right corner.</span></div><div class="line">  angle = <span class="number">0.5f</span> * kPI + kAngleStep;</div><div class="line">  scale =</div><div class="line">      vec2(spec.bottom_left_radius / width, spec.bottom_left_radius / height);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">    verts[out++].uv = verts[<span class="number">4</span>].uv + vec2(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle)) * scale;</div><div class="line">    angle += kAngleStep;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面函数计算这些点(0 ~ 40)对应的顶点坐标，根据对应的纹理坐标来计算得到.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Helper for GenerateRoundedRectVertices().</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> UvVertT, <span class="keyword">typename</span> PosVertT&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateRoundedRectVertexPositionsFromUVs</span><span class="params">(<span class="keyword">const</span> RoundedRectSpec&amp; spec,</span></span></div><div class="line">                                               UvVertT* uv_verts,</div><div class="line">                                               PosVertT* pos_verts) &#123;</div><div class="line">  TRACE_DURATION(<span class="string">"gfx"</span>, <span class="string">"escher::GenerateRoundedRectVertexPositionsFromUVs"</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">const</span> vec2 <span class="title">extent</span><span class="params">(spec.width, spec.height)</span></span>;</div><div class="line">  <span class="keyword">const</span> vec2 offset = <span class="number">-0.5f</span> * extent;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kVertexCount; ++i) &#123;</div><div class="line">    pos_verts[i].pos = uv_verts[i].uv * extent + offset;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x26-Sphere"><a href="#0x26-Sphere" class="headerlink" title="0x26 Sphere"></a>0x26 Sphere</h2><p>下面是构造Sphere的mesh的代码.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">MeshPtr <span class="title">NewSphereMesh</span><span class="params">(MeshBuilderFactory* factory, <span class="keyword">const</span> MeshSpec&amp; spec,</span></span></div><div class="line">                      <span class="keyword">int</span> subdivisions, vec3 center, <span class="keyword">float</span> radius) &#123;</div><div class="line">  FXL_DCHECK(subdivisions &gt;= <span class="number">0</span>);</div><div class="line">  FXL_DCHECK(spec.IsValidOneBufferMesh());</div><div class="line">  <span class="keyword">size_t</span> vertex_count = <span class="number">9</span>;</div><div class="line">  <span class="keyword">size_t</span> triangle_count = <span class="number">8</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subdivisions; ++i) &#123;</div><div class="line">    <span class="comment">// At each level of subdivision, an additional vertex is added for each</span></div><div class="line">    <span class="comment">// triangle, and each triangle is split into three.</span></div><div class="line">    vertex_count += triangle_count;</div><div class="line">    triangle_count *= <span class="number">3</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Populate initial octahedron.</span></div><div class="line">  <span class="keyword">auto</span> builder =</div><div class="line">      factory-&gt;NewMeshBuilder(spec, vertex_count, triangle_count * <span class="number">3</span>);</div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kMaxVertexSize = <span class="number">100</span>;</div><div class="line">  <span class="keyword">uint8_t</span> vertex[kMaxVertexSize];</div><div class="line">  <span class="keyword">auto</span> vertex_p =</div><div class="line">      GetVertexAttributePointers(vertex, kMaxVertexSize, spec, builder);</div><div class="line">  FXL_CHECK(vertex_p.pos3);</div><div class="line"></div><div class="line">  <span class="comment">// Positions and UV-coordinates for the initial octahedron.  The vertex with</span></div><div class="line">  <span class="comment">// position (-radius, 0, 0) is replicated 4 times, with different UV-coords</span></div><div class="line">  <span class="comment">// each time.  This is a consequence of surface parameterization that is</span></div><div class="line">  <span class="comment">// described in the header file.</span></div><div class="line">  <span class="keyword">const</span> vec3 positions[] = &#123;vec3(radius, <span class="number">0.f</span>, <span class="number">0.f</span>),  vec3(<span class="number">0.f</span>, <span class="number">0.f</span>, radius),</div><div class="line">                            vec3(<span class="number">0.f</span>, -radius, <span class="number">0.f</span>), vec3(<span class="number">0.f</span>, <span class="number">0.f</span>, -radius),</div><div class="line">                            vec3(<span class="number">0.f</span>, radius, <span class="number">0.f</span>),  vec3(-radius, <span class="number">0.f</span>, <span class="number">0.f</span>),</div><div class="line">                            vec3(-radius, <span class="number">0.f</span>, <span class="number">0.f</span>), vec3(-radius, <span class="number">0.f</span>, <span class="number">0.f</span>),</div><div class="line">                            vec3(-radius, <span class="number">0.f</span>, <span class="number">0.f</span>)&#125;;</div><div class="line">  <span class="keyword">const</span> vec2 uv_coords[] = &#123;vec2(<span class="number">.5</span>f, <span class="number">.5</span>f), vec2(<span class="number">1.f</span>, <span class="number">.5</span>f), vec2(<span class="number">.5</span>f, <span class="number">0.f</span>),</div><div class="line">                            vec2(<span class="number">0.f</span>, <span class="number">.5</span>f), vec2(<span class="number">.5</span>f, <span class="number">1.f</span>), vec2(<span class="number">0.f</span>, <span class="number">0.f</span>),</div><div class="line">                            vec2(<span class="number">1.f</span>, <span class="number">0.f</span>), vec2(<span class="number">1.f</span>, <span class="number">1.f</span>), vec2(<span class="number">0.f</span>, <span class="number">1.f</span>)&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</div><div class="line">    (*vertex_p.pos3) = positions[i] + center;</div><div class="line">    <span class="keyword">if</span> (vertex_p.uv) &#123;</div><div class="line">      (*vertex_p.uv) = uv_coords[i];</div><div class="line">    &#125;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line">  &#125;</div><div class="line">  builder-&gt;AddTriangle(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">      .AddTriangle(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">      .AddTriangle(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">      .AddTriangle(<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>)</div><div class="line">      .AddTriangle(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line">      .AddTriangle(<span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>)</div><div class="line">      .AddTriangle(<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>)</div><div class="line">      .AddTriangle(<span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line">  <span class="comment">// TODO(ES-32): this is a hack to ease implementation.  We don't currently</span></div><div class="line">  <span class="comment">// need any tessellated spheres; this is just a way to verify that 3D meshes</span></div><div class="line">  <span class="comment">// are working properly.</span></div><div class="line">  FXL_DCHECK(spec.attributes[<span class="number">0</span>] ==</div><div class="line">             (MeshAttribute::kPosition3D | MeshAttribute::kUV))</div><div class="line">      &lt;&lt; <span class="string">"Tessellated sphere must have UV-coordinates."</span>;</div><div class="line">  <span class="keyword">size_t</span> position_offset = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(vertex_p.pos3) - vertex;</div><div class="line">  <span class="keyword">size_t</span> uv_offset = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(vertex_p.uv) - vertex;</div><div class="line">  <span class="keyword">while</span> (subdivisions-- &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// For each level of subdivision, iterate over all existing triangles and</span></div><div class="line">    <span class="comment">// split them into three.</span></div><div class="line">    <span class="comment">// TODO(ES-32): see comment in header file... this approach is broken, but</span></div><div class="line">    <span class="comment">// sufficient for our current purpose.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> subdiv_triangle_count = builder-&gt;index_count() / <span class="number">3</span>;</div><div class="line">    FXL_DCHECK(subdiv_triangle_count * <span class="number">3</span> == builder-&gt;index_count());</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> tri_ind = <span class="number">0</span>; tri_ind &lt; subdiv_triangle_count; ++tri_ind) &#123;</div><div class="line">      <span class="comment">// Obtain indices for the current triangle, and the position/UV coords for</span></div><div class="line">      <span class="comment">// the corresponding vertices.</span></div><div class="line">      <span class="keyword">uint32_t</span>* tri = builder-&gt;GetIndex(tri_ind * <span class="number">3</span>);</div><div class="line">      <span class="keyword">uint32_t</span> ind0 = tri[<span class="number">0</span>];</div><div class="line">      <span class="keyword">uint32_t</span> ind1 = tri[<span class="number">1</span>];</div><div class="line">      <span class="keyword">uint32_t</span> ind2 = tri[<span class="number">2</span>];</div><div class="line">      <span class="keyword">uint8_t</span>* vert0 = builder-&gt;GetVertex(ind0);</div><div class="line">      <span class="keyword">uint8_t</span>* vert1 = builder-&gt;GetVertex(ind1);</div><div class="line">      <span class="keyword">uint8_t</span>* vert2 = builder-&gt;GetVertex(ind2);</div><div class="line">      vec3 pos0 = *<span class="keyword">reinterpret_cast</span>&lt;vec3*&gt;(vert0 + position_offset);</div><div class="line">      vec3 pos1 = *<span class="keyword">reinterpret_cast</span>&lt;vec3*&gt;(vert1 + position_offset);</div><div class="line">      vec3 pos2 = *<span class="keyword">reinterpret_cast</span>&lt;vec3*&gt;(vert2 + position_offset);</div><div class="line">      vec2 uv0 = *<span class="keyword">reinterpret_cast</span>&lt;vec2*&gt;(vert0 + uv_offset);</div><div class="line">      vec2 uv1 = *<span class="keyword">reinterpret_cast</span>&lt;vec2*&gt;(vert1 + uv_offset);</div><div class="line">      vec2 uv2 = *<span class="keyword">reinterpret_cast</span>&lt;vec2*&gt;(vert2 + uv_offset);</div><div class="line"></div><div class="line">      <span class="comment">// Create a new vertex by averaging the existing vertex attributes.</span></div><div class="line">      (*vertex_p.pos3) =</div><div class="line">          center + radius * glm::normalize((pos0 + pos1 + pos2) / <span class="number">3.f</span> - center);</div><div class="line">      (*vertex_p.uv) = (uv0 + uv1 + uv2) / <span class="number">3.f</span>;</div><div class="line">      builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line"></div><div class="line">      <span class="comment">// Replace the current triangle in-place with a new triangle that refers</span></div><div class="line">      <span class="comment">// to the new vertex.  Then, add two new triangles that also refer to the</span></div><div class="line">      <span class="comment">// new vertex.</span></div><div class="line">      <span class="keyword">uint32_t</span> new_ind = builder-&gt;vertex_count() - <span class="number">1</span>;</div><div class="line">      tri[<span class="number">2</span>] = new_ind;</div><div class="line">      builder-&gt;AddTriangle(ind1, ind2, new_ind)</div><div class="line">          .AddTriangle(ind2, ind0, new_ind);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> builder-&gt;Build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x27-Ring"><a href="#0x27-Ring" class="headerlink" title="0x27 Ring"></a>0x27 Ring</h2><p>下面分析Ring的mesh是如何生成的, Ring是由内圈和外圈包含的区域组成, 内圈区域内是透明的, 实际上Ring的mesh没有包括内圈，也就是说渲染的时候不会去绘制内圈区域, 所以mesh生成的绘制区域只需要包括内圈和外圈组成的区域，mesh的过程也就是把内圈和外圈之间的区域拆分成许多小三角形.</p>
<p>下面函数的参数中，<br>subdivisions指定Ring的拆分数.<br>center指定Circle的中心点坐标.<br>outer_radius指定Ring的外圈半径.<br>inner_radius指定Ring的内圈半径.</p>
<p>生成mesh的时候把Ring分成(subdivisions*4)个小扇形，这些小扇形会和Ring的内圈和外圈相交,<br>指定相交点的vertex值，然后把这些vertex组成的triangle，vertex的index值指定给mesh的index.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">MeshPtr NewRingMesh(MeshBuilderFactory* factory, const MeshSpec&amp; spec,</div><div class="line">                    int subdivisions, vec2 center, float outer_radius,</div><div class="line">                    float inner_radius, float outer_offset_magnitude,</div><div class="line">                    float inner_offset_magnitude) &#123;</div><div class="line">  // Compute the number of vertices in the tessellated circle.</div><div class="line">  FXL_DCHECK(subdivisions &gt;= 0);</div><div class="line">  FXL_DCHECK(spec.IsValidOneBufferMesh());</div><div class="line">  size_t outer_vertex_count = 4;</div><div class="line">  while (subdivisions-- &gt; 0) &#123;</div><div class="line">    outer_vertex_count *= 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  size_t vertex_count = outer_vertex_count * 2;</div><div class="line">  size_t index_count = outer_vertex_count * 6;</div><div class="line"></div><div class="line">  auto builder = factory-&gt;NewMeshBuilder(spec, vertex_count, index_count);</div><div class="line"></div><div class="line">  // Generate vertex positions.</div><div class="line">  constexpr size_t kMaxVertexSize = 100;</div><div class="line">  uint8_t vertex[kMaxVertexSize];</div><div class="line">  auto vertex_p =</div><div class="line">      GetVertexAttributePointers(vertex, kMaxVertexSize, spec, builder);</div><div class="line">  FXL_CHECK(vertex_p.pos2);</div><div class="line"></div><div class="line">  const float outer_vertex_count_reciprocal = 1.f / outer_vertex_count;</div><div class="line">  const float radian_step = 2 * M_PI / outer_vertex_count;</div><div class="line">  for (size_t i = 0; i &lt; outer_vertex_count; ++i) &#123;</div><div class="line">    float radians = i * radian_step;</div><div class="line"></div><div class="line">    // Direction of the current vertex from the center of the circle.</div><div class="line">    vec2 dir(sin(radians), cos(radians));</div><div class="line"></div><div class="line">    // Build outer-ring vertex.</div><div class="line">    (*vertex_p.pos2) = dir * outer_radius + center;</div><div class="line">    if (vertex_p.uv) &#123;</div><div class="line">      // Munge the texcoords slightly to avoid wrapping artifacts.  This matters</div><div class="line">      // when both:</div><div class="line">      //   - the vk::SamplerAddressMode is eRepeat</div><div class="line">      //   - the vk::Filter is eLinear</div><div class="line">      (*vertex_p.uv) = 0.49f * (dir + vec2(1.f, 1.02f));</div><div class="line">      // TODO(ES-108): once we can specify a SamplerAddressMode of eClampToEdge,</div><div class="line">      // remove the hack above and replace it with the code below:</div><div class="line">      // (*vertex_p.uv) = 0.5f * (dir + vec2(1.f, 1.f));</div><div class="line">    &#125;</div><div class="line">    if (vertex_p.pos_offset)</div><div class="line">      (*vertex_p.pos_offset) = dir * outer_offset_magnitude;</div><div class="line">    if (vertex_p.perim)</div><div class="line">      (*vertex_p.perim) = i * outer_vertex_count_reciprocal;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line"></div><div class="line">    // Build inner-ring vertex.  Only the position and offset may differ from</div><div class="line">    // the corresponding outer-ring vertex.</div><div class="line">    (*vertex_p.pos2) = dir * inner_radius + center;</div><div class="line">    if (vertex_p.pos_offset) &#123;</div><div class="line">      // Positive offsets point inward, toward the center of the circle.</div><div class="line">      (*vertex_p.pos_offset) = dir * -inner_offset_magnitude;</div><div class="line">    &#125;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Generate vertex indices.</div><div class="line">  for (size_t i = 2; i &lt; vertex_count; i += 2) &#123;</div><div class="line">    builder-&gt;AddIndex(i - 2);</div><div class="line">    builder-&gt;AddIndex(i - 1);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">    builder-&gt;AddIndex(i - 1);</div><div class="line">    builder-&gt;AddIndex(i + 1);</div><div class="line">  &#125;</div><div class="line">  builder-&gt;AddIndex(vertex_count - 2);</div><div class="line">  builder-&gt;AddIndex(vertex_count - 1);</div><div class="line">  builder-&gt;AddIndex(0);</div><div class="line">  builder-&gt;AddIndex(0);</div><div class="line">  builder-&gt;AddIndex(vertex_count - 1);</div><div class="line">  builder-&gt;AddIndex(1);</div><div class="line"></div><div class="line">  auto mesh = builder-&gt;Build();</div><div class="line">  FXL_DCHECK(mesh-&gt;num_indices() == index_count);</div><div class="line">  FXL_DCHECK(</div><div class="line">      mesh-&gt;bounding_box() ==</div><div class="line">      BoundingBox(vec3(center.x - outer_radius, center.y - outer_radius, 0),</div><div class="line">                  vec3(center.x + outer_radius, center.y + outer_radius, 0)));</div><div class="line">  return mesh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/graphics-vulkan/" rel="tag"># graphics vulkan</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/" rel="next" title="How vulkan benefit from multithead on cpu">
                <i class="fa fa-chevron-left"></i> How vulkan benefit from multithead on cpu
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/" rel="prev" title="How stencil buffer work in graphics pipeline">
                How stencil buffer work in graphics pipeline <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Kevin Wen" />
          <p class="site-author-name" itemprop="name">Kevin Wen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x1-总体介绍"><span class="nav-number">1.</span> <span class="nav-text">0x1 总体介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x2-各种shape的mesh过程"><span class="nav-number">2.</span> <span class="nav-text">0x2 各种shape的mesh过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x21-MeshBuilder介绍"><span class="nav-number">2.1.</span> <span class="nav-text">0x21 MeshBuilder介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x22-SimpleRectangle"><span class="nav-number">2.2.</span> <span class="nav-text">0x22 SimpleRectangle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x23-Rectangle"><span class="nav-number">2.3.</span> <span class="nav-text">0x23 Rectangle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x24-Circle"><span class="nav-number">2.4.</span> <span class="nav-text">0x24 Circle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x25-RoundRectangle"><span class="nav-number">2.5.</span> <span class="nav-text">0x25 RoundRectangle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x26-Sphere"><span class="nav-number">2.6.</span> <span class="nav-text">0x26 Sphere</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x27-Ring"><span class="nav-number">2.7.</span> <span class="nav-text">0x27 Ring</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Wen</span>
</div>


<div> <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
访问量 <span id="busuanzi_value_site_pv"></span>
访问人数 <span id="busuanzi_value_site_uv"></span>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("orq8xxsDQDXKiHdqSRcjlflB-gzGzoHsz", "ecCFdIcWDfbJKQOCiLFf1EBm");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
