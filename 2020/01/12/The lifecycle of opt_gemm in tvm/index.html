<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="artificial intelligence," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="0x0 简介TVM是目前比较热门的深度学习编译框架，本文对tvm的函数注册机制和执行机制进行介绍，这些函数作为在python和c++代码之间交互的接口，可以理解成python和c++之间有统一的command交互接口。理解了这个交互接口，对理解tvm从python到c++的完整执行流程有很大的帮助。另外本文后面以opt_gemm.py为例子，对tvm的从python到c++的执行流程进行了分析。">
<meta name="keywords" content="artificial intelligence">
<meta property="og:type" content="article">
<meta property="og:title" content="The lifecycle of opt_gemm in tvm">
<meta property="og:url" content="http://yoursite.com/2020/01/12/The lifecycle of opt_gemm in tvm/index.html">
<meta property="og:site_name" content="Kevin Wen&#39;s Blog">
<meta property="og:description" content="0x0 简介TVM是目前比较热门的深度学习编译框架，本文对tvm的函数注册机制和执行机制进行介绍，这些函数作为在python和c++代码之间交互的接口，可以理解成python和c++之间有统一的command交互接口。理解了这个交互接口，对理解tvm从python到c++的完整执行流程有很大的帮助。另外本文后面以opt_gemm.py为例子，对tvm的从python到c++的执行流程进行了分析。">
<meta property="og:image" content="http://yoursite.com/2020/01/12/The%20lifecycle%20of%20opt_gemm%20in%20tvm/set_body_typed.png">
<meta property="og:image" content="http://yoursite.com/2020/01/12/The%20lifecycle%20of%20opt_gemm%20in%20tvm/set_body_method.png">
<meta property="og:image" content="http://yoursite.com/2020/01/12/The%20lifecycle%20of%20opt_gemm%20in%20tvm/set_body.png">
<meta property="og:updated_time" content="2020-04-15T00:38:57.625Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The lifecycle of opt_gemm in tvm">
<meta name="twitter:description" content="0x0 简介TVM是目前比较热门的深度学习编译框架，本文对tvm的函数注册机制和执行机制进行介绍，这些函数作为在python和c++代码之间交互的接口，可以理解成python和c++之间有统一的command交互接口。理解了这个交互接口，对理解tvm从python到c++的完整执行流程有很大的帮助。另外本文后面以opt_gemm.py为例子，对tvm的从python到c++的执行流程进行了分析。">
<meta name="twitter:image" content="http://yoursite.com/2020/01/12/The%20lifecycle%20of%20opt_gemm%20in%20tvm/set_body_typed.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/12/The lifecycle of opt_gemm in tvm/"/>





  <title>The lifecycle of opt_gemm in tvm | Kevin Wen's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kevin Wen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/The lifecycle of opt_gemm in tvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">The lifecycle of opt_gemm in tvm</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-12T20:00:10+09:00">
                2020-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2020/01/12/The lifecycle of opt_gemm in tvm/" class="leancloud_visitors" data-flag-title="The lifecycle of opt_gemm in tvm">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="0x0-简介"><a href="#0x0-简介" class="headerlink" title="0x0 简介"></a>0x0 简介</h1><p>TVM是目前比较热门的深度学习编译框架，本文对tvm的函数注册机制和执行机制进行介绍，这些函数作为在python和c++代码之间交互的接口，可以理解成python和c++之间有统一的command交互接口。理解了这个交互接口，对理解tvm从python到c++的完整执行流程有很大的帮助。<br>另外本文后面以opt_gemm.py为例子，对tvm的从python到c++的执行流程进行了分析。</p>
<h1 id="0x1-函数注册"><a href="#0x1-函数注册" class="headerlink" title="0x1 函数注册"></a>0x1 函数注册</h1><p>TVM中所有上下层交互函数都封装到PackedFunc中，并且所有函数都保存在下面所示的Manager中，每一个函数都封装在Registry中，通过string作为key可以找到注册的函数并调用。tvm中使用的函数为什么要这样设计呢？好处是可以从python调用到这些函数的时候可以用统一的接口，简化接口层代码的编写，只需要把函数名作为key从Manager中找到对应的函数并调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// fmap以函数名称为key，保存函数列表</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Registry</span>:</span>:Manager &#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Registry*&gt; fmap;</div><div class="line">  <span class="comment">// mutex</span></div><div class="line">  <span class="built_in">std</span>::mutex mutex;</div><div class="line"></div><div class="line">  Manager() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Registry的定义如下，Registry提供接口把函数都封装到PackedFunc类型的变量中，后面会详细介绍这些接口。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Registry &#123;</div><div class="line"> public:</div><div class="line">  Registry&amp; set_body(PackedFunc::FType f) &#123;  // NOLINT(*)</div><div class="line">    return set_body(PackedFunc(f));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  template&lt;typename FLambda&gt;</div><div class="line">  Registry&amp; set_body_typed(FLambda f) &#123;</div><div class="line">    using FType = typename detail::function_signature&lt;FLambda&gt;::FType;</div><div class="line">    return set_body(TypedPackedFunc&lt;FType&gt;(std::move(f)).packed());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  template&lt;typename T, typename R, typename ...Args&gt;</div><div class="line">  Registry&amp; set_body_method(R (T::*f)(Args...) const) &#123;</div><div class="line">    auto fwrap = [f](const T target, Args... params) -&gt; R &#123;</div><div class="line">      // call method pointer</div><div class="line">      return (target.*f)(params...);</div><div class="line">    &#125;;</div><div class="line">    return set_body(TypedPackedFunc&lt;R(const T, Args...)&gt;(fwrap));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  template&lt;typename TObjectRef, typename TNode, typename R, typename ...Args,</div><div class="line">    typename = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, TObjectRef&gt;::value&gt;::type&gt;</div><div class="line">  Registry&amp; set_body_method(R (TNode::*f)(Args...)) &#123;</div><div class="line">    auto fwrap = [f](TObjectRef ref, Args... params) &#123;</div><div class="line">      TNode* target = ref.operator-&gt;();</div><div class="line">      // call method pointer</div><div class="line">      return (target-&gt;*f)(params...);</div><div class="line">    &#125;;</div><div class="line">    return set_body(TypedPackedFunc&lt;R(TObjectRef, Args...)&gt;(fwrap));</div><div class="line">  &#125;</div><div class="line">protected:</div><div class="line">  /*! \brief name of the function */</div><div class="line">  std::string name_;</div><div class="line">  /*! \brief internal packed function */</div><div class="line">  PackedFunc func_;</div><div class="line">  friend struct Manager;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>PackedFunc的定义如下。<br>PackedFunc内部使用std::function来保存函数对象。<br>TVMArgs提供了对函数参数的封装，可以包括多个参数。<br>TVMRetValue提供了对函数返回值的封装。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/*!</div><div class="line"> * \brief Packed function is a type-erased function.</div><div class="line"> *  The arguments are passed by packed format.</div><div class="line"> *</div><div class="line"> *  This is an useful unified interface to call generated functions,</div><div class="line"> *  It is the unified function function type of TVM.</div><div class="line"> *  It corresponds to TVMFunctionHandle in C runtime API.</div><div class="line"> */</div><div class="line">class PackedFunc &#123;</div><div class="line"> public:</div><div class="line">   /*!</div><div class="line">   * \brief The internal std::function</div><div class="line">   * \param args The arguments to the function.</div><div class="line">   * \param rv The return value.</div><div class="line">   */</div><div class="line">  using FType = std::function&lt;void (TVMArgs args, TVMRetValue* rv)&gt;;</div><div class="line">  /*! \brief default constructor */</div><div class="line">  PackedFunc() &#123;&#125;</div><div class="line">  /*! \brief constructor from null */</div><div class="line">  PackedFunc(std::nullptr_t null) &#123;&#125;  // NOLINT(*)</div><div class="line">  /*!</div><div class="line">   * \brief constructing a packed function from a std::function.</div><div class="line">   * \param body the internal container of packed function.</div><div class="line">   */</div><div class="line">  explicit PackedFunc(FType body) : body_(body) &#123;&#125;</div><div class="line"></div><div class="line"> private:</div><div class="line">  /*! \brief internal container of packed function */</div><div class="line">  FType body_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>PackedFunc中的函数参数TVMArgs定义如下，可以支持可变长度的函数参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line"> * \brief Union type of values</div><div class="line"> *  being passed through API and function calls.</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</div><div class="line">  <span class="keyword">int64_t</span> v_int64;</div><div class="line">  <span class="keyword">double</span> v_float64;</div><div class="line">  <span class="keyword">void</span>* v_handle;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* v_str;</div><div class="line">  TVMType v_type;</div><div class="line">  TVMContext v_ctx;</div><div class="line">&#125; TVMValue;</div><div class="line"></div><div class="line"><span class="comment">/*! \brief Arguments into TVM functions. */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TVMArgs</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">const</span> TVMValue* values;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* type_codes;</div><div class="line">  <span class="keyword">int</span> num_args;</div></pre></td></tr></table></figure></p>
<p>下面来分析在tvm中注册执行函数的具体执行流程，包括三种方式。</p>
<h2 id="0x11-通过set-body-typed的注册"><a href="#0x11-通过set-body-typed的注册" class="headerlink" title="0x11 通过set_body_typed的注册"></a>0x11 通过set_body_typed的注册</h2><p>下图说明了通过set_body_typed来注册函数对象到Registry::Manager的详细过程。<br><img src="/2020/01/12/The lifecycle of opt_gemm in tvm/set_body_typed.png" alt=""></p>
<p>下面是set_body_typed注册函数对象的举例说明。<br>relay模块中通过set_body_typed的注册方式来注册函数_make.relu。<br>注意这个函数内部还通过Op::Get()来得到op operator，这个op operator的管理在本文0x14小节中介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\relay\op\nn\nn.cc</span></div><div class="line">TVM_REGISTER_GLOBAL(<span class="string">"relay.op.nn._make.relu"</span>)</div><div class="line">.set_body_typed([](Expr data) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Op&amp; op = Op::Get(<span class="string">"nn.relu"</span>);</div><div class="line">    <span class="keyword">return</span> CallNode::make(op, &#123;data&#125;, Attrs(), &#123;&#125;);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>relay模块依赖于topi层的实现，topi层中对relu的定义如下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// topi\include\topi\nn.h</div><div class="line">template &lt;typename T&gt;</div><div class="line">inline tvm::Tensor relu(const tvm::Tensor&amp; t,</div><div class="line">                        T threshold = static_cast&lt;T&gt;(0),</div><div class="line">                        std::string name = "T_relu",</div><div class="line">                        std::string tag = kElementWise) &#123;</div><div class="line">  return tvm::compute(</div><div class="line">      t-&gt;shape,</div><div class="line">      [&amp;](const tvm::Array&lt;tvm::Var&gt;&amp; i) &#123;</div><div class="line">        auto threshold_const = tvm::make_const(t-&gt;dtype, threshold);</div><div class="line">        return tvm::max(t(i), threshold_const);</div><div class="line">      &#125;,</div><div class="line">      name,</div><div class="line">      tag);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后调用到lang模块中实现的tvm::max，构造出相应的TVM IR。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\lang\expr_operator.cc</span></div><div class="line"><span class="function">Expr <span class="title">max</span><span class="params">(Expr a, Expr b)</span> </span>&#123;</div><div class="line">  <span class="comment">// inf-aware simplificaiton</span></div><div class="line">  <span class="keyword">using</span> arith::is_pos_inf;</div><div class="line">  <span class="keyword">using</span> arith::is_neg_inf;</div><div class="line">  <span class="keyword">if</span> (is_pos_inf(a)) <span class="keyword">return</span> a;</div><div class="line">  <span class="keyword">if</span> (is_neg_inf(a)) <span class="keyword">return</span> b;</div><div class="line">  <span class="keyword">if</span> (is_pos_inf(b)) <span class="keyword">return</span> b;</div><div class="line">  <span class="keyword">if</span> (is_neg_inf(b)) <span class="keyword">return</span> a;</div><div class="line">  BinaryOpMatchTypes(a, b);</div><div class="line">  Expr ret = arith::TryConstFold&lt;ir::Max&gt;(a, b);</div><div class="line">  <span class="keyword">if</span> (ret.defined()) <span class="keyword">return</span> ret;</div><div class="line">  <span class="keyword">return</span> ir::Max::make(a, b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后python模块中的relay层对relu的实现提供了python封装。这样python就可以调用到前面介绍的C++模块中的对应实现。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// python\tvm\relay\op\nn\nn.py</div><div class="line">def relu(data):</div><div class="line">    """Rectified linear unit.</div><div class="line">    return _make.relu(data)</div></pre></td></tr></table></figure></p>
<h2 id="0x12-通过set-body-method的注册"><a href="#0x12-通过set-body-method的注册" class="headerlink" title="0x12 通过set_body_method的注册"></a>0x12 通过set_body_method的注册</h2><p>下图说明了通过set_body_method来注册函数对象到Registry::Manager的详细过程。<br><img src="/2020/01/12/The lifecycle of opt_gemm in tvm/set_body_method.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面是一个set_body_method的调用示例。</div><div class="line"><span class="comment">// src\api\api_lang.cc</span></div><div class="line">TVM_REGISTER_GLOBAL(<span class="string">"_BijectiveLayoutBackwardShape"</span>)</div><div class="line">.set_body_method(&amp;BijectiveLayout::BackwardShape);</div></pre></td></tr></table></figure></p>
<h2 id="0x13-通过set-body的注册"><a href="#0x13-通过set-body的注册" class="headerlink" title="0x13 通过set_body的注册"></a>0x13 通过set_body的注册</h2><p>下图说明了通过set_body来注册函数对象到Registry::Manager的详细过程。<br><img src="/2020/01/12/The lifecycle of opt_gemm in tvm/set_body.png" alt=""></p>
<p>下面是一个set_body的调用示例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TVM_REGISTER_GLOBAL(<span class="string">"device_api.opencl"</span>)</div><div class="line">.set_body([](TVMArgs args, TVMRetValue* rv) &#123;</div><div class="line">    DeviceAPI* ptr = OpenCLWorkspace::Global().get();</div><div class="line">    *rv = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(ptr);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<h2 id="0x14-Relay-OP注册"><a href="#0x14-Relay-OP注册" class="headerlink" title="0x14 Relay OP注册"></a>0x14 Relay OP注册</h2><p>Relay OP保存在另外一个OpManager中，和前面的函数注册不是一个地方，这是因为这个OpManager管理的是relay operator函数，这些函数不会直接从python中调用过来。</p>
<p>OpManager的相关代码如下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\relay\ir\op.cc</span></div><div class="line">::dmlc::Registry&lt;OpRegistry&gt;* OpRegistry::Registry() &#123;</div><div class="line">  <span class="keyword">return</span> ::dmlc::Registry&lt;OpRegistry&gt;::Get();</div><div class="line">&#125;</div><div class="line"><span class="comment">// single manager of operator information.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpManager</span> &#123;</span></div><div class="line">  <span class="comment">// mutex to avoid registration from multiple threads.</span></div><div class="line">  <span class="built_in">std</span>::mutex mutex;</div><div class="line">  <span class="comment">// global operator counter</span></div><div class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; op_counter&#123;<span class="number">0</span>&#125;;</div><div class="line">  <span class="comment">// storage of additional attribute table.</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;GenericOpMap&gt;&gt; attr;</div><div class="line">  <span class="comment">// frontend functions</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PackedFunc*&gt; frontend_funcs;</div><div class="line">  <span class="comment">// get singleton of the op manager</span></div><div class="line">  <span class="function"><span class="keyword">static</span> OpManager* <span class="title">Global</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> OpManager* inst = <span class="keyword">new</span> OpManager();</div><div class="line">    <span class="keyword">return</span> inst;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// find operator by name</span></div><div class="line"><span class="keyword">const</span> Op&amp; Op::Get(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) &#123;</div><div class="line">  <span class="keyword">const</span> OpRegistry* reg = dmlc::Registry&lt;OpRegistry&gt;::Find(name);</div><div class="line">  CHECK(reg != <span class="literal">nullptr</span>) &lt;&lt; <span class="string">"Operator "</span> &lt;&lt; name &lt;&lt; <span class="string">" is not registered"</span>;</div><div class="line">  <span class="keyword">return</span> reg-&gt;op();</div><div class="line">&#125;</div><div class="line"></div><div class="line">OpRegistry::OpRegistry() &#123;</div><div class="line">  OpManager* mgr = OpManager::Global();</div><div class="line">  ObjectPtr&lt;OpNode&gt; n = make_object&lt;OpNode&gt;();</div><div class="line">  n-&gt;index_ = mgr-&gt;op_counter++;</div><div class="line">  op_ = Op(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EntryType&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Registry</span> &#123;</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是调用OpManager来注册op函数的代码示例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RELAY_REGISTER_OP(<span class="string">"argsort"</span>)</div><div class="line">.describe(<span class="string">R"doc(Returns the indices that would sort an</span></div><div class="line">input array along the given axis.</div><div class="line">)doc" TVM_ADD_FILELINE)</div><div class="line">.set_num_inputs(<span class="number">1</span>)</div><div class="line">.set_attrs_type&lt;ArgsortAttrs&gt;()</div><div class="line">.add_argument(<span class="string">"data"</span>, <span class="string">"Tensor"</span>, <span class="string">"Input data."</span>)</div><div class="line">.set_support_level(<span class="number">6</span>)</div><div class="line">.add_type_rel(<span class="string">"Argsort"</span>, ArgsortRel);</div></pre></td></tr></table></figure></p>
<p>如何取得OpManager中注册的op函数呢？答案是像下面这段代码所示通过调用Op::Get()来得到。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Cache the operators that are checked </span></div><div class="line"><span class="comment">// recursively to reduce lookup overhead.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; expand_dims_op = Op::Get(<span class="string">"expand_dims"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; reshape_op = Op::Get(<span class="string">"reshape"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; transpose_op = Op::Get(<span class="string">"transpose"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; squeeze_op = Op::Get(<span class="string">"squeeze"</span>);</div></pre></td></tr></table></figure></p>
<h1 id="0x2-执行流程介绍"><a href="#0x2-执行流程介绍" class="headerlink" title="0x2 执行流程介绍"></a>0x2 执行流程介绍</h1><p>前面介绍了执行函数是如何注册的，那这些函数是怎样被python调用到的呢？下面来介绍一下。<br>我们知道从python调用过来的接口定义在c_runtime_api.h头文件中，这其中比较重要的是这两个API，TVMFuncCall()和TVMArrayAlloc，从API的名称上可知，TVMFuncCall对应于从python来的函数调用，TVMArrayAlloc对应于数组的分配。<br>这两个API接口定义如下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tvm\include\tvm\runtime\c_runtime_api.h</span></div><div class="line"></div><div class="line"><span class="function">TVM_DLL <span class="keyword">int</span> <span class="title">TVMFuncCall</span><span class="params">(TVMFunctionHandle func,</span></span></div><div class="line">                        TVMValue* arg_values,</div><div class="line">                        <span class="keyword">int</span>* type_codes,</div><div class="line">                        <span class="keyword">int</span> num_args,</div><div class="line">                        TVMValue* ret_val,</div><div class="line">                        <span class="keyword">int</span>* ret_type_code);</div><div class="line"></div><div class="line"><span class="function">TVM_DLL <span class="keyword">int</span> <span class="title">TVMArrayAlloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">tvm_index_t</span>* shape,</span></span></div><div class="line">                          <span class="keyword">int</span> ndim,</div><div class="line">                          <span class="keyword">int</span> dtype_code,</div><div class="line">                          <span class="keyword">int</span> dtype_bits,</div><div class="line">                          <span class="keyword">int</span> dtype_lanes,</div><div class="line">                          <span class="keyword">int</span> device_type,</div><div class="line">                          <span class="keyword">int</span> device_id,</div><div class="line">                          TVMArrayHandle* out);</div></pre></td></tr></table></figure></p>
<p>然而python是如何知道前面的函数Manager中包括了哪些函数呢？这个时候Manager提供了一个函数供上层来调用得到所有注册函数名称列表，这个函数的定义如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TVMFuncListGlobalNames</span><span class="params">(<span class="keyword">int</span> *out_size,</span></span></div><div class="line">                           <span class="keyword">const</span> <span class="keyword">char</span>*** out_array) &#123;</div><div class="line">  API_BEGIN();</div><div class="line">  TVMFuncThreadLocalEntry *ret = TVMFuncThreadLocalStore::Get();</div><div class="line">  ret-&gt;ret_vec_str = tvm::runtime::Registry::ListNames();</div><div class="line">  ret-&gt;ret_vec_charp.clear();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ret-&gt;ret_vec_str.size(); ++i) &#123;</div><div class="line">    ret-&gt;ret_vec_charp.push_back(ret-&gt;ret_vec_str[i].c_str());</div><div class="line">  &#125;</div><div class="line">  *out_array = dmlc::BeginPtr(ret-&gt;ret_vec_charp);</div><div class="line">  *out_size = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ret-&gt;ret_vec_str.size());</div><div class="line">  API_END();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后python层根据前面的函数名称列表，通过下面的函数来得到每一个函数名称所对应的函数对象，python层拿到了这些函数对象以后，会在python层也创建相应的函数对象。这样python和c++层的函数操作就可以对应起来了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TVMFuncGetGlobal</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, TVMFunctionHandle* out)</span> </span>&#123;</div><div class="line">  API_BEGIN();</div><div class="line">  <span class="keyword">const</span> tvm::runtime::PackedFunc* fp =</div><div class="line">      tvm::runtime::Registry::Get(name);</div><div class="line">  <span class="keyword">if</span> (fp != <span class="literal">nullptr</span>) &#123;</div><div class="line">    *out = <span class="keyword">new</span> tvm::runtime::PackedFunc(*fp);  <span class="comment">// NOLINT(*)</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    *out = <span class="literal">nullptr</span>;</div><div class="line">  &#125;</div><div class="line">  API_END();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在python中创建函数对象的代码如下，先根据函数TVMFuncGetGlobal()来查找底层的函数对象，找到以后根据返回的handle创建上层函数对象Function。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def get_global_func(name, allow_missing=False):</div><div class="line">    handle = FunctionHandle()</div><div class="line">    check_call(_LIB.TVMFuncGetGlobal(c_str(name), ctypes.byref(handle)))</div><div class="line">    if handle.value:</div><div class="line">        return Function(handle, False)</div><div class="line"></div><div class="line">    if allow_missing:</div><div class="line">        return None</div><div class="line"></div><div class="line">    raise ValueError("Cannot find global function %s" % name)</div></pre></td></tr></table></figure></p>
<p>下面来介绍一下函数调用是如何从python层调用到C++层的，其中核心是要理解TVMFuncCall的调用过程。</p>
<h2 id="0x21-TVMFuncCall的调用过程"><a href="#0x21-TVMFuncCall的调用过程" class="headerlink" title="0x21 TVMFuncCall的调用过程"></a>0x21 TVMFuncCall的调用过程</h2><p>Python中调用TVMFuncCall的代码如下所示，其中包括了函数参数的封装。<br>self.handle是python中持有的C++ PackedFunc对象。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class FunctionBase(object):</div><div class="line">    def __call__(self, *args):</div><div class="line"></div><div class="line">        temp_args = []</div><div class="line">        values, tcodes, num_args = _make_tvm_args(args, temp_args)</div><div class="line">        ret_val = TVMValue()</div><div class="line">        ret_tcode = ctypes.c_int()</div><div class="line">        if _LIB.TVMFuncCall(</div><div class="line">                self.handle, values, tcodes, ctypes.c_int(num_args),</div><div class="line">                ctypes.byref(ret_val), ctypes.byref(ret_tcode)) != 0:</div><div class="line">            raise get_last_ffi_error()</div><div class="line">        _ = temp_args</div><div class="line">        _ = args</div><div class="line">        return RETURN_SWITCH[ret_tcode.value](ret_val)</div></pre></td></tr></table></figure></p>
<p>从Python代码调用到C++代码的入口函数如下。<br>函数参数func是封装好的PackedFunc对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\runtime\c_runtime_api.cc</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TVMFuncCall</span><span class="params">(TVMFunctionHandle func,</span></span></div><div class="line">                TVMValue* args,</div><div class="line">                <span class="keyword">int</span>* arg_type_codes,</div><div class="line">                <span class="keyword">int</span> num_args,</div><div class="line">                TVMValue* ret_val,</div><div class="line">                <span class="keyword">int</span>* ret_type_code) &#123;</div><div class="line">  API_BEGIN();</div><div class="line">  TVMRetValue rv;</div><div class="line">  (*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> PackedFunc*&gt;(func)).CallPacked(</div><div class="line">      TVMArgs(args, arg_type_codes, num_args), &amp;rv);</div><div class="line">  <span class="comment">// handle return string.</span></div><div class="line">  <span class="keyword">if</span> (rv.type_code() == kStr ||</div><div class="line">      rv.type_code() == kTVMType ||</div><div class="line">      rv.type_code() == kBytes) &#123;</div><div class="line">    TVMRuntimeEntry* e = TVMAPIRuntimeStore::Get();</div><div class="line">    <span class="keyword">if</span> (rv.type_code() != kTVMType) &#123;</div><div class="line">      e-&gt;ret_str = *rv.ptr&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      e-&gt;ret_str = rv.<span class="keyword">operator</span> <span class="built_in">std</span>::<span class="built_in">string</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rv.type_code() == kBytes) &#123;</div><div class="line">      e-&gt;ret_bytes.data = e-&gt;ret_str.c_str();</div><div class="line">      e-&gt;ret_bytes.size = e-&gt;ret_str.length();</div><div class="line">      *ret_type_code = kBytes;</div><div class="line">      ret_val-&gt;v_handle = &amp;(e-&gt;ret_bytes);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      *ret_type_code = kStr;</div><div class="line">      ret_val-&gt;v_str = e-&gt;ret_str.c_str();</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    rv.MoveToCHost(ret_val, ret_type_code);</div><div class="line">  &#125;</div><div class="line">  API_END();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// tvm\include\tvm\runtime\packed_func.h</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> PackedFunc::CallPacked(TVMArgs args, TVMRetValue* rv) <span class="keyword">const</span> &#123;</div><div class="line">  body_(args, rv);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面执行对body_的调用，利用可变参数模板的递归展开来实现，这样就可以调用到真正的注册函数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// include\tvm\runtime\packed_func.h</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ...Args&gt;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FType&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> TypedPackedFunc&lt;R(Args...)&gt;::AssignTypedLambda(FType flambda) &#123;</div><div class="line">  packed_ = PackedFunc([flambda](<span class="keyword">const</span> TVMArgs&amp; args, TVMRetValue* rv) &#123;</div><div class="line">      detail::unpack_call&lt;R, <span class="keyword">sizeof</span>...(Args)&gt;(flambda, args, rv);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">int</span> nargs, <span class="keyword">typename</span> F&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unpack_call</span><span class="params">(<span class="keyword">const</span> F&amp; f, <span class="keyword">const</span> TVMArgs&amp; args, TVMRetValue* rv)</span> </span>&#123;</div><div class="line">  unpack_call_dispatcher&lt;R, nargs, <span class="number">0</span>, F&gt;::run(f, args, rv);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">int</span> nleft, <span class="keyword">int</span> index, <span class="keyword">typename</span> F&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unpack_call_dispatcher</span> &#123;</span></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> F&amp; f,</span></span></div><div class="line">                  <span class="keyword">const</span> TVMArgs&amp; args_pack,</div><div class="line">                  TVMRetValue* rv,</div><div class="line">                  Args&amp;&amp;... unpacked_args) &#123;</div><div class="line">    unpack_call_dispatcher&lt;R, nleft - <span class="number">1</span>, index + <span class="number">1</span>, F&gt;</div><div class="line">        ::run(f, args_pack, rv,</div><div class="line">              <span class="built_in">std</span>::forward&lt;Args&gt;(unpacked_args)...,</div><div class="line">              args_pack[index]);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">int</span> index, <span class="keyword">typename</span> F&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unpack_call_dispatcher</span>&lt;R, 0, index, F&gt; &#123;</span></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> F&amp; f,</span></span></div><div class="line">                  <span class="keyword">const</span> TVMArgs&amp; args_pack,</div><div class="line">                  TVMRetValue* rv,</div><div class="line">                  Args&amp;&amp;... unpacked_args) &#123;</div><div class="line">    *rv = R(f(<span class="built_in">std</span>::forward&lt;Args&gt;(unpacked_args)...));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后可以看到调用的是Variable::make来生成tvm IR。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\api\api_ir.cc</span></div><div class="line">TVM_REGISTER_GLOBAL(<span class="string">"_Var"</span>)</div><div class="line">.set_body_typed([](<span class="built_in">std</span>::<span class="built_in">string</span> s, DataType t) &#123;</div><div class="line">    <span class="keyword">return</span> Variable::make(t, s);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h2 id="0x22-TVMArrayAlloc的调用过程"><a href="#0x22-TVMArrayAlloc的调用过程" class="headerlink" title="0x22 TVMArrayAlloc的调用过程"></a>0x22 TVMArrayAlloc的调用过程</h2><p>TVMArrayAlloc的调用过程比较简单，直接调用NDArray的接口来分配Array。<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">TVMArrayAlloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">tvm_index_t</span>* shape,</span></span></div><div class="line">                  <span class="keyword">int</span> ndim,</div><div class="line">                  <span class="keyword">int</span> dtype_code,</div><div class="line">                  <span class="keyword">int</span> dtype_bits,</div><div class="line">                  <span class="keyword">int</span> dtype_lanes,</div><div class="line">                  <span class="keyword">int</span> device_type,</div><div class="line">                  <span class="keyword">int</span> device_id,</div><div class="line">                  TVMArrayHandle* out) &#123;</div><div class="line">  API_BEGIN();</div><div class="line">  DLDataType dtype;</div><div class="line">  dtype.code = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(dtype_code);</div><div class="line">  dtype.bits = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(dtype_bits);</div><div class="line">  dtype.lanes = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;(dtype_lanes);</div><div class="line">  DLContext ctx;</div><div class="line">  ctx.device_type = <span class="keyword">static_cast</span>&lt;DLDeviceType&gt;(device_type);</div><div class="line">  ctx.device_id = device_id;</div><div class="line">  *out = NDArray::Internal::MoveToFFIHandle(</div><div class="line">      NDArray::Empty(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int64_t</span>&gt;(shape, shape + ndim), dtype, ctx));</div><div class="line">  API_END();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="0x03-opt-gemm-py执行流程分析"><a href="#0x03-opt-gemm-py执行流程分析" class="headerlink" title="0x03 opt_gemm.py执行流程分析"></a>0x03 opt_gemm.py执行流程分析</h1><p>下面来分析tvm自带的矩阵优化测试程序opt_gemm.py的执行流程。</p>
<h2 id="0x31-根据算法创建数据流图"><a href="#0x31-根据算法创建数据流图" class="headerlink" title="0x31 根据算法创建数据流图"></a>0x31 根据算法创建数据流图</h2><p>python代码如下，这部分描述了算法是两个矩阵相乘，根据矩阵的大小分配了相应的占位符placeholder,placeholder和tensorflow中的概念类似。然后调用compute()函数创建tvm IR。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">M = <span class="number">1024</span></div><div class="line">K = <span class="number">1024</span></div><div class="line">N = <span class="number">1024</span></div><div class="line"></div><div class="line">k = tvm.reduce_axis((<span class="number">0</span>, K), <span class="string">'k'</span>)</div><div class="line">A = tvm.placeholder((M, K), name=<span class="string">'A'</span>)</div><div class="line">B = tvm.placeholder((K, N), name=<span class="string">'B'</span>)</div><div class="line">C = tvm.compute(</div><div class="line">           (M, N),</div><div class="line">           lambda x, y: tvm.sum(A[x, k] * B[k, y], axis=k),</div><div class="line">           name=<span class="string">'C'</span>)</div></pre></td></tr></table></figure></p>
<p>上面算法描述对应到C++代码中，会创建相应的tvm node，这部分可以理解成是tvm的IR的生成。<br>下面的代码描述了上述python流程执行的最后创建ComputeOpNode的过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Operation ComputeOpNode::make(<span class="built_in">std</span>::<span class="built_in">string</span> name,</div><div class="line">                              <span class="built_in">std</span>::<span class="built_in">string</span> tag,</div><div class="line">                              Map&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ObjectRef&gt; attrs,</div><div class="line">                              Array&lt;IterVar&gt; axis,</div><div class="line">                              Array&lt;Expr&gt; body) &#123;</div><div class="line">  <span class="keyword">if</span> (!attrs.defined()) &#123;</div><div class="line">    attrs = Map&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ObjectRef&gt;();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> n = make_object&lt;ComputeOpNode&gt;();</div><div class="line">  n-&gt;name = <span class="built_in">std</span>::move(name);</div><div class="line">  n-&gt;tag = <span class="built_in">std</span>::move(tag);</div><div class="line">  n-&gt;attrs = <span class="built_in">std</span>::move(attrs);</div><div class="line">  n-&gt;axis = <span class="built_in">std</span>::move(axis);</div><div class="line">  n-&gt;body = <span class="built_in">std</span>::move(body);</div><div class="line">  <span class="keyword">if</span> (n-&gt;body[<span class="number">0</span>]-&gt;IsInstance&lt;ir::Reduce&gt;()) &#123;</div><div class="line">    <span class="keyword">const</span> ir::Reduce* reduce = n-&gt;body[<span class="number">0</span>].as&lt;ir::Reduce&gt;();</div><div class="line">    n-&gt;reduce_axis = reduce-&gt;axis;</div><div class="line">  &#125;</div><div class="line">  VerifyComputeOp(n.get());</div><div class="line">  <span class="keyword">return</span> Operation(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x32-创建Schedule"><a href="#0x32-创建Schedule" class="headerlink" title="0x32 创建Schedule"></a>0x32 创建Schedule</h2><p>python代码如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = tvm.create_schedule(C.op)</div></pre></td></tr></table></figure></p>
<p>对应的C++代码如下，这个时候会根据前面创建的tvm IR来生成reader graph，reader graph中描述了node之间的数据依赖关系。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">Schedule ScheduleNode::make(Array&lt;Operation&gt; ops) &#123;</div><div class="line">  <span class="keyword">auto</span> n = make_object&lt;ScheduleNode&gt;();</div><div class="line">  <span class="function">Schedule <span class="title">sch</span><span class="params">(n)</span></span>;</div><div class="line">  n-&gt;outputs = ops;</div><div class="line">  <span class="keyword">auto</span> g = schedule::CreateReadGraph(n-&gt;outputs);</div><div class="line">  Array&lt;Operation&gt; post_order = schedule::PostDFSOrder(n-&gt;outputs, g);</div><div class="line">  <span class="comment">// output set.</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;Operation&gt; output_set;</div><div class="line">  <span class="keyword">for</span> (Operation x : ops) &#123;</div><div class="line">    output_set.insert(x);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (Operation op : post_order) &#123;</div><div class="line">    <span class="function">Stage <span class="title">stage</span><span class="params">(op)</span></span>;</div><div class="line">    stage-&gt;is_output = output_set.count(op) != <span class="number">0</span>;</div><div class="line">    n-&gt;stages.push_back(stage);</div><div class="line">    n-&gt;stage_map.Set(op, stage);</div><div class="line">    <span class="comment">// mark scan updates.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">const</span> ScanOpNode* scan = op.as&lt;ScanOpNode&gt;()) &#123;</div><div class="line">      Array&lt;Tensor&gt; inputs;</div><div class="line">      <span class="keyword">for</span> (Tensor t : scan-&gt;state_placeholder) &#123;</div><div class="line">        inputs.push_back(t);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (Tensor t : scan-&gt;inputs) &#123;</div><div class="line">        inputs.push_back(t);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Create the scan group.</span></div><div class="line">      Stage scan_group = sch.create_group(scan-&gt;update, inputs, <span class="literal">false</span>);</div><div class="line">      scan_group-&gt;attach_type = kScanUpdate;</div><div class="line">      scan_group-&gt;attach_stage = stage;</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; scan-&gt;update.size(); ++i) &#123;</div><div class="line">        Stage s = n-&gt;stage_map[scan-&gt;update[i]-&gt;op];</div><div class="line">        CHECK(scan_group.same_as(s-&gt;group));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sch;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x32-用TVM-Pass来处理schedule生成的graph"><a href="#0x32-用TVM-Pass来处理schedule生成的graph" class="headerlink" title="0x32 用TVM Pass来处理schedule生成的graph"></a>0x32 用TVM Pass来处理schedule生成的graph</h2><p>执行下面的测试代码以后会调用下面的语句来创建stmt。<br>func = tvm.build(s, [A, B, C], target=target, name=’mmult’)</p>
<p>其Python代码如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">def lower(sch,</div><div class="line">          args,</div><div class="line">          name="default_function",</div><div class="line">          binds=None,</div><div class="line">          simple_mode=False):</div><div class="line"> </div><div class="line">    cfg = current_build_config()</div><div class="line">    add_lower_pass = cfg.add_lower_pass if cfg.add_lower_pass else []</div><div class="line">    if cfg.dump_pass_ir:</div><div class="line">        add_lower_pass = BuildConfig._dump_ir.decorate_custompass(add_lower_pass)</div><div class="line">    lower_phase0 = [x[1] for x in add_lower_pass if x[0] == 0]</div><div class="line">    lower_phase1 = [x[1] for x in add_lower_pass if x[0] == 1]</div><div class="line">    lower_phase2 = [x[1] for x in add_lower_pass if x[0] == 2]</div><div class="line">    lower_phase3 = [x[1] for x in add_lower_pass if x[0] &gt; 2]</div><div class="line"></div><div class="line">    # Phase 0</div><div class="line">    if isinstance(sch, schedule.Schedule):</div><div class="line">        stmt = form_body(sch)</div><div class="line"></div><div class="line">    for f in lower_phase0:</div><div class="line">        stmt = f(stmt)</div><div class="line"></div><div class="line">    compact = ir_pass.VerifyCompactBuffer(stmt)</div><div class="line">    binds, arg_list = get_binds(args, compact, binds)</div><div class="line"></div><div class="line">    # Phase 1</div><div class="line">    stmt = ir_pass.RewriteForTensorCore(stmt, sch, binds)</div><div class="line">    stmt = ir_pass.StorageFlatten(stmt, binds, 64, cfg.instrument_bound_checkers)</div><div class="line">    stmt = ir_pass.CanonicalSimplify(stmt)</div><div class="line">    for f in lower_phase1:</div><div class="line">        stmt = f(stmt)</div><div class="line"></div><div class="line">    # Phase 2</div><div class="line">    if not simple_mode:</div><div class="line">        stmt = ir_pass.LoopPartition(stmt, cfg.partition_const_loop)</div><div class="line">    if cfg.disable_vectorize:</div><div class="line">        stmt = ir_pass.SkipVectorize(stmt)</div><div class="line">    else:</div><div class="line">        stmt = ir_pass.VectorizeLoop(stmt)</div><div class="line">    stmt = ir_pass.InjectVirtualThread(stmt)</div><div class="line">    stmt = ir_pass.InjectDoubleBuffer(stmt, cfg.double_buffer_split_loop)</div><div class="line">    stmt = ir_pass.StorageRewrite(stmt)</div><div class="line">    stmt = ir_pass.UnrollLoop(</div><div class="line">        stmt,</div><div class="line">        cfg.auto_unroll_max_step,</div><div class="line">        cfg.auto_unroll_max_depth,</div><div class="line">        cfg.auto_unroll_max_extent,</div><div class="line">        cfg.unroll_explicit)</div><div class="line">    for f in lower_phase2:</div><div class="line">        stmt = f(stmt)</div><div class="line"></div><div class="line">    # Phase 3</div><div class="line">    stmt = ir_pass.Simplify(stmt)</div><div class="line">    stmt = ir_pass.RemoveNoOp(stmt)</div><div class="line">    if not cfg.disable_select_rewriting:</div><div class="line">        stmt = ir_pass.RewriteUnsafeSelect(stmt)</div><div class="line">    for f in lower_phase3:</div><div class="line">        stmt = f(stmt)</div><div class="line">    # Instrument BoundCheckers</div><div class="line">    if cfg.instrument_bound_checkers:</div><div class="line">        stmt = ir_pass.InstrumentBoundCheckers(stmt)</div><div class="line">    if simple_mode:</div><div class="line">        return stmt</div><div class="line"></div><div class="line">    return ir_pass.MakeAPI(stmt, name, arg_list, 0, cfg.restricted_func)</div></pre></td></tr></table></figure></p>
<p>前面的ir_pass.xxx函数调用都会对应到C++的实现，这些pass是tvm中实现的中间流程处理操作，<br>例如前面的函数中执行的下列python代码，<br>stmt = ir_pass.RemoveNoOp(stmt)<br>其对应的C++代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\pass\remove_no_op.cc</span></div><div class="line"><span class="comment">// Mark the statment of each stage.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoOpRemover</span> :</span> <span class="keyword">public</span> StmtMutator &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function">Stmt <span class="title">VisitStmt_</span><span class="params">(<span class="keyword">const</span> LetStmt* op)</span> final </span>&#123;</div><div class="line">    Stmt stmt = StmtMutator::VisitStmt_(op);</div><div class="line">    op = stmt.as&lt;LetStmt&gt;();</div><div class="line">    <span class="keyword">return</span> is_no_op(op-&gt;body) ? MakeEvaluate(op-&gt;value) : stmt;</div><div class="line">  &#125;</div><div class="line">  <span class="function">Stmt <span class="title">VisitStmt_</span><span class="params">(<span class="keyword">const</span> AttrStmt* op)</span> final </span>&#123;</div><div class="line">    <span class="keyword">if</span> (op-&gt;attr_key == <span class="string">"pragma_debug_skip_region"</span>) &#123;</div><div class="line">      <span class="keyword">return</span> MakeEvaluate(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    Stmt stmt = StmtMutator::VisitStmt_(op);</div><div class="line">    op = stmt.as&lt;AttrStmt&gt;();</div><div class="line">    <span class="keyword">return</span> is_no_op(op-&gt;body) ? MakeEvaluate(op-&gt;value) : stmt;</div><div class="line">  &#125;</div><div class="line">  ......</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">Stmt <span class="title">RemoveNoOp</span><span class="params">(Stmt stmt)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> NoOpRemover()(<span class="built_in">std</span>::move(stmt));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x33-把前面优化过的Pass调用LLVM-codegen来生成LLVM-IR"><a href="#0x33-把前面优化过的Pass调用LLVM-codegen来生成LLVM-IR" class="headerlink" title="0x33 把前面优化过的Pass调用LLVM codegen来生成LLVM IR"></a>0x33 把前面优化过的Pass调用LLVM codegen来生成LLVM IR</h2><p>python代码如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def build_module(lowered_func, target):</div><div class="line">    return _Build(lowered_func, target)</div></pre></td></tr></table></figure></p>
<p>C++代码如下，该段代码把tvm IR翻译成LLVM IR。<br>在其调用的Finish()函数中还会采用LLVM PassManager对已经生成的LLVM IR进行进一步优化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> Array&lt;LoweredFunc&gt;&amp; funcs, <span class="built_in">std</span>::<span class="built_in">string</span> target)</span> </span>&#123;</div><div class="line">    InitializeLLVM();</div><div class="line">    tm_ = GetLLVMTargetMachine(target);</div><div class="line">    <span class="keyword">bool</span> system_lib = (target.find(<span class="string">"-system-lib"</span>) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos);</div><div class="line">    CHECK_NE(funcs.size(), <span class="number">0U</span>);</div><div class="line">    ctx_ = <span class="built_in">std</span>::make_shared&lt;llvm::LLVMContext&gt;();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CodeGenLLVM&gt; cg = CodeGenLLVM::Create(tm_.get());</div><div class="line">    entry_func_ = funcs[<span class="number">0</span>]-&gt;name;</div><div class="line">    cg-&gt;Init(funcs[<span class="number">0</span>]-&gt;name, tm_.get(), ctx_.get(), system_lib, system_lib);</div><div class="line">    <span class="keyword">for</span> (LoweredFunc f :  funcs) &#123;</div><div class="line">      cg-&gt;AddFunction(f);</div><div class="line">    &#125;</div><div class="line">    cg-&gt;AddMainFunction(funcs[<span class="number">0</span>]-&gt;name);</div><div class="line">    module_ = cg-&gt;Finish();</div><div class="line"></div><div class="line">    module_-&gt;addModuleFlag(llvm::Module::Warning, <span class="string">"tvm_target"</span>, llvm::MDString::get(*ctx_, target));</div><div class="line">    module_-&gt;addModuleFlag(llvm::Module::Override, <span class="string">"Debug Info Version"</span>,</div><div class="line">                           llvm::DEBUG_METADATA_VERSION);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (tm_-&gt;getTargetTriple().isOSDarwin()) &#123;</div><div class="line">      module_-&gt;addModuleFlag(llvm::Module::Override, <span class="string">"Dwarf Version"</span>, <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> verify_errors_storage;</div><div class="line">    llvm::<span class="function">raw_string_ostream <span class="title">verify_errors</span><span class="params">(verify_errors_storage)</span></span>;</div><div class="line">    LOG_IF(FATAL, llvm::verifyModule(*module_, &amp;verify_errors))</div><div class="line">        &lt;&lt; <span class="string">"LLVM module verification failed with the following errors: \n"</span></div><div class="line">        &lt;&lt; verify_errors.str();</div><div class="line">    target_ = target;</div><div class="line">    mptr_ = module_.get();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x34-根据LLVM-IR生成对应的机器指令"><a href="#0x34-根据LLVM-IR生成对应的机器指令" class="headerlink" title="0x34 根据LLVM IR生成对应的机器指令"></a>0x34 根据LLVM IR生成对应的机器指令</h2><p>调用了如下python代码就触发了机器指令的生成。<br>func(a, b, c)</p>
<p>func为前面返回的LLVM IR module对应的地址，a, b, c为对应的执行参数，也就是矩阵运算的输入。<br>对应到C++中的下述实现，调用LLVM模块来生成对应target的机器代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">PackedFunc <span class="title">WrapPackedFunc</span><span class="params">(BackendPackedCFunc faddr,</span></span></div><div class="line">                          <span class="keyword">const</span> ObjectPtr&lt;Object&gt;&amp; sptr_to_self) &#123;</div><div class="line">  <span class="keyword">return</span> PackedFunc([faddr, sptr_to_self](TVMArgs args, TVMRetValue* rv) &#123;</div><div class="line">      <span class="keyword">int</span> ret = (*faddr)(</div><div class="line">          <span class="keyword">const_cast</span>&lt;TVMValue*&gt;(args.values),</div><div class="line">          <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(args.type_codes),</div><div class="line">          args.num_args);</div><div class="line">      CHECK_EQ(ret, <span class="number">0</span>) &lt;&lt; TVMGetLastError();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x35-评估执行时间"><a href="#0x35-评估执行时间" class="headerlink" title="0x35 评估执行时间"></a>0x35 评估执行时间</h2><p>python代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">evaluator = func.time_evaluator(func.entry_name, ctx, number=1)</div><div class="line">print('Baseline: %f' % evaluator(a, b, c).mean)</div></pre></td></tr></table></figure></p>
<p>c++代码如下，调用LLVM生成的机器指令来执行具体的运算。这部分还包括了把运算调用到其他机器的rpc操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">PackedFunc <span class="title">WrapTimeEvaluator</span><span class="params">(PackedFunc pf,</span></span></div><div class="line">                             TVMContext ctx,</div><div class="line">                             <span class="keyword">int</span> number,</div><div class="line">                             <span class="keyword">int</span> repeat,</div><div class="line">                             <span class="keyword">int</span> min_repeat_ms) &#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeat; ++i) &#123;</div><div class="line">        ......</div><div class="line">        <span class="comment">// start timing</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</div><div class="line">          pf.CallPacked(args, &amp;temp);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/artificial-intelligence/" rel="tag"># artificial intelligence</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/06/Use AI to speed up AV1 encoder/" rel="next" title="Use AI to speed up AV1 encoder">
                <i class="fa fa-chevron-left"></i> Use AI to speed up AV1 encoder
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Kevin Wen" />
          <p class="site-author-name" itemprop="name">Kevin Wen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x0-简介"><span class="nav-number">1.</span> <span class="nav-text">0x0 简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x1-函数注册"><span class="nav-number">2.</span> <span class="nav-text">0x1 函数注册</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x11-通过set-body-typed的注册"><span class="nav-number">2.1.</span> <span class="nav-text">0x11 通过set_body_typed的注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x12-通过set-body-method的注册"><span class="nav-number">2.2.</span> <span class="nav-text">0x12 通过set_body_method的注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x13-通过set-body的注册"><span class="nav-number">2.3.</span> <span class="nav-text">0x13 通过set_body的注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x14-Relay-OP注册"><span class="nav-number">2.4.</span> <span class="nav-text">0x14 Relay OP注册</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x2-执行流程介绍"><span class="nav-number">3.</span> <span class="nav-text">0x2 执行流程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x21-TVMFuncCall的调用过程"><span class="nav-number">3.1.</span> <span class="nav-text">0x21 TVMFuncCall的调用过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x22-TVMArrayAlloc的调用过程"><span class="nav-number">3.2.</span> <span class="nav-text">0x22 TVMArrayAlloc的调用过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-opt-gemm-py执行流程分析"><span class="nav-number">4.</span> <span class="nav-text">0x03 opt_gemm.py执行流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x31-根据算法创建数据流图"><span class="nav-number">4.1.</span> <span class="nav-text">0x31 根据算法创建数据流图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x32-创建Schedule"><span class="nav-number">4.2.</span> <span class="nav-text">0x32 创建Schedule</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x32-用TVM-Pass来处理schedule生成的graph"><span class="nav-number">4.3.</span> <span class="nav-text">0x32 用TVM Pass来处理schedule生成的graph</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x33-把前面优化过的Pass调用LLVM-codegen来生成LLVM-IR"><span class="nav-number">4.4.</span> <span class="nav-text">0x33 把前面优化过的Pass调用LLVM codegen来生成LLVM IR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x34-根据LLVM-IR生成对应的机器指令"><span class="nav-number">4.5.</span> <span class="nav-text">0x34 根据LLVM IR生成对应的机器指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x35-评估执行时间"><span class="nav-number">4.6.</span> <span class="nav-text">0x35 评估执行时间</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Wen</span>
</div>


<div> <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
访问量 <span id="busuanzi_value_site_pv"></span>
访问人数 <span id="busuanzi_value_site_uv"></span>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("orq8xxsDQDXKiHdqSRcjlflB-gzGzoHsz", "ecCFdIcWDfbJKQOCiLFf1EBm");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
