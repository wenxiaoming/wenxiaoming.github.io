<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Kevin Wen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Kevin Wen&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kevin Wen&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Kevin Wen's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kevin Wen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/17/Understanding of eglSwapBuffers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/17/Understanding of eglSwapBuffers/" itemprop="url">Understanding of eglSwapBuffers</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-17T20:00:30+09:00">
                2019-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/11/17/Understanding of eglSwapBuffers/" class="leancloud_visitors" data-flag-title="Understanding of eglSwapBuffers">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-eglSwapBuffers在图形系统中的作用"><a href="#0x1-eglSwapBuffers在图形系统中的作用" class="headerlink" title="0x1 eglSwapBuffers在图形系统中的作用"></a>0x1 eglSwapBuffers在图形系统中的作用</h1><p>在开发图形程序的时候，经常有同事问是不是调用eglSwapBuffers函数以后就可以输出显示了，如果简单来说可以这么理解，但是实际上gpu驱动中eglSwapBuffers函数执行以后只是提示上层模块该输出buffer可以使用了，这个时候是把输出buffer显示到屏幕上还是输出到文件中，或者是通过网络发送到远程终端上，取决于上层图形系统的设计。另外eglSwapBuffers函数需要配合上层模块(如Android上的Surface)完成buffer管理的工作。<br>本文详细介绍了eglSwapBuffers函数在图形系统中是如何配合上层buffer管理模块，完成从应用绘制到屏幕显示的完整流程的。</p>
<p>在典型图形系统中，一般包括了如下图所示的几个模块，应用程序绘制UI，合成器把多个UI合成为一帧图像，然后Frame buffer driver把合成好的图像绘制到屏幕硬件上。</p>
<p><img src="/2019/11/17/Understanding of eglSwapBuffers/eglswapbuffers.png" alt=""></p>
<p>这里有几个生产者-消费者模型，<br>App1/App2是UI内容的生产者，Compositor是App1/App2生产出来的UI内容的消费者，Compositor本身又是Frame buffer driver输入buffer的生产者。Frame buffer driver是Compositor生产出的buffer内容的消费者。</p>
<p>App1分配了三块buffer供gpu绘制使用，buffer的管理可以通过BufferQueue的模块来管理，在App1的绘制线程中调用gpu driver的eglSwapBuffers函数，eglSwapBuffers函数在执行的时候首先需要从BufferQueue中取得一块可以供GPU写入的buffer，如果这个时候没有空闲的buffer，gpu driver会在这里等待，如果发生这种情况，在性能分析的时候，我们可以在systrace上看到eglSwapBuffers占用的时间较长，从上面分析的buffer模型可以看出，出现没有空闲的buffer可能是Compositor执行太慢，三块buffer都被Compositor占用了，另外的原因可能是App1中gpu driver绘制执行时间太长，三块buffer都还在等待gpu硬件的写入完成。</p>
<p>eglSwapBuffers申请到了空闲的buffer以后，就可以把空闲buffer的地址设置给GPU硬件，并根据App1的其他设置驱动GPU硬件开始工作。这个时候eglSwapBuffers是否需要等待GPU硬件把完整的一帧绘制完成才返回呢?答案是不需要等待，但是会给这块buffer设置相应的fence，然后把这块buffer送给后续的Compositor来使用，Compositor在需要读取这块buffer内容之前，GPU硬件可以继续完成该buffer的绘制工作，达到CPU处理(Compositor的处理流程)和GPU处理的并行，Compositor在执行到了必须读取这块buffer内容的时候，会去检查buffer对应的fence的状态，如果还没有被signal，则需要等待，直至GPU绘制完成后singal对应的fence。</p>
<h1 id="0x2-应用进程使用eglSwapBuffers"><a href="#0x2-应用进程使用eglSwapBuffers" class="headerlink" title="0x2 应用进程使用eglSwapBuffers"></a>0x2 应用进程使用eglSwapBuffers</h1><p>App1执行流程如下所示。</p>
<p><img src="/2019/11/17/Understanding of eglSwapBuffers/app_draw.svg" alt=""></p>
<ol>
<li>应用程序调用createBufferQueue创建BufferQueue，其中包括Buffer的Producer和Consumer。Producer是buffer的生产者，Consumer是buffer的消费者。这样应用中的渲染线程相当于Producer，合成器是Consumer，是buffer的消费者。</li>
<li>BufferQueue通过合成器进程创建buffer队列，一般创建3个buffer。</li>
<li>渲染线程把Producer包装成Surface，然后把Surface作为参数去调用eglCreateWindowSurface。这样GPU driver相当于Producer，负责生产buffer。</li>
<li>应用程序调用draw命令，渲染线程调用eglSwapBuffers。</li>
<li>eglSwapBuffers通过dequeue()查找BufferQueue中空闲的buffer，如果没有空闲的buffer则需要等待。</li>
<li>eglSwapBuffers把空闲的buffer的地址设置给GPU硬件，并设置其他参数，驱动GPU硬件工作。</li>
<li>eglSwapBuffers通过queue()把前面GPU的写入buffer返回给BufferQueue，并设置相应的fence。</li>
<li>BufferQueue通过Consumer接口通知合成器有新的buffer到来，可以进行合成工作。</li>
</ol>
<h1 id="0x3-合成器进程使用eglSwapBuffers"><a href="#0x3-合成器进程使用eglSwapBuffers" class="headerlink" title="0x3 合成器进程使用eglSwapBuffers"></a>0x3 合成器进程使用eglSwapBuffers</h1><p>Compositor执行流程如下所示。<br>这里我们只讨论采用GPU来做合成的情况，如采用2D加速硬件来做合成的话就不会在合成器中调用eglSwapBuffers。</p>
<p><img src="/2019/11/17/Understanding of eglSwapBuffers/compositor_draw.svg" alt=""></p>
<ol>
<li>应用程序创建的时候会在合成器中创建相应的Layer，这样应用程序的绘制输出就可以通知到对应的Layer。</li>
<li>创建相应的DisplayDevice，在创建DisplayDevice的时候创建BufferQueue，这里Producer是合成器线程，Consumer是后面连接的Frame buffer driver。</li>
<li>应用程序通过其渲染线程中的eglSwapBuffers通知合成器有新的buffer到来，需要进行合成工作。</li>
<li>合成器线程准备开始合成，等待应用渲染线程中的buffer被GPU硬件绘制完成。</li>
<li>合成器线程调用eglSwapBuffers。</li>
<li>eglSwapBuffers通过dequeue()查找BufferQueue中空闲的buffer，如果没有空闲的buffer则需要等待。</li>
<li>eglSwapBuffers通过queue()把前面GPU的写入buffer返回给BufferQueue，并设置相应的fence。</li>
<li>BufferQueue通过Consumer接口通知Frame buffer driver有新的buffer到来，可以把buffer内容绘制到屏幕硬件上。</li>
</ol>
<h1 id="0x4-图形系统中buffer管理的特点"><a href="#0x4-图形系统中buffer管理的特点" class="headerlink" title="0x4 图形系统中buffer管理的特点"></a>0x4 图形系统中buffer管理的特点</h1><p>上面分析基本是基于Android系统的，从上面的流程可知，buffer的分配是在合成器进程中分配的，然后返回给应用进程使用。<br>如果是采用wayland协议的weston图形系统中，buffer的分配是在应用进程中进行的，然后把相应的buffer handle传给weston进程，作为weston合成的输入buffer使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/13/About Video Codec Optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/13/About Video Codec Optimization/" itemprop="url">About Video Codec Optimization</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-13T18:01:30+09:00">
                2019-10-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/10/13/About Video Codec Optimization/" class="leancloud_visitors" data-flag-title="About Video Codec Optimization">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Video-Codec流程"><a href="#0x1-Video-Codec流程" class="headerlink" title="0x1 Video Codec流程"></a>0x1 Video Codec流程</h1><p>视频编码流程如下图所示。<br><img src="/2019/10/13/About Video Codec Optimization/Encoder.png" alt=""><br>视频解码流程如下图所示。<br><img src="/2019/10/13/About Video Codec Optimization/Decoder.png" alt=""><br>如何对编解码器进行优化呢？<br>主要方法有算法优化，指令集优化和并行优化。本文的后面部分会对这些优化方法进行详细的介绍。<br>这边先来介绍一下优化的量化指标。</p>
<p>对编解码来说，共性的指标是编解码速度和消耗的功耗。编解码速度可以用fps来量化。这个是典型的软件优化过程，这个时候，诸如降低cache miss率，循环展开等优化思想都是适用的。<br>对软件编解码器而言，功耗可以量化为CPU占用率或者是MIPS(Million Instructions Per Second)。对硬件编解码器来说，功耗可以量化成硬件执行频率/硬件使用率等，也可以是硬件电压和电流参数。</p>
<p>对编码器来说，我们还需要保证相同码率下图像质量不衰退，这个衡量指标是PSNR和码率。在编码优化过程中，如何保证优化以后不出问题呢？我们知道编码的流程中是包括解码过程的，我们可以把编码过程中解码部分输出的YUV数据保存下来，再把编码生成的码流用参考解码器进行解码并保存为参考YUV输出，这个参考YUV输出和前面编码器中保存的YUV数据进行比较，如果两者的YUV数据有差异，可以确定是编码器优化出了问题，这个时候可以比较具体的比特位差异来快速定位问题。</p>
<p>另外在编解码优化过程中，我们还会用到码流分析工具，如<a href="http://www.interrasystems.com/pdf/datasheet/Vega_Datasheet.pdf" target="_blank" rel="external">Vega</a>,<a href="https://www.elecard.com/zh/products/video-analysis/streameye" target="_blank" rel="external">streameye</a>和yuvviewer等。</p>
<p>对解码器来说，我们还需要运行各种conformance test来保证解码优化以后不引入衰退。</p>
<h1 id="0x2-算法优化"><a href="#0x2-算法优化" class="headerlink" title="0x2 算法优化"></a>0x2 算法优化</h1><p>算法优化主要针对编码器而言的。<br>编码算法优化的目标有三个，一个是在保证质量的前提下降低码率，另一个是码率不变情况下提升编码质量。第三个目标是保证图形质量和码率不变的情况下提升编码速度。</p>
<p>前面两个的目标也是制定编解码器标准的目标，在一种特定的码流格式确定之前需要召开多次会议来讨论码流的细节，这种会议会讨论各个单位的提案，选出最佳的coding tools，达到最佳的压缩效率。下面我们来讨论一下如何按照第三个目标来优化编码器。</p>
<p>编码算法进行优化后，如何保证编码质量呢？这个时候需要通过客观指标如PSNR来保证，或者是类似的主观指标如MOS或者DMOS来保证。通过比较优化前后的PSNR，我们可以知道编码质量有没有下降。如何检查码率有没有变化呢？这个很简单，直接比较编码生成的文件大小有没有增加即可。</p>
<p>下面以AVC的编码器为例，看看如何对编码算法进行一定的优化。</p>
<p>帧内预测优化<br>比如在AVC的Luma帧内编码过程中，对应4x4大小的block，我们需要遍历9种预测方向来找到最优的预测方式。这个时候我们可以利用像素的特点减少预测方向的数量。另外还有16x16,8x8(High Profile而言)大小需要比较，这个时候都可以通过减少预测数量来优化。</p>
<p>帧间预测优化<br>对帧间预测的模式选择过程进行优化，因为运动估计比较耗时，如果所有模式都搜索一遍很耗时，可以利用像素特点对运动估计进行简化。<br>还有一种是I macroblock in P frame，需要计算什么情况下要在P frame采用Intra macroblock，这个过程也可以优化，对P frame中一个特定的宏块，可以采用某种方式来判断是否需要进行采用Intra编码，而不是需要计算好Inter和Intra的cost才能通过比较cost来选择。<br>另外可以采用不同的运动搜索算法来对简化通过运动搜索找到最佳运动矢量的过程。</p>
<p>码率控制优化<br>码率控制的过程是选择哪个宏块采用哪个量化参数QP的过程，有frame level的码率控制， 这个时候整个frame都是采用固定的QP。有slice level的码率控制，这个时候整个slice采用固定的QP。有macroblock level的码率控制，这个时候每个宏块可以自由地调节QP。macroblock level的码率控制是最准确的，但是计算复杂度也最大，可以通过在这几种码率控制级别之间进行选择，来达到码率控制和计算复杂度之间的平衡。</p>
<p>解码因为是固定的流程，算法没有办法进行优化，当然也有特例，如2006年左右PC性能比较差的时候，需要播放BluRay的AVC码流，在1080P情况下AVC软件解码性能不足，CPU占用率高，某播放器公司是把AVC的deblocking关闭的，当然画面质量会受到一些影响。另外在早期SOC平台性能不足，在软件解码的时候，很多时候会把不参与预测的B帧直接丢弃。</p>
<h1 id="0x3-平台指令集优化"><a href="#0x3-平台指令集优化" class="headerlink" title="0x3 平台指令集优化"></a>0x3 平台指令集优化</h1><p>这种优化方法是采用各个平台特有的SIMD指令对编解码过程中某些运算过程进行加速，如x86上的mmx/sse/sse2/sse3/sse4/avx/avx512等SIMD指令，ARM平台上的SIMD指令有neon指令。</p>
<p>如编解码过程中典型的Hadmard变换，SATD, SAD, DCT, IDCT,运动补偿插值，Deblocking等过程都是很适合采用SIMD指令来加速的。<br>这里特别说明一下运动补偿插值的过程，目前AVC的Luma分量支持1/4像素的插值，也就是说每个像素需要插值成15个分像素点供后续运动估计使用。如果内存充足的话，可以利用SIMD方法把15个分像素点先计算好，这样在运动估计的时候就不需要做插值工作。<br>如下图所示，方框所示为整像素点，圆形所示为分像素点。可以按照1/2/3, 4/8/12, 5/7/13/15, 10, 6/9/11/14的过程进行SIMD计算。<br><img src="/2019/10/13/About Video Codec Optimization/Quarter pixel interpolation.png" alt=""><br>目前各个开源编解码库，如ffmpeg,x264,xvid,x265等，这些库的很大部分优化工作就是在各个平台上进行SIMD优化。</p>
<h1 id="0x4-GPU并行优化"><a href="#0x4-GPU并行优化" class="headerlink" title="0x4 GPU并行优化"></a>0x4 GPU并行优化</h1><p>这里说的GPU并行优化一般指采用opencl/cuda之类的GPU Compute API来进行编解码的处理。</p>
<p>x264中采用了opencl来进行编码优化，把CPU需要完成的工作offload到GPU中来完成，其中x264采用opencl来在analysis阶段分析像素的特点来提前确定GOP中IBP帧的排列分布，还用来判断当前Slice是需要用Intra编码还是Inter编码。</p>
<h1 id="0x5-并行优化"><a href="#0x5-并行优化" class="headerlink" title="0x5 并行优化"></a>0x5 并行优化</h1><h2 id="0x51-分布式优化"><a href="#0x51-分布式优化" class="headerlink" title="0x51 分布式优化"></a>0x51 分布式优化</h2><p>分布式优化一般用于编码优化，基本原理是把需要编码的文件划分成几个部分，每一部分分别在不同的机器上进行编码，编码完成以后再把编码好的几段码流合并成一个完整的码流。这种编码优化方法一般多见于专业视频制作过程，需要保证图形质量最佳的情况下码率最小，一般会启用编码器中的所有feature。另外一般采用多pass的编码方法，第一个pass先分析输入素材的特点，根据分布式处理的机器数目来确定那一段输入素材在哪台机器上进行编码。另外需要指出的是在分割点附近的码率控制算法需要特别处理，否则容易出现码率突然增大的情况。<br><img src="/2019/10/13/About Video Codec Optimization/Clip Level Parallel.png" alt=""></p>
<h2 id="0x52-GOP并行优化"><a href="#0x52-GOP并行优化" class="headerlink" title="0x52 GOP并行优化"></a>0x52 GOP并行优化</h2><p>这种优化方法是把一个GOP分配给一个线程来进行优化。<br>对编码而言，可以控制每个GOP中frame的数目，并且不采用Open GOP，只采用Close GOP的方式来进行编码。这样每个线程的负载可以做到比较平均。每个GOP开头和结尾处的码率控制需要特别处理。</p>
<p>对解码而言， 如果GOP之间的frame数目差别较大，则没有办法做到线程的负载平衡。而且如果是Open GOP的话，线程之间也有等待操作。<br><img src="/2019/10/13/About Video Codec Optimization/GOP Level Parallel.png" alt=""></p>
<h2 id="0x53-Frame并行优化"><a href="#0x53-Frame并行优化" class="headerlink" title="0x53 Frame并行优化"></a>0x53 Frame并行优化</h2><p>Frame级别优化是把Frame分配给不同的线程处理，一般用于视频解码，如果当前帧的当前宏块的解码过程需要依赖于前面帧的解码完成，这个时候是需要等待，这个在目前的视频标准中是很常见的。如P帧的解码需要依赖前面I帧的解码完成。<br><img src="/2019/10/13/About Video Codec Optimization/Frame Level Parallel.png" alt=""></p>
<h2 id="0x54-Slice并行优化"><a href="#0x54-Slice并行优化" class="headerlink" title="0x54 Slice并行优化"></a>0x54 Slice并行优化</h2><p>对编码器来说，可以按照多个Slice来并行编码，只需要在编码器启动的时候配置好Slice数目即可，需要注意的是，Slice编码完成以后，一般需要进行Deblocking，这个过程是跨Slice边界的，也就是说这个时候没有办法并行处理了，需要等待所有Slice编码完成以后在Control Thread中完成Deblocking的过程。<br>对解码器来说，按照码流中的slice数目启动多线程解码。<br>这种并行优化方式的优点是实现简单。<br>这种并行优化方式的缺点是，对编码器来说会稍微损失码率，对解码器来说是依赖于slice数目，如果只有一个slice,没办法并行处理。<br><img src="/2019/10/13/About Video Codec Optimization/Slice Level Parallel.png" alt=""></p>
<h2 id="0x55-MB-Block并行优化"><a href="#0x55-MB-Block并行优化" class="headerlink" title="0x55 MB Block并行优化"></a>0x55 MB Block并行优化</h2><p>这种优化方式一般用于解码器。优点是线程负载比较平衡，缺点是实现较复杂，需要深入解码器内部进行划分任务，把解码任务划分成不同的阶段，如VLD，IDCT，MC，Deblocking等。每个线程只是执行一个阶段的任务，而且执行的宏块数也只是上图中一个长方框内的宏块数目。这个时候如果算法的实现中对前后方框之间的宏块有数据依赖的话，需要加入同步机制。如ffmpeg就没有实现这种方式。<br><img src="/2019/10/13/About Video Codec Optimization/Macroblock Level Parallel.png" alt=""></p>
<h1 id="0x6-AI优化"><a href="#0x6-AI优化" class="headerlink" title="0x6 AI优化"></a>0x6 AI优化</h1><p>AV1的参考编码器libaom中采用了AI来加速partiton划分, partiton划分在libaom中占用了大概80%的复杂度。libaom编码过程中采用的CNN + DNN的网络是经过训练的，在libaom的代码中并没有提供这个网络结构的训练过程代码。但是从其推理过程我们可以大体知道其训练过程，其实现方式应该是设计好网络以后，通过大量样本数据来训练得到该推理网络的。</p>
<h1 id="0x7-硬件优化"><a href="#0x7-硬件优化" class="headerlink" title="0x7 硬件优化"></a>0x7 硬件优化</h1><p>下面提到的DXVA和LibVA是指通过GPU集成的视频编解码能力来加速视频处理。<br>DXVA指Windows平台上的GPU视频编解码加速标准。<br>LibVA指Linux平台上的GPU视频编解码加速标准。</p>
<p>DXVA架构图如下所示。<br><img src="/2019/10/13/About Video Codec Optimization/DXVA.png" alt=""><br>LibVA架构图如下所示。<br><img src="/2019/10/13/About Video Codec Optimization/LibVA.png" alt=""><br>ASIC优化<br>还有一种优化方法是把编解码模块做成ASIC模块，如早期的WisChip公司的视频编解码器。<br>现在Verisilicon公司的Hantro IP, Broadcom的VideoCore， 各个手机SOC厂商（Huawei, MTK, Spreadtrum, qualcomm)在SOC中集成的视频编解码IP。</p>
<p>DSP优化<br>如TI公司的DSP平台如TMS320C64可以用来优化Codec。</p>
<p>FPGA优化<br>如Altera和Xilinx的FPGA都可以用来优化视频编解码能力。</p>
<h1 id="0x8-优化思考"><a href="#0x8-优化思考" class="headerlink" title="0x8 优化思考"></a>0x8 优化思考</h1><p>目前openmp, tbb等基础库已经很成熟，已经广泛应用于各种深度学习推理框架的优化中。视频编解码优化应该也可以采用这些基础库来优化。<br>另外是可以思考是否可以采用TVM类似框架来优化，现在对推理框架的优化热潮和十多年前对codec的优化热潮很像。如果可以有TVM类似的框架，目前视频编解码优化中各种平台上的手写SIMD优化工作应该可以通过类似的AutoTune工作来完成。这样视频编解码优化的工作可以从繁重的手写汇编的工作中解放出来，把优化侧重点放在对算法和计算流程方面的优化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/Deep about Intel Gen Driver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/13/Deep about Intel Gen Driver/" itemprop="url">Intel Gen Driver流程介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-13T21:18:20+09:00">
                2019-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/07/13/Deep about Intel Gen Driver/" class="leancloud_visitors" data-flag-title="Intel Gen Driver流程介绍">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-总体流程"><a href="#0x1-总体流程" class="headerlink" title="0x1 总体流程"></a>0x1 总体流程</h1><p>GPU硬件简单说来可以包括这几块，首先是内存访问相关模块，如MMU，Cache等。其次是各种Fixed Function模块，如Rasterizer，Clipper等。最后是可编程单元模块Shader Core，Shader Core的加入使GPU具有了和CPU一样具体处理各种复杂问题的能力，赋予了用户很大的发挥空间来编写各个OpenGL shader，OpenCL kernel，这些shader和kernel最后都会生成对应的专有GPU指令并运行在Shader Core上。在Intel Gen GPU中，对应的Shader Core模块也称为EU(Execution Unit)。</p>
<p>从GPU driver到GPU硬件完成绘制的流程可以简单说明如下。</p>
<p>a. GPU user space driver在CPU侧根据应用设置的各种状态生成各种command list。</p>
<p>b. GPU user space driver在CPU侧通过compiler把shader源代码生成对应的gpu shader core指令. 这个shader core指令也是保存在memory中，driver会把其地址保存在某一个command结构体中。</p>
<p>c. GPU user space driver把前面生成的内容发送到GPU kernel space driver中。GPU kernel space driver启动gpu硬件读取command list的内容。</p>
<p>d. GPU中的command executor开始消费command，根据command的内容驱动gpu硬件中各个不同的模块协同工作。当需要shader core执行的时候，从相应的memory buffer中读取GPU指令，shader core根据GPU指令完成相应的shader操作。当需要读取Vertex和Texture内容的时候，从相应的command找到对应的buffer地址，然后读取相应的内容。<br>上面提到的流程说明可以简单地用下图所示。<br><img src="/2019/07/13/Deep about Intel Gen Driver/general structure of gpu.svg" alt=""></p>
<p>本文后面用一个简单的三角形绘制测试程序说明一下GPU driver是如何工作的。这里的GPU driver主要是指开源的User space driver实现mesa。</p>
<p>这个测试程序的流程如下图所示。<br><img src="/2019/07/13/Deep about Intel Gen Driver/triangle test.svg" alt=""></p>
<h1 id="0x2-Shader编译"><a href="#0x2-Shader编译" class="headerlink" title="0x2 Shader编译"></a>0x2 Shader编译</h1><p>下面说明一下mesa driver中Intel Gen shader编译过程。</p>
<p>Vertex Shader的编译过程如下。</p>
<p>对应的GLSL source code如下所示。<br>这个shader只是把外部设置的attribute信息Position设置到gl_Position中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">attribute vec4 vPosition;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    gl_Position = vPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译的第一阶段是完成词法分析，语法分析，生成对应的抽象语法树AST。<br>然后根据AST生成Mesa内部的中间表示NIR。然后在NIR上执行各种编译器优化。每执行一次优化称为一个Pass。<br>经过多个Pass优化以后，最后生成的NIR代码如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NIR (final form) <span class="keyword">for</span> vertex shader:</div><div class="line">shader: MESA_SHADER_VERTEX</div><div class="line">name: GLSL3</div><div class="line">inputs: <span class="number">1</span></div><div class="line">outputs: <span class="number">1</span></div><div class="line">uniforms: <span class="number">0</span></div><div class="line">shared: <span class="number">0</span></div><div class="line"><span class="function">decl_var shader_in INTERP_MODE_NONE highp vec4 <span class="title">vPosition</span> <span class="params">(VERT_ATTRIB_GENERIC0.xyzw, <span class="number">16</span>, <span class="number">0</span>)</span></span></div><div class="line">decl_var shader_out INTERP_MODE_NONE highp vec4 <span class="title">gl_Position</span> <span class="params">(VARYING_SLOT_POS.xyzw, <span class="number">0</span>, <span class="number">0</span>)</span></div><div class="line">decl_function <span class="title">main</span> <span class="params">(<span class="number">0</span> params)</span></div><div class="line"></div><div class="line">impl main &#123;</div><div class="line">    block block_0:</div><div class="line">    <span class="comment">/* preds: */</span></div><div class="line">    vec1 <span class="number">32</span> ssa_0 = load_const (<span class="number">0x00000000</span> <span class="comment">/* 0.000000 */</span>)</div><div class="line">    vec4 <span class="number">32</span> ssa_1 = intrinsic load_input (ssa_0) (<span class="number">0</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">144</span>) <span class="comment">/* base=0 */</span> <span class="comment">/* component=0 */</span> <span class="comment">/* dest_type=float32 */</span> <span class="comment">/* location=16 slots=1 */</span></div><div class="line">    intrinsic store_output (ssa_1, ssa_0) (<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">128</span>) <span class="comment">/* base=0 */</span> <span class="comment">/* wrmask=xyzw */</span> <span class="comment">/* component=0 */</span> <span class="comment">/* src_type=float32 */</span> <span class="comment">/* location=0 slots=1 */</span> <span class="comment">/* gl_Position */</span></div><div class="line">    <span class="comment">/* succs: block_1 */</span></div><div class="line">    block block_1:</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面开始执行编译器后端，生成具体的GPU shader core指令。这里shader core也就是前面提到的EU，所以我们也就是要生成EU code。<br>这里面也用到了传统的编译器后端技术，如图着色寄存器分配等。<br>最后生成的EU code如下所示。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Native code for unnamed vertex shader GLSL3 (sha1 15358268e6b3974dafb7512e3bdaa7c4c81a9394)</div><div class="line">SIMD8 shader: 6 instructions. 0 loops. 20 cycles. 0:0 spills:fills, 1 sends, scheduled with mode top-down. Promoted 0 constants. Compacted 96 to 64 bytes (33%)</div><div class="line">   START B0 (20 cycles)</div><div class="line">mov(8)          g122&lt;1&gt;UD       g1&lt;8,8,1&gt;UD                     &#123; align1 WE_all 1Q compacted &#125;;</div><div class="line">mov(8)          g123&lt;1&gt;F        g2&lt;8,8,1&gt;F                      &#123; align1 1Q compacted &#125;;</div><div class="line">mov(8)          g124&lt;1&gt;F        g3&lt;8,8,1&gt;F                      &#123; align1 1Q compacted &#125;;</div><div class="line">mov(8)          g125&lt;1&gt;F        g4&lt;8,8,1&gt;F                      &#123; align1 1Q compacted &#125;;</div><div class="line">mov(8)          g126&lt;1&gt;F        g5&lt;8,8,1&gt;F                      &#123; align1 1Q compacted &#125;;</div><div class="line">send(8)         null&lt;1&gt;F        g122&lt;8,8,1&gt;F    0x8a080017</div><div class="line">                            urb MsgDesc: 1 SIMD8 write mlen 5 rlen 0        &#123; align1 1Q EOT &#125;;</div><div class="line">   END B0</div></pre></td></tr></table></figure></p>
<p>Fragment Shader的编译过程如下。<br>具体的流程和Vertex Shader的编译过程类似。详细的过程不介绍了，下面只是列出各个编译阶段的结果。</p>
<p>GLSL source code<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">precision mediump <span class="keyword">float</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>                                 </span></div><div class="line">&#123;                                            </div><div class="line">    gl_FragColor = vec4 ( <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NIR code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NIR (final form) <span class="keyword">for</span> fragment shader:</div><div class="line">shader: MESA_SHADER_FRAGMENT</div><div class="line">name: GLSL3</div><div class="line">inputs: <span class="number">0</span></div><div class="line">outputs: <span class="number">1</span></div><div class="line">uniforms: <span class="number">0</span></div><div class="line">shared: <span class="number">0</span></div><div class="line"><span class="function">decl_var shader_out INTERP_MODE_NONE mediump vec4 <span class="title">gl_FragColor</span> <span class="params">(FRAG_RESULT_COLOR.xyzw, <span class="number">4</span>, <span class="number">0</span>)</span></span></div><div class="line">decl_function <span class="title">main</span> <span class="params">(<span class="number">0</span> params)</span></div><div class="line"></div><div class="line">impl main &#123;</div><div class="line">    block block_0:</div><div class="line">    <span class="comment">/* preds: */</span></div><div class="line">    vec4 <span class="number">32</span> ssa_0 = load_const (<span class="number">0x3f800000</span> <span class="comment">/* 1.000000 */</span>, <span class="number">0x00000000</span> <span class="comment">/* 0.000000 */</span>, <span class="number">0x00000000</span> <span class="comment">/* 0.000000 */</span>, <span class="number">0x3f800000</span> <span class="comment">/* 1.000000 */</span>)</div><div class="line">    vec1 <span class="number">32</span> ssa_1 = load_const (<span class="number">0x00000000</span> <span class="comment">/* 0.000000 */</span>)</div><div class="line">    intrinsic store_output (ssa_0, ssa_1) (<span class="number">4</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">8388738</span>) <span class="comment">/* base=4 */</span> <span class="comment">/* wrmask=xyzw */</span> <span class="comment">/* component=0 */</span> <span class="comment">/* src_type=float32 */</span> <span class="comment">/* location=2 slots=1 mediump */</span> <span class="comment">/* gl_FragColor */</span></div><div class="line">    <span class="comment">/* succs: block_1 */</span></div><div class="line">    block block_1:</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EU code</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Native code for unnamed fragment shader GLSL3 (sha1 f7554fd836ad71e30768cdc6b984e294b8f2fae5)</div><div class="line">SIMD8 shader: 5 instructions. 0 loops. 18 cycles. 0:0 spills:fills, 1 sends, scheduled with mode top-down. Promoted 0 constants. Compacted 80 to 64 bytes (20%)</div><div class="line">   START B0 (18 cycles)</div><div class="line">mov(8)          g123&lt;1&gt;F        0x3f800000F      /* 1F */       &#123; align1 1Q &#125;;</div><div class="line">mov(8)          g124&lt;1&gt;F        0x0VF           /* [0F, 0F, 0F, 0F]VF */ &#123; align1 1Q compacted &#125;;</div><div class="line">mov(8)          g125&lt;1&gt;F        0x0VF           /* [0F, 0F, 0F, 0F]VF */ &#123; align1 1Q compacted &#125;;</div><div class="line">mov(8)          g126&lt;1&gt;F        0x3f800000F      /* 1F */       &#123; align1 1Q &#125;;</div><div class="line">sendc(8)        null&lt;1&gt;UW       g123&lt;0,1,0&gt;UD   0x88031400</div><div class="line">                            render MsgDesc: RT write SIMD8 LastRT Surface = 0 mlen 4 rlen 0 &#123; align1 1Q EOT &#125;;</div><div class="line">   END B0</div></pre></td></tr></table></figure>
<h1 id="0x3-Command生成"><a href="#0x3-Command生成" class="headerlink" title="0x3 Command生成"></a>0x3 Command生成</h1><p>Command Stream Unit是Gen GPU内部用来管理3D pipeline或者Media单元的模块，通过配置不同的Command Stream命令，我们可以精细地控制3D pipeline的运行。<br>Command Stream Unit还提供了URB分配和管理的功能。URB可以理解成是用来在各个Pipeline阶段(如VS, Rasterizer, Clipper, PS等)之间传递参数的buffer。</p>
<p>对Command Stream的编程，简单地理解就是把Graphics API的状态配置转换成Command Stream的命令。不同API函数执行的时候需要配置不同的Command Stream命令，我们可以通过command stream dump机制把生成command保存下来，然后通过可视化的工具分析出现时问题。mesa提供了可视化的viewer工具来分析生成的每个command。</p>
<p>对于Broadcom GPU来说，和Command Stream类似的概念叫做Control List，执行Control List的硬件模块叫做Control List Executor。Broadcom GPU驱动也需要配置Control List来驱动GPU的执行。</p>
<p>下面来说明一下一个简单的OpenGL ES应用执行的时候需要配置哪些Command Stream命令。</p>
<p>eglCreateContext调用以后，会执行driver初始化动作。需要配置下面这些Command。</p>
<p>GEN9_PIPE_CONTROL<br>GEN9_PIPE_CONTROL<br>GEN9_PIPELINE_SELECT<br>state GEN9_L3CNTLREG<br>GEN9_MI_LOAD_REGISTER_IMM<br>GEN9_PIPE_CONTROL<br>GEN9_STATE_BASE_ADDRESS<br>GEN9_PIPE_CONTROL<br>state GEN9_CS_DEBUG_MODE2<br>GEN9_MI_LOAD_REGISTER_IMM<br>state GEN9_CACHE_MODE_1<br>GEN9_MI_LOAD_REGISTER_IMM<br>GEN9_3DSTATE_DRAWING_RECTANGLE<br>GEN9_3DSTATE_SAMPLE_PATTERN<br>GEN9_3DSTATE_AA_LINE_PARAMETERS<br>GEN9_3DSTATE_WM_CHROMAKEY<br>GEN9_3DSTATE_WM_HZ_OP<br>GEN9_3DSTATE_POLY_STIPPLE_OFFSET<br>GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_VS<br>GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_VS<br>GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_VS<br>GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_VS<br>GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_VS<br>GEN9_3DSTATE_CC_STATE_POINTERS<br>GEN9_PIPE_CONTROL<br>GEN9_PIPE_CONTROL<br>GEN9_PIPELINE_SELECT<br>state GEN9_L3CNTLREG<br>GEN9_MI_LOAD_REGISTER_IMM<br>GEN9_PIPE_CONTROL<br>GEN9_PIPE_CONTROL<br>GEN9_STATE_BASE_ADDRESS<br>GEN9_PIPE_CONTROL<br>GEN9_PIPE_CONTROL</p>
<p>eglMakeCurrent调用以后，需要给frame buffer分配Gem buffer。</p>
<p>glShaderSource/glCompileShader创建shader对象，把glsl source code设置到gpu driver中。</p>
<p>glLinkProgram调用以后，执行glsl的编译动作，把glsl source code编译成glsl AST，然后转换成NIR。</p>
<p>glClear调用以后，mesa driver会通过Blit engine来执行clear操作，这个时候需要给Blit engine生成EU code。所以这个时候会生成glsl fragment shader code，再转换成NIR，再生成EU code。这个时候需要配置下面这些Command。</p>
<p>state GEN9_GT_MODE<br>GEN9_PIPE_CONTROL<br>GEN9_MI_LOAD_REGISTER_IMM</p>
<p>GEN9_PIPE_CONTROL<br>GEN9_PIPE_CONTROL</p>
<p>GEN9_PIPE_CONTROL<br>GEN9_STATE_BASE_ADDRESS<br>GEN9_PIPE_CONTROL</p>
<p>这边再说明一下，给Blit engine生成的fragment shader的NIR和EU code如下所示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">NIR (final form) <span class="keyword">for</span> fragment shader:</div><div class="line">shader: MESA_SHADER_FRAGMENT</div><div class="line">name: BLORP-clear</div><div class="line">inputs: <span class="number">0</span></div><div class="line">outputs: <span class="number">0</span></div><div class="line">uniforms: <span class="number">0</span></div><div class="line">shared: <span class="number">0</span></div><div class="line"><span class="function">decl_var shader_in INTERP_MODE_FLAT vec4 <span class="title">clear_color</span> <span class="params">(VARYING_SLOT_VAR0.xyzw, <span class="number">32</span>, <span class="number">0</span>)</span></span></div><div class="line">decl_var shader_out INTERP_MODE_NONE vec4 <span class="title">gl_FragColor</span> <span class="params">(FRAG_RESULT_COLOR.xyzw, <span class="number">4</span>, <span class="number">0</span>)</span></div><div class="line">decl_function <span class="title">main</span> <span class="params">(<span class="number">0</span> params)</span></div><div class="line"></div><div class="line">impl main &#123;</div><div class="line">        block block_0:</div><div class="line">        <span class="comment">/* preds: */</span></div><div class="line">        vec1 <span class="number">32</span> ssa_0 = load_const (<span class="number">0x00000000</span> <span class="comment">/* 0.000000 */</span>)</div><div class="line">        vec4 <span class="number">32</span> ssa_1 = intrinsic load_input (ssa_0) (<span class="number">32</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">160</span>) <span class="comment">/* base=32 */</span> <span class="comment">/* component=0 */</span> <span class="comment">/* dest_type=float32 */</span> <span class="comment">/* location=32 slots=1 */</span> <span class="comment">/* clear_color */</span></div><div class="line">        intrinsic store_output (ssa_1, ssa_0) (<span class="number">4</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">130</span>) <span class="comment">/* base=4 */</span> <span class="comment">/* wrmask=xyzw */</span> <span class="comment">/* component=0 */</span> <span class="comment">/* src_type=float32 */</span> <span class="comment">/* location=2 slots=1 */</span>       <span class="comment">/* gl_FragColor */</span></div><div class="line">        <span class="comment">/* succs: block_1 */</span></div><div class="line">        block block_1:</div><div class="line">&#125;</div><div class="line"></div><div class="line">Native code <span class="keyword">for</span> unnamed fragment shader BLORP-clear (sha1 <span class="number">867</span>c2b9794cc6654dbcf091d8a21323f01e0d409)</div><div class="line">SIMD16 shader: <span class="number">2</span> instructions. <span class="number">0</span> loops. <span class="number">12</span> cycles. <span class="number">0</span>:<span class="number">0</span> spills:fills, <span class="number">1</span> sends, scheduled with mode (null). Promoted <span class="number">0</span> constants. Compacted <span class="number">32</span> to <span class="number">32</span> bytes (<span class="number">0</span>%)</div><div class="line">   START B0 (<span class="number">12</span> cycles)</div><div class="line">mov(<span class="number">4</span>)          g114&lt;<span class="number">1</span>&gt;F        g2<span class="number">.3</span>&lt;<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>&gt;F                    &#123; align1 WE_all <span class="number">1</span>N &#125;;</div><div class="line">sendc(<span class="number">16</span>)       null&lt;<span class="number">1</span>&gt;UW       g114&lt;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&gt;F    <span class="number">0x82031100</span></div><div class="line">                            render MsgDesc: RT write SIMD16/RepData LastRT Surface = <span class="number">0</span> mlen <span class="number">1</span> rlen <span class="number">0</span> &#123; align1 <span class="number">1</span>H EOT &#125;;</div><div class="line">   END B0</div></pre></td></tr></table></figure></p>
<p>然后通过下面代码加载Vertex数据。<br>   glVertexAttribPointer ( 0, 3, GL_FLOAT, GL_FALSE, 0, vVertices );<br>   glEnableVertexAttribArray ( 0 );</p>
<p>调用下面的函数执行Draw操作。<br>    glDrawArrays ( GL_TRIANGLES, 0, 3 );<br>这个时候才会把对应shader的NIR代码转换成EU code。注意前面执行glCompileShader的时候只是生成了NIR，没有完成EU code的生成，也就是说编译器的后端到这个时候才开始工作。</p>
<p>先生成fragment shader的EU code，然后把EU code配置到下面的command中。<br>其中GEN9_3DSTATE_PS有一个分量会指明PS对应的EU Code保存地址。<br>  GEN9_3DSTATE_PS<br>  GEN9_3DSTATE_PS_EXTRA</p>
<p>然后生成vertex shader的EU code，然后把EU code配置到下面的command中。<br>其中GEN9_3DSTATE_VS有一个分量会指明VS对应的EU Code保存地址。<br>  GEN9_3DSTATE_STREAMOUT<br>  GEN9_3DSTATE_SO_DECL_LIST<br>  GEN9_3DSTATE_VS</p>
<p>然后继续配置如下的command。其中GEN9_3DPRIMITIVE用来说明了需要参加绘制的Vertex数目。<br>state GEN9_BLEND_STATE_ENTRY<br>state GEN9_BLEND_STATE_ENTRY<br>state GEN9_BLEND_STATE_ENTRY<br>state GEN9_BLEND_STATE_ENTRY<br>state GEN9_BLEND_STATE_ENTRY<br>state GEN9_BLEND_STATE_ENTRY<br>state GEN9_BLEND_STATE_ENTRY<br>state GEN9_BLEND_STATE_ENTRY<br>GEN9_3DSTATE_PS_BLEND<br>state GEN9_BLEND_STATE<br>GEN9_3DSTATE_SF<br>GEN9_3DSTATE_RASTER<br>GEN9_3DSTATE_CLIP<br>GEN9_3DSTATE_WM<br>GEN9_3DSTATE_LINE_STIPPLE<br>GEN9_3DSTATE_VERTEX_ELEMENTS<br>state GEN9_VERTEX_ELEMENT_STATE<br>GEN9_3DSTATE_VF_INSTANCING<br>state GEN9_VERTEX_ELEMENT_STATE<br>GEN9_3DSTATE_VF_INSTANCING<br>state GEN9_VERTEX_BUFFER_STATE<br>GEN9_PIPE_CONTROL<br>state GEN9_CS_CHICKEN1<br>GEN9_MI_LOAD_REGISTER_IMM<br>state GEN9_CC_VIEWPORT<br>GEN9_3DSTATE_VIEWPORT_STATE_POINTERS_CC<br>state GEN9_SF_CLIP_VIEWPORT<br>GEN9_3DSTATE_VIEWPORT_STATE_POINTERS_SF_CLIP<br>GEN9_3DSTATE_URB_VS<br>GEN9_3DSTATE_URB_VS<br>GEN9_3DSTATE_URB_VS<br>GEN9_3DSTATE_URB_VS<br>state GEN9_BLEND_STATE<br>GEN9_3DSTATE_BLEND_STATE_POINTERS<br>state GEN9_COLOR_CALC_STATE<br>GEN9_3DSTATE_CC_STATE_POINTERS<br>GEN9_3DSTATE_CONSTANT_VS<br>GEN9_3DSTATE_CONSTANT_VS<br>GEN9_3DSTATE_BINDING_TABLE_POINTERS_VS<br>GEN9_3DSTATE_BINDING_TABLE_POINTERS_VS<br>GEN9_3DSTATE_BINDING_TABLE_POINTERS_VS<br>GEN9_3DSTATE_BINDING_TABLE_POINTERS_VS<br>GEN9_3DSTATE_BINDING_TABLE_POINTERS_VS<br>GEN9_3DSTATE_SAMPLER_STATE_POINTERS_VS<br>GEN9_3DSTATE_SAMPLER_STATE_POINTERS_VS<br>GEN9_3DSTATE_MULTISAMPLE<br>GEN9_3DSTATE_SAMPLE_MASK<br>GEN9_3DSTATE_HS<br>GEN9_3DSTATE_TE<br>GEN9_3DSTATE_DS<br>GEN9_3DSTATE_GS<br>GEN9_3DSTATE_PS<br>GEN9_3DSTATE_PS_EXTRA<br>GEN9_3DSTATE_STREAMOUT<br>GEN9_3DSTATE_CLIP<br>GEN9_3DSTATE_SF<br>GEN9_3DSTATE_WM<br>GEN9_3DSTATE_SBE<br>GEN9_3DSTATE_SBE_SWIZ<br>GEN9_3DSTATE_PS_BLEND<br>GEN9_3DSTATE_WM_DEPTH_STENCIL<br>GEN9_3DSTATE_SCISSOR_STATE_POINTERS<br>GEN9_3DSTATE_CLEAR_PARAMS<br>GEN9_3DSTATE_POLY_STIPPLE_PATTERN<br>GEN9_3DSTATE_VF_TOPOLOGY<br>GENX(3DSTATE_VERTEX_BUFFERS)<br>GEN9_3DSTATE_VF_SGVS<br>GEN9_3DSTATE_VF<br>GEN9_3DSTATE_VF_STATISTICS<br>GEN9_3DPRIMITIVE</p>
<p>最后执行eglSwapBuffers，把前面生成的command都送到GPU kernel driver中，然后启动GPU硬件完成绘制。<br>GEN9_PIPE_CONTROL<br>GEN9_PIPE_CONTROL<br>GEN9_PIPE_CONTROL</p>
<h1 id="0x4-Command配置的实现"><a href="#0x4-Command配置的实现" class="headerlink" title="0x4 Command配置的实现"></a>0x4 Command配置的实现</h1><p>这里以Vulkan driver中的Command配置实现为例说明Mesa中Gen gpu的command是如何配置的。对OpenGL driver来说，这部分实现也是很类似的。</p>
<p>通过xml配置文件来保存Command Streamer的结构体信息，然后在编译的时候通过python代码把xml文件转换成对应的配置头文件。这个过程如下图所示。<br><img src="/2019/07/13/Deep about Intel Gen Driver/genXml.svg" alt=""><br>其中可以看到Gen的各种Driver实现都依赖于这个配置头文件。另外提到一点就是这些配置的函数都是在不同的Driver中实现的，有不少冗余代码，可以作为一个代码优化方向。</p>
<p>xml的内容是参考下面两个文档(以Gen11为例)来生成的。</p>
<p>Intel® Iris® Plus Graphics and UHD Graphics Open Source<br>Programmer’s Reference Manual<br>For the 2019 10th Generation Intel CoreTM Processors based on the<br>“Ice Lake” Platform<br>Volume 2a - Command Reference: Instructions (Command Opcodes)</p>
<p>Intel® Iris® Plus Graphics and UHD Graphics Open<br>Source<br>Programmer’s Reference Manual<br>For the 2019 10th Generation Intel CoreTM Processors<br>based on the “Ice Lake” Platform<br>Volume 8: Command Stream Programming</p>
<p>下面截取了部分xml内容如下所示。其中包括了PIPE_CONTROL的配置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;instruction name=<span class="string">"PIPE_CONTROL"</span> bias=<span class="string">"2"</span> length=<span class="string">"6"</span> engine=<span class="string">"render"</span>&gt;</div><div class="line">  &lt;field name=<span class="string">"DWord Length"</span> start=<span class="string">"0"</span> end=<span class="string">"7"</span> type=<span class="string">"uint"</span> <span class="keyword">default</span>=<span class="string">"4"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"3D Command Sub Opcode"</span> start=<span class="string">"16"</span> end=<span class="string">"23"</span> type=<span class="string">"uint"</span> <span class="keyword">default</span>=<span class="string">"0"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"3D Command Opcode"</span> start=<span class="string">"24"</span> end=<span class="string">"26"</span> type=<span class="string">"uint"</span> <span class="keyword">default</span>=<span class="string">"2"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Command SubType"</span> start=<span class="string">"27"</span> end=<span class="string">"28"</span> type=<span class="string">"uint"</span> <span class="keyword">default</span>=<span class="string">"3"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Command Type"</span> start=<span class="string">"29"</span> end=<span class="string">"31"</span> type=<span class="string">"uint"</span> <span class="keyword">default</span>=<span class="string">"3"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Depth Cache Flush Enable"</span> start=<span class="string">"32"</span> end=<span class="string">"32"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Stall At Pixel Scoreboard"</span> start=<span class="string">"33"</span> end=<span class="string">"33"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"State Cache Invalidation Enable"</span> start=<span class="string">"34"</span> end=<span class="string">"34"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Constant Cache Invalidation Enable"</span> start=<span class="string">"35"</span> end=<span class="string">"35"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"VF Cache Invalidation Enable"</span> start=<span class="string">"36"</span> end=<span class="string">"36"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"DC Flush Enable"</span> start=<span class="string">"37"</span> end=<span class="string">"37"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Pipe Control Flush Enable"</span> start=<span class="string">"39"</span> end=<span class="string">"39"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Notify Enable"</span> start=<span class="string">"40"</span> end=<span class="string">"40"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Indirect State Pointers Disable"</span> start=<span class="string">"41"</span> end=<span class="string">"41"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Texture Cache Invalidation Enable"</span> start=<span class="string">"42"</span> end=<span class="string">"42"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Instruction Cache Invalidate Enable"</span> start=<span class="string">"43"</span> end=<span class="string">"43"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Render Target Cache Flush Enable"</span> start=<span class="string">"44"</span> end=<span class="string">"44"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Depth Stall Enable"</span> start=<span class="string">"45"</span> end=<span class="string">"45"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Post Sync Operation"</span> start=<span class="string">"46"</span> end=<span class="string">"47"</span> type=<span class="string">"uint"</span>&gt;</div><div class="line">    &lt;value name=<span class="string">"No Write"</span> value=<span class="string">"0"</span>/&gt;</div><div class="line">    &lt;value name=<span class="string">"Write Immediate Data"</span> value=<span class="string">"1"</span>/&gt;</div><div class="line">    &lt;value name=<span class="string">"Write PS Depth Count"</span> value=<span class="string">"2"</span>/&gt;</div><div class="line">    &lt;value name=<span class="string">"Write Timestamp"</span> value=<span class="string">"3"</span>/&gt;</div><div class="line">  &lt;/field&gt;</div><div class="line">  &lt;field name=<span class="string">"Generic Media State Clear"</span> start=<span class="string">"48"</span> end=<span class="string">"48"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"TLB Invalidate"</span> start=<span class="string">"50"</span> end=<span class="string">"50"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Global Snapshot Count Reset"</span> start=<span class="string">"51"</span> end=<span class="string">"51"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Command Streamer Stall Enable"</span> start=<span class="string">"52"</span> end=<span class="string">"52"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Store Data Index"</span> start=<span class="string">"53"</span> end=<span class="string">"53"</span> type=<span class="string">"uint"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"LRI Post Sync Operation"</span> start=<span class="string">"55"</span> end=<span class="string">"55"</span> type=<span class="string">"uint"</span>&gt;</div><div class="line">    &lt;value name=<span class="string">"No LRI Operation"</span> value=<span class="string">"0"</span>/&gt;</div><div class="line">    &lt;value name=<span class="string">"MMIO Write Immediate Data"</span> value=<span class="string">"1"</span>/&gt;</div><div class="line">  &lt;/field&gt;</div><div class="line">  &lt;field name=<span class="string">"Destination Address Type"</span> start=<span class="string">"56"</span> end=<span class="string">"56"</span> type=<span class="string">"uint"</span> prefix=<span class="string">"DAT"</span>&gt;</div><div class="line">    &lt;value name=<span class="string">"PPGTT"</span> value=<span class="string">"0"</span>/&gt;</div><div class="line">    &lt;value name=<span class="string">"GGTT"</span> value=<span class="string">"1"</span>/&gt;</div><div class="line">  &lt;/field&gt;</div><div class="line">  &lt;field name=<span class="string">"Flush LLC"</span> start=<span class="string">"58"</span> end=<span class="string">"58"</span> type=<span class="string">"bool"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Address"</span> start=<span class="string">"66"</span> end=<span class="string">"111"</span> type=<span class="string">"address"</span>/&gt;</div><div class="line">  &lt;field name=<span class="string">"Immediate Data"</span> start=<span class="string">"128"</span> end=<span class="string">"191"</span> type=<span class="string">"uint"</span>/&gt;</div><div class="line">&lt;/instruction&gt;</div></pre></td></tr></table></figure>
<p>把xml内容转换后头文件内容如下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GEN9_PIPE_CONTROL_length               6</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GEN9_PIPE_CONTROL_length_bias          2</span></div><div class="line"><span class="comment">// 定义Command的头信息</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GEN9_PIPE_CONTROL_header                \</span></div><div class="line">   .DWordLength                         =      4,  \</div><div class="line">   ._3DCommandSubOpcode                 =      0,  \</div><div class="line">   ._3DCommandOpcode                    =      2,  \</div><div class="line">   .CommandSubType                      =      3,  \</div><div class="line">   .CommandType                         =      3</div><div class="line"></div><div class="line"><span class="comment">// 定义Command的结构体信息</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GEN9_PIPE_CONTROL</span> &#123;</span></div><div class="line">   <span class="keyword">uint32_t</span>                             DWordLength;</div><div class="line">   <span class="keyword">uint32_t</span>                             _3DCommandSubOpcode;</div><div class="line">   <span class="keyword">uint32_t</span>                             _3DCommandOpcode;</div><div class="line">   <span class="keyword">uint32_t</span>                             CommandSubType;</div><div class="line">   <span class="keyword">uint32_t</span>                             CommandType;</div><div class="line">   <span class="keyword">bool</span>                                 DepthCacheFlushEnable;</div><div class="line">   <span class="keyword">bool</span>                                 StallAtPixelScoreboard;</div><div class="line">   <span class="keyword">bool</span>                                 StateCacheInvalidationEnable;</div><div class="line">   <span class="keyword">bool</span>                                 ConstantCacheInvalidationEnable;</div><div class="line">   <span class="keyword">bool</span>                                 VFCacheInvalidationEnable;</div><div class="line">   <span class="keyword">bool</span>                                 DCFlushEnable;</div><div class="line">   <span class="keyword">bool</span>                                 PipeControlFlushEnable;</div><div class="line">   <span class="keyword">bool</span>                                 NotifyEnable;</div><div class="line">   <span class="keyword">bool</span>                                 IndirectStatePointersDisable;</div><div class="line">   <span class="keyword">bool</span>                                 TextureCacheInvalidationEnable;</div><div class="line">   <span class="keyword">bool</span>                                 InstructionCacheInvalidateEnable;</div><div class="line">   <span class="keyword">bool</span>                                 RenderTargetCacheFlushEnable;</div><div class="line">   <span class="keyword">bool</span>                                 DepthStallEnable;</div><div class="line">   <span class="keyword">uint32_t</span>                             PostSyncOperation;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NoWrite                                  0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WriteImmediateData                       1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WritePSDepthCount                        2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WriteTimestamp                           3</span></div><div class="line">   <span class="keyword">bool</span>                                 GenericMediaStateClear;</div><div class="line">   <span class="keyword">bool</span>                                 TLBInvalidate;</div><div class="line">   <span class="keyword">bool</span>                                 GlobalSnapshotCountReset;</div><div class="line">   <span class="keyword">bool</span>                                 CommandStreamerStallEnable;</div><div class="line">   <span class="keyword">uint32_t</span>                             StoreDataIndex;</div><div class="line">   <span class="keyword">uint32_t</span>                             LRIPostSyncOperation;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NoLRIOperation                           0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MMIOWriteImmediateData                   1</span></div><div class="line">   <span class="keyword">uint32_t</span>                             DestinationAddressType;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DAT_PPGTT                                0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DAT_GGTT                                 1</span></div><div class="line">   <span class="keyword">bool</span>                                 FlushLLC;</div><div class="line">   __gen_address_type                   Address;</div><div class="line">   <span class="keyword">uint64_t</span>                             ImmediateData;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Command配置的宏定义如下。<br>该宏定义包括了所有Command的配置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __anv_cmd_header(cmd) cmd ## _header</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __anv_cmd_pack(cmd) cmd ## _pack</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> anv_batch_emit(batch, cmd, name)                            \</span></div><div class="line">   for (struct cmd name = &#123; __anv_cmd_header(cmd) &#125;,                    \</div><div class="line">        *_dst = anv_batch_emit_dwords(batch, __anv_cmd_length(cmd));    \</div><div class="line">        __builtin_expect(_dst != NULL, 1);                              \</div><div class="line">        (&#123; __anv_cmd_pack(cmd)(batch, _dst, &amp;name);                     \</div><div class="line">           printf(<span class="meta-string">"%s\n"</span>, #cmd);                                        \</div><div class="line">           VG(VALGRIND_CHECK_MEM_IS_DEFINED(_dst, __anv_cmd_length(cmd) * 4)); \</div><div class="line">           _dst = NULL;                                                 \</div><div class="line">         &#125;))</div></pre></td></tr></table></figure></p>
<p>上面的宏定义是通过实现各个不同Command的pack函数(也是通过前面的genXml自动生成的)来实现不同Command的配置的。</p>
<p>例如下面的函数实现了PIPE_CONTROL Command的结构体信息配置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">static inline __attribute__((always_inline)) void</div><div class="line">GEN9_PIPE_CONTROL_pack(__attribute__((unused)) __gen_user_data *data,</div><div class="line">                       __attribute__((unused)) void * restrict dst,</div><div class="line">                       __attribute__((unused)) const struct GEN9_PIPE_CONTROL * restrict values)</div><div class="line">&#123;</div><div class="line">   uint32_t * restrict dw = (uint32_t * restrict) dst;</div><div class="line"></div><div class="line">   dw[0] =</div><div class="line">      __gen_uint(values-&gt;DWordLength, 0, 7) |</div><div class="line">      __gen_uint(values-&gt;_3DCommandSubOpcode, 16, 23) |</div><div class="line">      __gen_uint(values-&gt;_3DCommandOpcode, 24, 26) |</div><div class="line">      __gen_uint(values-&gt;CommandSubType, 27, 28) |</div><div class="line">      __gen_uint(values-&gt;CommandType, 29, 31);</div><div class="line"></div><div class="line">   dw[1] =</div><div class="line">      __gen_uint(values-&gt;DepthCacheFlushEnable, 0, 0) |</div><div class="line">      __gen_uint(values-&gt;StallAtPixelScoreboard, 1, 1) |</div><div class="line">      __gen_uint(values-&gt;StateCacheInvalidationEnable, 2, 2) |</div><div class="line">      __gen_uint(values-&gt;ConstantCacheInvalidationEnable, 3, 3) |</div><div class="line">      __gen_uint(values-&gt;VFCacheInvalidationEnable, 4, 4) |</div><div class="line">      __gen_uint(values-&gt;DCFlushEnable, 5, 5) |</div><div class="line">      __gen_uint(values-&gt;PipeControlFlushEnable, 7, 7) |</div><div class="line">      __gen_uint(values-&gt;NotifyEnable, 8, 8) |</div><div class="line">      __gen_uint(values-&gt;IndirectStatePointersDisable, 9, 9) |</div><div class="line">      __gen_uint(values-&gt;TextureCacheInvalidationEnable, 10, 10) |</div><div class="line">      __gen_uint(values-&gt;InstructionCacheInvalidateEnable, 11, 11) |</div><div class="line">      __gen_uint(values-&gt;RenderTargetCacheFlushEnable, 12, 12) |</div><div class="line">      __gen_uint(values-&gt;DepthStallEnable, 13, 13) |</div><div class="line">      __gen_uint(values-&gt;PostSyncOperation, 14, 15) |</div><div class="line">      __gen_uint(values-&gt;GenericMediaStateClear, 16, 16) |</div><div class="line">      __gen_uint(values-&gt;TLBInvalidate, 18, 18) |</div><div class="line">      __gen_uint(values-&gt;GlobalSnapshotCountReset, 19, 19) |</div><div class="line">      __gen_uint(values-&gt;CommandStreamerStallEnable, 20, 20) |</div><div class="line">      __gen_uint(values-&gt;StoreDataIndex, 21, 21) |</div><div class="line">      __gen_uint(values-&gt;LRIPostSyncOperation, 23, 23) |</div><div class="line">      __gen_uint(values-&gt;DestinationAddressType, 24, 24) |</div><div class="line">      __gen_uint(values-&gt;FlushLLC, 26, 26);</div><div class="line"></div><div class="line">   const uint64_t v2_address =</div><div class="line">      __gen_combine_address(data, &amp;dw[2], values-&gt;Address, 0);</div><div class="line">   dw[2] = v2_address;</div><div class="line">   dw[3] = v2_address &gt;&gt; 32;</div><div class="line"></div><div class="line">   const uint64_t v4 =</div><div class="line">      __gen_uint(values-&gt;ImmediateData, 0, 63);</div><div class="line">   dw[4] = v4;</div><div class="line">   dw[5] = v4 &gt;&gt; 32;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Vulkan驱动中通过类似的配置的调用代码来设置具体的Command信息。<br>最后调用的函数是前面实现的GEN9_PIPE_CONTROL_pack()。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">anv_batch_emit(&amp;cmd_buffer-&gt;batch, GENX(PIPE_CONTROL), pc) &#123;</div><div class="line">    pc.DCFlushEnable = <span class="literal">true</span>;</div><div class="line">    pc.RenderTargetCacheFlushEnable = <span class="literal">true</span>;</div><div class="line">    pc.CommandStreamerStallEnable = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/Graphics buffer Summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/Graphics buffer Summary/" itemprop="url">Graphics buffer总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T18:20:31+09:00">
                2019-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/06/01/Graphics buffer Summary/" class="leancloud_visitors" data-flag-title="Graphics buffer总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-GPU系统Buffer介绍"><a href="#0x1-GPU系统Buffer介绍" class="headerlink" title="0x1 GPU系统Buffer介绍"></a>0x1 GPU系统Buffer介绍</h1><p>  本文对GPU系统中的buffer管理进行了总结。<br>  简单说来GPU系统使用到的buffer主要包括两部分，其中一部分是GPU绘制输出的frame buffer， 另外一部分是GPU driver中内部运行所需的各种buffer。<br>  这些buffer在CPU和GPU之间的pipeline如下图所示。<br>  从图中可知，Graphics程序运行的时候首先需要CPU先准备好各种数据，如纹理，顶点数据等。另外很大一块是Command，这个是用来驱动GPU硬件执行图形流水线的指令。另外Shader指的是用来执行GPU可编程pileine(如vertex shader，fragment shader等)的GPU指令。<br>  CPU把数据准备好了以后，驱动GPU硬件根据前面buffer里的数据和指令执行绘制工作，绘制的结果需要输出到一个地方，这个就是frame buffer。当然我们知道frame buffer也是可以被GPU再读进来。图中的Bin List部分指的是在Tile Based Render架构特有的buffer，这个buffer用来存储Tile划分(一般称为Binning阶段)以后每个Tile需要绘制的信息。</p>
<p>  <img src="/2019/06/01/Graphics buffer Summary/gpu bufer pileline.svg" alt=""></p>
<h1 id="0x2-Frame-Buffer"><a href="#0x2-Frame-Buffer" class="headerlink" title="0x2 Frame Buffer"></a>0x2 Frame Buffer</h1><p>  下面先来介绍一下Android系统中Graphics Buffer管理模块，后续再介绍一下DRM结构下Buffer分配的流程。<br>  Android系统中Graphics Buffer的架构图如下所示。<br>  <img src="/2019/06/01/Graphics buffer Summary/android buffer management.svg" alt=""></p>
<p>  Android系统中Graphics框架或应用通过Gralloc模块调用到ION driver，再通过ION driver分配出相应的frame buffer。如上图所示，ION driver中提供多种不同的heap。Carveout heap一般是指系统启动的时候预分配好的物理连续地址空间，缺点是这部分内存属于特定驱动独占式的，不能和其他模块共享，目前已经很少使用了。CMA(contiguous memory allocation) heap分配出来的buffer的物理地址也是连续的，但是它是在系统运行过程中通过内核中CMA框架来动态分配的。system heap分配出来的buffer其物理地址一般不是连续的。这三种类型的buffer适用于不同的硬件类型。对没有MMU的硬件来说，一般需要要求其访问的物理地址空间是连续的，所以这种硬件一般要求分配的buffer是CMA heap。对包含MMU的硬件来说，由于可以通过MMU(也称为IOMMU)来做虚拟地址到物理地址的转换，所以可以不需要保证其分配的buffer的物理地址空间是连续的。</p>
<p>  下面来介绍一下DRM架构下buffer分配的流程。<br>  传统的Linux系统如Ubuntu系统采用的是DRM架构图形系统，这个时候通过DRM kernel driver中的GEM模块来分配buffer。GEM是DRM kernel driver的buffer管理模块。其分配出来的buffer一般称为GEM buffer。其buffer分配过程简单说明如下。<br>  <img src="/2019/06/01/Graphics buffer Summary/drm buffer management.svg" alt=""></p>
<p>  为了简化DRM架构下GEM buffer的分配工作，其提供了libgbm模块作为管理kernel driver和图形应用之间的buffer分配的桥梁。<br>  libgbm的功能类似于Android上的gralloc+libion。mesa中包括了libgbm的实现代码。libgbm提供了底层DRM driver中buffer管理的封装。一般包括分配(DRM_IOCTL_MODE_CREATE_DUMB)，释放(DRM_IOCTL_MODE_DESTROY_DUMB)和mmap操作(DRM_IOCTL_MODE_MAP_DUMB)等操作。各种采用Linux作为内核的操作系统的HAL模块都提供了类似libgbm功能的buffer管理模块。</p>
<p>  下面来简单介绍一下为什么要执行 DRM_IOCTL_MODE_MAP_DUMB? DRM_IOCTL_MODE_MAP_DUMB的输入是一个 gem handle，返回结果是一个 offset，通过 offset 可以知道 mmap 当前要操作的dumb buffer。所以对 drm device 进行 mmap 操作时，其参数offset 并不是真正的内存偏移量，而是一个 gem object 的索引值。通过该索引值，drm 驱动就可以准确确定当前要操作的是哪个 gem对象，然后可以获取到与该 object 相对应的物理 buffer，并对完成真正的 mmap 操作。</p>
<p>   libgbm中DRM_IOCTL_MODE_MAP_DUMB的使用如下所示。可以看到和前面的解析是可以对应起来的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">map_arg.handle = bo-&gt;handle;</div><div class="line"></div><div class="line">ret = drmIoctl(bo-&gt;base.gbm-&gt;fd, DRM_IOCTL_MODE_MAP_DUMB, &amp;map_arg);</div><div class="line"><span class="keyword">if</span> (ret)</div><div class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">bo-&gt;<span class="built_in">map</span> = mmap(<span class="number">0</span>, bo-&gt;size, PROT_WRITE,</div><div class="line">               MAP_SHARED, bo-&gt;base.gbm-&gt;fd, map_arg.offset);</div></pre></td></tr></table></figure></p>
<p>   下面来说一下mesa driver中frame buffer分配过程。<br>   调用eglCreateWindowSurface之类的函数会指明需要创建Suface。这个时候一般不会真正分配buffer，而是会创建类似buffer的占位符的Suface对象。然后等真正需要使用这个buffer的时候才完成分配工作，这里面体现了defer分配的思想。<br>   下面介绍一下真正需要分配buffer的时候buffer是如何分配出来的。<br>   首先通过eglMakeCurrent分配，具体流程如下。这个分配出来的buffer供给后续的eglSwapBuffer使用。<br>    <img src="/2019/06/01/Graphics buffer Summary/eglMakeCurrent.svg" alt=""></p>
<p>   eglSwapBuffer在前面分配好的buffer执行完绘制工作以后，对应的buffer可能送去合成模块继续执行合成动作了。如果后面再调用glClear，需要分配新的buffer，具体流程如下。<br>   <img src="/2019/06/01/Graphics buffer Summary/glClear.svg" alt=""></p>
<p>   在eglMakeCurrent和glClear调用执行buffer分配工作的时候，需要找到一块目标buffer执行clear操作，如果这个时候没有可用的buffer，或者buffer大小不符合要求，则需要重新分配一块新的buffer。</p>
<p>   前面看到，不同的Graphics API函数都可能触发buffer的分配，但是每个egl context可以分配buffer的数量是有限制的，一般是2~3个。如果buffer用完了，这个时候可能就需要等待一个空的可用的buffer从其他的pipeline中释放出来。如我们可能在systrace上看到glClear函数占用很长时间，这个时候就会感觉很奇怪，因为glClear按理说不应该占用GPU太长时间，这个时候大概率是在等待一个空的buffer变成可用，并不是在GPU在执行繁重的绘制任务。</p>
<h1 id="0x3-GPU-driver中内部使用的buffer"><a href="#0x3-GPU-driver中内部使用的buffer" class="headerlink" title="0x3 GPU driver中内部使用的buffer"></a>0x3 GPU driver中内部使用的buffer</h1><p>   这里介绍的buffer一般是指GPU driver运行过程中内部需要的各种buffer，如常见的texture buffer,vertex buffer,shader buffer, command buffer。这种buffer一般用来保存GPU需要读取的各种数据, 这种buffer的使用一般流程是先通过kernel driver分配出来，然后mmap到CPU端，CPU完成写入以后，GPU开始读取。GPU读取的时候会涉及到GPU MMU的动作，需要完成GPU虚拟地址到GPU物理地址的转换。</p>
<p>   Andorid的GPU驱动架构下，其内部使用的buffer管理一般是char kernel driver+闭源User space library的架构来实现。kernel driver通过alloc_pages之类的底层API直接分配buffer，然后mmap到User space给CPU写入，写入完成通过ioctl通知GPU硬件开始使用这些buffer。</p>
<p>   下面来简单介绍一下Intel Gen i915 kernel driver中GEM buffer实现。<br>    i915 kernel driver提供了下面三种gem buffer实现。<br>    其中shmem_region_ops采用的是shmem机制来分配内存，shmem是一套ipc，通过相应的ipc系统调用shmget能够以指定key创建一块的共享内存。需要使用这块内存的进程可以通过shmat系统调用来获得它。<br>    stolen buffer指的通过GTT(Graphics translation table)来管理的buffer，这里面类似GTT,PPGTT的概念都是很大的一块技术，这里就不深入介绍了。<br>    下面直接贴出i915 kernel driver中三种gem buffer定义和初始化的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> intel_region_id &#123;</div><div class="line">    INTEL_REGION_SMEM = <span class="number">0</span>,</div><div class="line">    INTEL_REGION_LMEM,</div><div class="line">    INTEL_REGION_STOLEN,</div><div class="line">    INTEL_REGION_UNKNOWN, <span class="comment">/* Should be last */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">intel_memory_region_ops</span> <span class="title">shmem_region_ops</span> = &#123;</span></div><div class="line">    .init = init_shmem,</div><div class="line">    .release = release_shmem,</div><div class="line">    .create_object = create_shmem,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">intel_memory_region_ops</span> <span class="title">i915_region_stolen_ops</span> = &#123;</span></div><div class="line">    .init = init_stolen,</div><div class="line">    .release = release_stolen,</div><div class="line">    .create_object = _i915_gem_object_create_stolen,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">intel_memory_region_ops</span> <span class="title">intel_region_lmem_ops</span> = &#123;</span></div><div class="line">    .init = region_lmem_init,</div><div class="line">    .release = region_lmem_release,</div><div class="line">    .create_object = __i915_gem_lmem_object_create,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">intel_memory_regions_hw_probe</span><span class="params">(struct drm_i915_private *i915)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> err, i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(i915-&gt;mm.regions); i++) &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">intel_memory_region</span> *<span class="title">mem</span> = <span class="title">ERR_PTR</span>(-<span class="title">ENODEV</span>);</span></div><div class="line">        u32 type;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!HAS_REGION(i915, BIT(i)))</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        type = MEMORY_TYPE_FROM_REGION(intel_region_map[i]);</div><div class="line">        <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="keyword">case</span> INTEL_MEMORY_SYSTEM:</div><div class="line">            mem = i915_gem_shmem_setup(i915);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> INTEL_MEMORY_STOLEN:</div><div class="line">            mem = i915_gem_stolen_setup(i915);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> INTEL_MEMORY_LOCAL:</div><div class="line">            mem = intel_setup_fake_lmem(i915);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (IS_ERR(mem)) &#123;</div><div class="line">            err = PTR_ERR(mem);</div><div class="line">            drm_err(&amp;i915-&gt;drm,</div><div class="line">                <span class="string">"Failed to setup region(%d) type=%d\n"</span>,</div><div class="line">                err, type);</div><div class="line">            <span class="keyword">goto</span> out_cleanup;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mem-&gt;id = intel_region_map[i];</div><div class="line">        mem-&gt;type = type;</div><div class="line">        mem-&gt;instance = MEMORY_INSTANCE_FROM_REGION(intel_region_map[i]);</div><div class="line"></div><div class="line">        i915-&gt;mm.regions[i] = mem;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  另外我们知道buffer的分配是很heavy的操作，gpu驱动一般都提供了cache机制来缓存使用过的buffer，也就是说延迟释放这些使用过的buffer。mesa和broadcom gpu驱动中实现了用户态驱动的cache机制，mali早期gpu(mali400/450)在kernel space driver中加了cache机制。从性能的角度的来说，用户态驱动的cache应该更好一些，毕竟少了从用户态到内核态的调用，但是用户态驱动的cache实现复杂一些。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/06/Use AI to speed up AV1 encoder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/06/Use AI to speed up AV1 encoder/" itemprop="url">Use AI to speed up AV1 encoder</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-06T17:00:10+09:00">
                2019-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/06/Use AI to speed up AV1 encoder/" class="leancloud_visitors" data-flag-title="Use AI to speed up AV1 encoder">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-AV1的编码复杂性"><a href="#0x1-AV1的编码复杂性" class="headerlink" title="0x1 AV1的编码复杂性"></a>0x1 AV1的编码复杂性</h1><p>我们知道AV1的官方参考实现是libaom，由于AV1的编码复杂度高，如果采用libaom编码器来生成AV1的码流离实时编码还有很大的距离。我们知道传统视频编码器中有宏块的概念，宏块是16x16的亮度块 + 2个 8x8的色度快。从HEVC开始，到现在的AV1进一步引入了partiton的概念，也就是树形编码的概念，也就是说把先规定好最大的编码单元，这个最大的编码单元称为super block，在HEVC一般是64x64，在AV1中为128x128。然后进行四叉树划分，AV1中直至划分成4x4，HEVC中直至划分成8x8。而且这种划分进一步扩展到预测单元和变换单元。据统计，AV1编码中的复杂度80%是因为partiton引入的，所以要是能有一个快速方法来加速partiton的判断的话，AV1的编码速度能大幅提升。</p>
<p>AV1中的partiton划分如下图所示。<br><img src="https://wenxiaoming.github.io/2019/03/02/The-overview-of-AV1-coding/partition2.png" alt=""></p>
<h1 id="0x2-AI加速partiton划分"><a href="#0x2-AI加速partiton划分" class="headerlink" title="0x2 AI加速partiton划分"></a>0x2 AI加速partiton划分</h1><pre><code>在libaom目前的实现中，AI加速主要用在intra frame的partition划分优化上。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">av1_intra_mode_cnn_partition(</div><div class="line">    &amp;cpi-&gt;common, x, bsize, x-&gt;quad_tree_idx, &amp;partition_none_allowed,</div><div class="line">    &amp;partition_horz_allowed, &amp;partition_vert_allowed, &amp;do_rectangular_split,</div><div class="line">    &amp;do_square_split);</div></pre></td></tr></table></figure>
<p>该函数的输入是图像的像素值，可以理解为图像对应的纹理。并且需要把对应亮度/色度值转换成0~1之间的浮点数。如下代码所示，c为亮度或色度分量的index，这里c为0，为亮度分量。max_val为亮度/色度分量的最大值255(假设为8bit yuv)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i)</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</div><div class="line">      input[i * in_stride + j] = (<span class="keyword">float</span>)dgd[c][i * stride + j] / max_val;</div></pre></td></tr></table></figure>
<p>输出是这几个变量partition_none_allowed，partition_horz_allowed，partition_vert_allowed，do_rectangular_split，do_square_split。用来对后续的partition的划分进行优化，从变量的名称可以看到这些变量会对后续的partition划分进行限制，也就是减少了partition的数目。</p>
<p>推理采用的网络是CNN + DNN的结合。<br>CNN是5层网络结构，网络定义如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> CNN_CONFIG av1_intra_mode_cnn_partition_cnn_config = &#123;</div><div class="line">    NUM_CNN_LAYERS,  <span class="comment">// num_layers</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// is_residue</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// ext_width</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// ext_height</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// strict_bounds</span></div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_0_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_0_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_0_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_0_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_0_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_0_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_0_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_0_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">-1</span>,                <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_1_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_1_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_1_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_1_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_1_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_1_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_1_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_1_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">3</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_2_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_2_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_2_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_2_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_2_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_2_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_2_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_2_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">2</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_3_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_3_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_3_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_3_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_3_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_3_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_3_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_3_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">1</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_4_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_4_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_4_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_4_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_4_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_4_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_4_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_4_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">0</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>DNN是两层网络结构，网络定义如下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> NN_CONFIG av1_intra_mode_cnn_partition_branch_0_dnn_config = &#123;</div><div class="line">    BRANCH_0_NUM_DNN_FEATURES,</div><div class="line">    BRANCH_0_NUM_LOGITS,</div><div class="line">    BRANCH_0_NUM_DNN_LAYERS,</div><div class="line">    &#123;</div><div class="line">        BRANCH_0_NUM_DNN_LAYER_0_UNITS,</div><div class="line">        BRANCH_0_NUM_DNN_LAYER_1_UNITS,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_0_kernel,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_1_kernel,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_logits_kernel,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_0_bias,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_1_bias,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_logits_bias,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="0x3-推理模型的训练"><a href="#0x3-推理模型的训练" class="headerlink" title="0x3 推理模型的训练"></a>0x3 推理模型的训练</h1><p>以上编码过程中采用的CNN + DNN的网络是经过训练的，在libaom的代码中并没有提供这个网络结构的训练过程代码。参考<a href="https://zhuanlan.zhihu.com/p/40034222" target="_blank" rel="external">HEVC partition优化</a>可以大体知道其训练过程。应该是设计好网络以后，通过大量样本数据来训练得到该推理网络的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/Buffer sharing in Weston/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/Buffer sharing in Weston/" itemprop="url">Buffer sharing in Weston</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T19:30:00+09:00">
                2019-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/30/Buffer sharing in Weston/" class="leancloud_visitors" data-flag-title="Buffer sharing in Weston">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Weston简介"><a href="#0x1-Weston简介" class="headerlink" title="0x1 Weston简介"></a>0x1 Weston简介</h1><h2 id="0x11-X系统"><a href="#0x11-X系统" class="headerlink" title="0x11 X系统"></a>0x11 X系统</h2><p>X即X11、X Window System，是用于在类UNIX的操作系统上的位图显示的窗口系统，提供了GUI环境的基本框架，可以在显示设备上绘制、移动窗口，通过鼠标、键盘、触摸屏与用户交互. X Server是X显示服务的一种开源实现，其系统结构如下图所示<br><img src="/2019/03/30/Buffer sharing in Weston/x-architecture.png" alt=""></p>
<h2 id="0x12-Wayland系统"><a href="#0x12-Wayland系统" class="headerlink" title="0x12 Wayland系统"></a>0x12 Wayland系统</h2><p>Wayland是一个显示服务协议，服务端为Wayland Compositor，服务端把把X系统中的X Server和Compositor合二为一，作为类Unix操作系统上更现代、简洁的窗口系统，旨在替换X系统。Weston是Wayland Compositor的参考实现。下面是Wayland官网文档给出的架构简图.<br><img src="/2019/03/30/Buffer sharing in Weston/wayland-architecture.png" alt=""></p>
<p>Wayland协议为Client/Server模式，客户端为图形应用程序，发送绘制命令，请求在各自输出缓冲区的显示，服务器为Compositor，控制各个客户端输出缓冲区的合成和显示。</p>
<p>Wayland参考实现Weston包括两层协议。</p>
<p>一个为底层IPC协议。采用Linux Domain Socket实现的IPC，这部分采用手动写的C语言实现。</p>
<p>另一个是上层消息协议。这部分采用libffi来实现，从规定格式的XML文件中自动生成，可以灵活地动态扩展或者用于错误验证。处理客户端和Weston之间的上层交互流程，以实现窗口系统的基本功能。</p>
<p>Wayland参考实现包括两部分，libwayland-client和libwayland-server，其架构简图如下所示。<br><img src="/2019/03/30/Buffer sharing in Weston/Wayland_protocol_architecture.svg" alt=""></p>
<h1 id="0x2-Buffer管理"><a href="#0x2-Buffer管理" class="headerlink" title="0x2 Buffer管理"></a>0x2 Buffer管理</h1><p>在Weston的实现中，客户端先把内容绘制到一个buffer中，然后weston把多个客户端绘制的buffer通过compositor模块合成在一起。这里面涉及到buffer在各个模块之间的传递，从性能的角度考虑，我们很自然地想到如何避免memory copy的问题。下来我们来看一下如何实现zero memory copy的。</p>
<p>Weston中的buffer用wl_buffer对象来描述。这个buffer需要在客户端和Compositor之间共享。目前有两种buffer的管理模式。</p>
<ol>
<li>wl_shm<br>这种方式是通过共享内存的方式来实现客户端和Compositor之间的共享，通过这种方式分配的内存是物理不连续的，这种方式一般用于采用软件绘制的情况，当buffer在客户端绘制完成以后，Compositor得到通知开始合成的时候，需要通过glTexImage2D()函数把buffer作为纹理上传到GPU中，这样的话性能是会受到影响的，因为纹理上传一般是比较耗时的操作。</li>
<li><p>wl_drm<br>这种方式通过Wayland EGL中的相关机制来保证，客户端通过wayland-egl.h的相关接口EGLSurface来创建GPU的输出buffer，然后客户端开始绘制，绘制完成以后，客户端的GPU输出buffer通过eglCreateImageKHR()接口创建EGLImage，这个EGLImage可以直接作为Compositor的输入纹理来使用，不需要额外的拷贝工作。</p>
<p>开源的mesa drm实现定义了drm Wayland扩展, 这个时候客户端和Compositor之间可以共享drm (GEM) buffers。</p>
<p>下面介绍一下基于KMS BO buffer type的mesa wl_drm共享流程<br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_1.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_2.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_3.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_4.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_5.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_6.png" alt=""></p>
</li>
</ol>
<h1 id="0x3-与Android上图形系统的比较"><a href="#0x3-与Android上图形系统的比较" class="headerlink" title="0x3 与Android上图形系统的比较"></a>0x3 与Android上图形系统的比较</h1><ol>
<li><p>Buffer的分配<br>Android上的buffer是在服务端（SurfaceFlinger）分配的，然后通过ION机制实现buffer的共享。<br>而Wayland系统中buffer是在客户端分配的，通过底层EGL驱动提供的buffer共享管理机制，再配合IPC机制实现客户端和服务端之间的buffer共享。</p>
</li>
<li><p>Window管理器的实现<br>Android上有单独的WMS(Window Manager Service)模块来做窗口管理的工作。而Wayland系统中在Weston中实现了窗口管理的工作，也就是是窗口管理和合成是在同一个进程中完成的。</p>
</li>
<li><p>Android on Wayland<br>把Android上的SurfaceFlinger作为一个Wayland Client，然后参与Weston的合成。架构图如下<br><img src="/2019/03/30/Buffer sharing in Weston/AndroidOnWayland.png" alt=""></p>
<p>上图的架构有点类似于把X Server作为一个Wayland Client，如下图所示<br><img src="/2019/03/30/Buffer sharing in Weston/xwayland.png" alt=""></p>
</li>
</ol>
<h1 id="0x4-Run-Weston-on-Ubuntu"><a href="#0x4-Run-Weston-on-Ubuntu" class="headerlink" title="0x4 Run Weston on Ubuntu"></a>0x4 Run Weston on Ubuntu</h1><p>   把Wayland protocol和Weston相关实现porting到Ubuntu上，Weston加载X11-backend，也就是说Weston作为X Server的一个Client，把Weston的合成输出在接入到Ubuntu的X Server系统中来输出。</p>
<p>   绘制和合成流程如下图所示<br>   <img src="/2019/03/30/Buffer sharing in Weston/Draw &amp; Composition.png" alt=""></p>
<p>   测试效果如下图所示<br>   <img src="/2019/03/30/Buffer sharing in Weston/demo.png" alt=""></p>
<h1 id="0x5-参考"><a href="#0x5-参考" class="headerlink" title="0x5 参考"></a>0x5 参考</h1><p><a href="https://wayland.freedesktop.org/architecture.html" target="_blank" rel="external">Wayland architecture</a><br><a href="https://events.static.linuxfound.org/sites/events/files/slides/als2015_wayland_weston_v2.pdf" target="_blank" rel="external">Wayland/Weston Renderer</a><br><a href="https://at.projects.genivi.org/wiki/display/DIRO/Android+display+subsystem+as+a+wayland+client" target="_blank" rel="external">Android display subsystem as a wayland client</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/23/How escher support physically based render/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/How escher support physically based render/" itemprop="url">How escher support physically based render</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-23T12:00:00+09:00">
                2019-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/23/How escher support physically based render/" class="leancloud_visitors" data-flag-title="How escher support physically based render">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-物理渲染和光栅化渲染"><a href="#0x1-物理渲染和光栅化渲染" class="headerlink" title="0x1 物理渲染和光栅化渲染"></a>0x1 物理渲染和光栅化渲染</h1><h2 id="0x21-传统光栅化渲染器的特点"><a href="#0x21-传统光栅化渲染器的特点" class="headerlink" title="0x21 传统光栅化渲染器的特点"></a>0x21 传统光栅化渲染器的特点</h2><p>光栅化是指把3D空间的几何图形及其色彩信息转换至2D计算机屏幕上像素的过程。光栅化渲染器的pipeline包括Vertex Shader,Rasterization,Fragment Shader等阶段，目前GPU硬件也是采用这种高效率的光栅化架构。基于这些GPU硬件设计的渲染API有Windows上的DirectX,跨平台的OpenGL和Vulkan，已经Apple的Metal等。应用程序可以基于这些渲染API开发出酷炫的3D效果。但是这种光栅化的缺点也很明显，那就是无法完全模拟真实场景下的光线传播，导致绘制效果失真。</p>
<p>下图说明了光栅化渲染器的流水线。</p>
<p><img src="/2019/03/23/How escher support physically based render/pipeline.png" alt=""></p>
<p>现代GPU中vertex shader和fragment shader一般是逻辑的概念，当时比较早的GPU是采用两种独立的硬件单元(不是Unified Shader)来实现的，如ARM Mali-400就是这种架构，这种架构的缺点是vertex shader和fragment shader的负载没办法平衡，极端情况下会出现其中一种硬件Shader满负荷运行，另外一种硬件Shader空闲的情况。后来的架构一般是基于通用可编程计算单元实现这些功能。也就是我们常说的Unified Shader架构。如树莓派中的Soc VideoCore采用了BroadCom V3D GPU, 其中的Unified Shader中采用QPU这种通用可编程计算单元来实现。</p>
<p>移动GPU相对桌面GPU的架构也有差别，因为移动平台上对带宽及功耗的要求都比较高。<br>桌面GPU一般采用IMR(Immediate Mode Rendering)架构, 这种架构需要同时对该次渲染的全部物体进行处理，需要频繁访问系统帧缓存（位于系统内存里），故对带宽要求较高。</p>
<p>移动GPU一般采用TBR架构(Tile Based Rendering)。TBR架构包括两个阶段Tiling和Binning。Tiling阶段把整个画面分成小块，然后计算每个小块中有哪些三角形需要处理。Binning阶段每次只对一个小块中包括的三角形进行处理，这种方式避免了对帧缓存（位于系统内存里）的频繁读写和修改，因为这些小块中的三角形的渲染是在GPU上的高速缓存里进行，所以能节约带宽，同时也减少了功耗。</p>
<p>Imagination在TBR架构的基础上又提出了TBDR(Tile Based Deferred Rendering), 在执行shading之前加入HSR(Hidded Surface Remove), 这个模块利用vertex shader/rasterization之后的fragment的深度值来优化掉不必要的计算。</p>
<h2 id="0x22-物理渲染器的特点"><a href="#0x22-物理渲染器的特点" class="headerlink" title="0x22 物理渲染器的特点"></a>0x22 物理渲染器的特点</h2><p>物理渲染器PBR(Physically Based Rendering),也称光线跟踪器(Ray tracer)。采用该算法渲染的结果看起来更真实，因为它基于物理参数的方法来编写材质，而且考虑了光线的发射和折射，材质对光线的吸收等。</p>
<p>光线跟踪算法描述如下，沿着到达视点的光线的反方向跟踪，经过屏幕上每一个象素，找出与视线相交的物体表面点，并继续跟踪，找出影响点光强的所有光源，从而算出点上精确的光线强度。这种算法计算量极大，一般用于离线渲染。</p>
<p>一个典型的物理渲染器包括如下模块。<br>相机<br>光线-对象相交测试<br>光照分布/光线传播<br>递归光线跟踪机制</p>
<p>考虑到PBR的计算量太大，只适合离线渲染，后来基于全局光照Global Illuslaton技术的来实现实时PBR，因为考虑到了速度的提升，在渲染质量上会有损失。</p>
<p>早期Ray tracing的硬件有德国萨尔兰大学计算机图形小组在2005年的SIGGRAPH上展示了第一个实时光线追踪加速硬件——RPU（Ray Processing Unit），最近有NVIDIA在GPU硬件中加入了Ray tracing。</p>
<p>下图是采用Blender中的cycles物理渲染器渲染的坦克效果图，如果完全用CPU来计算，速度很慢，大概需要几十分钟。<br><img src="/2019/03/23/How escher support physically based render/tank.png" alt=""></p>
<h1 id="0x2-Escher是如何做到物理渲染的？"><a href="#0x2-Escher是如何做到物理渲染的？" class="headerlink" title="0x2 Escher是如何做到物理渲染的？"></a>0x2 Escher是如何做到物理渲染的？</h1><p>Escher是Google下一代操作系统Fuchsia上内置的基于物理的真实感渲染引擎，它和Scenic一起提供了Fuchsia上的合成及进一步特效处理功能。</p>
<p>Escher目前看来主要采用光照和阴影技术来达到物理渲染的效果。</p>
<p>阴影是真实感渲染的一个重要组成部分，它对增加渲染物体的表面细节，帮助观察者增加对场景的空间感，从而更好地来判断物体的位置关系以及形状等有很大的帮助。可以说没有了阴影，3D场景中的真实感和吸引力将降低。</p>
<p>Escher中包括了如下几种阴影技术，ShadowMap、ShadowVolume等。</p>
<p>从Escher的实现代码可知，Escher还只是实现了部分物理渲染的功能，主要是通过light和shadow来体现真实感效果，后续要支持AR/VR中更多酷炫效果的话，需要进一步开发。</p>
<h1 id="0x03-展望"><a href="#0x03-展望" class="headerlink" title="0x03 展望"></a>0x03 展望</h1><p>随着GPU硬件中增加了Ray tracing的功能，主流API都增加了对Ray tracing的支持，未来Escher中可能会直接调用这些API(目前Escher中是调用了Vulkan，也就是说会调用Vulkan的Ray tracing支持)来加速Ray tracing的处理。</p>
<p>下来介绍一种主流API对 ray tracing的支持</p>
<h2 id="0x31-Directx-raytracing"><a href="#0x31-Directx-raytracing" class="headerlink" title="0x31 Directx raytracing"></a>0x31 Directx raytracing</h2><p>DirectX Raytracing在DirectX 12 API的基础上引入了下面这些概念<br><a href="https://devblogs.microsoft.com/directx/announcing-microsoft-directx-raytracing/" target="_blank" rel="external">DirectX Raytracing</a></p>
<p>What is DirectX Raytracing?<br>At the highest level, DirectX Raytracing (DXR) introduces four, new concepts to the DirectX 12 API:</p>
<p>The acceleration structure is an object that represents a full 3D environment in a format optimal for traversal by the GPU.  Represented as a two-level hierarchy, the structure affords both optimized ray traversal by the GPU, as well as efficient modification by the application for dynamic objects.</p>
<p>A new command list method, DispatchRays, which is the starting point for tracing rays into the scene.  This is how the game actually submits DXR workloads to the GPU.</p>
<p>A set of new HLSL shader types including ray-generation, closest-hit, any-hit, and miss shaders.  These specify what the DXR workload actually does computationally.  When DispatchRays is called, the ray-generation shader runs.  Using the new TraceRay intrinsic function in HLSL, the ray generation shader causes rays to be traced into the scene.  Depending on where the ray goes in the scene, one of several hit or miss shaders may be invoked at the point of intersection.  This allows a game to assign each object its own set of shaders and textures, resulting in a unique material.</p>
<p>The raytracing pipeline state, a companion in spirit to today’s Graphics and Compute pipeline state objects, encapsulates the raytracing shaders and other state relevant to raytracing workloads.</p>
<h2 id="0x32-Vulkan-ray-tracing"><a href="#0x32-Vulkan-ray-tracing" class="headerlink" title="0x32 Vulkan ray tracing"></a>0x32 Vulkan ray tracing</h2><p>NVIDIA提供了Vulkan的扩展了支持ray tracing。<br><a href="https://devblogs.nvidia.com/vulkan-raytracing/" target="_blank" rel="external">Vulkan ray tracing</a></p>
<h2 id="0x33-Metal-ray-tracing"><a href="#0x33-Metal-ray-tracing" class="headerlink" title="0x33 Metal ray tracing"></a>0x33 Metal ray tracing</h2><p>Metal提供了ray tracing的支持。<br><img src="/2019/03/23/How escher support physically based render/metal_ray_tracing.png" alt=""></p>
<p>详细信息请参考<br><a href="https://developer.apple.com/videos/play/wwdc2018/606/" target="_blank" rel="external">Metal ray tracing</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/16/AV1-syntax-explanation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/AV1-syntax-explanation/" itemprop="url">AV1-syntax-explanation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T17:00:10+09:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/16/AV1-syntax-explanation/" class="leancloud_visitors" data-flag-title="AV1-syntax-explanation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-解码流程介绍"><a href="#0x1-解码流程介绍" class="headerlink" title="0x1 解码流程介绍"></a>0x1 解码流程介绍</h1><p><img src="/2019/03/16/AV1-syntax-explanation/av1 syntax description.png" alt=""><br>解码流程说明如下</p>
<h2 id="0x11-tile-group-obu"><a href="#0x11-tile-group-obu" class="headerlink" title="0x11 tile_group_obu"></a>0x11 tile_group_obu</h2><p>   对tile group的每个tile调用decode_tile()进行解码，直至tile group中包括的tile都解码完成.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( TileNum = tg_start; TileNum &lt;= tg_end; TileNum++ ) &#123;</div><div class="line">    tileRow = TileNum / TileCols</div><div class="line">    tileCol = TileNum % TileCols</div><div class="line">    ......</div><div class="line">    decode_tile( )</div><div class="line">    exit_symbol( )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x12-decode-tile"><a href="#0x12-decode-tile" class="headerlink" title="0x12 decode_tile"></a>0x12 decode_tile</h2><p>   对tile中包含的每个partition进行解码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( r = MiRowStart; r &lt; MiRowEnd; r += sbSize4 ) &#123;</div><div class="line">    <span class="keyword">for</span> ( c = MiColStart; c &lt; MiColEnd; c += sbSize4 ) &#123;</div><div class="line">        ......</div><div class="line">        decode_partition( r, c, sbSize )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x13-decode-partition"><a href="#0x13-decode-partition" class="headerlink" title="0x13 decode_partition"></a>0x13 decode_partition</h2><p>   每个partition的解码过程就是对一个super block(super block的定义参考0x2)进行解码的过程.<br>   根据partition类型对进一步split, 不能split的类型调用decode_block().</p>
<pre><code>partition类型的定义如下

| Partition index | Type of partition  |
|:-------:|:------------- |
| 0 |PARTITION_NONE|
| 1 |PARTITION_HORZ|
| 2 |PARTITION_VERT|
| 3 |PARTITION_SPLIT|
| 4 |PARTITION_HORZ_A|
| 5 |PARTITION_HORZ_B|
| 6 |PARTITION_VERT_A|
| 7 |PARTITION_VERT_B|
| 8 |PARTITION_HORZ_4|
| 9 |PARTITION_VERT_4|
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( partition == PARTITION_NONE ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line"><span class="keyword">if</span> ( hasRows )</div><div class="line">    decode_block( r + halfBlock4x4, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    <span class="keyword">if</span> ( hasCols )</div><div class="line">       decode_block( r, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_SPLIT ) &#123;</div><div class="line">    decode_partition( r, c, subSize )</div><div class="line">    decode_partition( r, c + halfBlock4x4, subSize )</div><div class="line">    decode_partition( r + halfBlock4x4, c, subSize )</div><div class="line">    decode_partition( r + halfBlock4x4, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_A ) &#123;</div><div class="line">    decode_block( r, c, splitSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_B ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c + halfBlock4x4, splitSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT_A ) &#123;</div><div class="line">    decode_block( r, c, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, splitSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT_B ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c + halfBlock4x4, splitSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_4 ) &#123;</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">0</span>, c, subSize )</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">1</span>, c, subSize )</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">2</span>, c, subSize )</div><div class="line">    <span class="keyword">if</span> ( r + quarterBlock4x4 * <span class="number">3</span> &lt; MiRows )</div><div class="line">        decode_block( r + quarterBlock4x4 * <span class="number">3</span>, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//PARTITION_VERT_4</span></div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">0</span>, subSize )</div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">1</span>, subSize )</div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">2</span>, subSize )</div><div class="line">    <span class="keyword">if</span> ( c + quarterBlock4x4 * <span class="number">3</span> &lt; MiCols )</div><div class="line">        decode_block( r, c + quarterBlock4x4 * <span class="number">3</span>, subSize )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x14-decode-block"><a href="#0x14-decode-block" class="headerlink" title="0x14 decode_block"></a>0x14 decode_block</h2><p>   对一个block进行解码，进一步调用residual对残差进行解码.</p>
<h2 id="0x15-transform-tree"><a href="#0x15-transform-tree" class="headerlink" title="0x15 transform_tree"></a>0x15 transform_tree</h2><p>   对不同size的transform块进行解码，它是一个递归函数，递归退出函数是transform_block.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">transform_tree( startX, startY, w, h ) &#123; Type</div><div class="line">    maxX = MiCols * MI_SIZE</div><div class="line">    maxY = MiRows * MI_SIZE</div><div class="line">    <span class="keyword">if</span> ( startX &gt;= maxX || startY &gt;= maxY ) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    row = startY &gt;&gt; MI_SIZE_LOG2</div><div class="line">    col = startX &gt;&gt; MI_SIZE_LOG2</div><div class="line">    lumaTxSz = InterTxSizes[ row ][ col ]</div><div class="line">    lumaW = Tx_Width[ lumaTxSz ]</div><div class="line">    lumaH = Tx_Height[ lumaTxSz ]</div><div class="line">    <span class="keyword">if</span> ( w &lt;= lumaW &amp;&amp; h &lt;= lumaH ) &#123;</div><div class="line">        txSz = find_tx_size( w, h )</div><div class="line">        transform_block( <span class="number">0</span>, startX, startY, txSz, <span class="number">0</span>, <span class="number">0</span> )</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ( w &gt; h ) &#123;</div><div class="line">            transform_tree( startX, startY, w/<span class="number">2</span>, h )</div><div class="line">            transform_tree( startX + w / <span class="number">2</span>, startY, w/<span class="number">2</span>, h )</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( w &lt; h ) &#123;</div><div class="line">            transform_tree( startX, startY, w, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX, startY + h/<span class="number">2</span>, w, h/<span class="number">2</span> )</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            transform_tree( startX, startY, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX + w/<span class="number">2</span>, startY, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX, startY + h/<span class="number">2</span>, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX + w/<span class="number">2</span>, startY + h/<span class="number">2</span>, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x16-Reconstruct中包括具体的反量化，反dct-重建像素和loop-filter等过程"><a href="#0x16-Reconstruct中包括具体的反量化，反dct-重建像素和loop-filter等过程" class="headerlink" title="0x16 Reconstruct中包括具体的反量化，反dct,重建像素和loop filter等过程."></a>0x16 Reconstruct中包括具体的反量化，反dct,重建像素和loop filter等过程.</h2><h1 id="0x2-super-block"><a href="#0x2-super-block" class="headerlink" title="0x2 super block"></a>0x2 super block</h1><p>下图说明了一个frame由许多super block组成，super block的定义稍后说明.<br><img src="/2019/03/16/AV1-syntax-explanation/super_block.png" alt=""></p>
<p>Super block的定义如下<br>The top level of the block quadtree within a tile. All superblocks within a frame are the same size and are square. The<br>superblocks may be 128x128 luma samples or 64x64 luma samples. A superblock may contain 1 or 2 or 4 mode info<br>blocks, or may be bisected in each direction to create 4 sub-blocks, which may themselves be further subpartitioned,<br>forming the block quadtree.</p>
<p>通过在sequence_header_obu中的use_128x128_superblock来控制superblock的大小是128x128还是64x64.<br>sequence_header_obu( ) {<br>    ……<br>    use_128x128_superblock f(1)<br>    ……<br>}</p>
<p>use_128x128_superblock的定义如下<br>when equal to 1, indicates that superblocks contain 128x128 luma samples. When equal to 0,<br>it indicates that superblocks contain 64x64 luma samples.</p>
<h1 id="0x3-split划分"><a href="#0x3-split划分" class="headerlink" title="0x3 split划分"></a>0x3 split划分</h1><p>下图显示了super block(64x64)的split状态, 从图中可以看到，64x64的block会被split到32x32，再进一步split到16x16.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/split_.png" alt=""></p>
<h1 id="0x4-Intra-Y-mode"><a href="#0x4-Intra-Y-mode" class="headerlink" title="0x4 Intra Y mode"></a>0x4 Intra Y mode</h1><p>下图显示了Intra Prediction中Y分量的mode，不同的颜色代码不同的mode.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/mode.png" alt=""></p>
<h1 id="0x5-Intra-UV-mode"><a href="#0x5-Intra-UV-mode" class="headerlink" title="0x5 Intra UV mode"></a>0x5 Intra UV mode</h1><p>下图显示了Intra Prediction中UV分量的mode，不同的颜色代码不同的mode，其中显示数字的块表示该mode为chroma from luma prediction, 其中显示的数字表示chroma需要从哪个位置的luma预测.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/uv_mode.png" alt=""></p>
<h1 id="0x6-Motion-vector"><a href="#0x6-Motion-vector" class="headerlink" title="0x6 Motion vector"></a>0x6 Motion vector</h1><p>下图显示了Inter frame帧间预测的运动向量.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/motion_vector.png" alt=""></p>
<h1 id="0x7-Reference"><a href="#0x7-Reference" class="headerlink" title="0x7 Reference"></a>0x7 Reference</h1><p><a href="https://people.xiph.org/~mbebenita/analyzer/" target="_blank" rel="external">AV1 analyzer</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/Synchronization-in-Vulkan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/Synchronization-in-Vulkan/" itemprop="url">Synchronization-in-Vulkan</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T17:00:10+09:00">
                2019-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/09/Synchronization-in-Vulkan/" class="leancloud_visitors" data-flag-title="Synchronization-in-Vulkan">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Overview"><a href="#0x1-Overview" class="headerlink" title="0x1 Overview"></a>0x1 Overview</h1><p>Vulkan的一大优势是能通过多线程来提升CPU bounding场景的performance，这依赖于其提供了下面几种同步机制。</p>
<p>Semaphores，用于多个queue之间的同步或者是一个queue的任务提交同步。<br>Events，用于一个command buffer内部的同步或在同一个queue内部多个command buffer的同步。<br>Fences，用于提供devive和host之间的同步。<br>barriers，用于精确控制pipeline中各个pipeline阶段的资源流动。<br>下图说明了这几种同步机制适用的场景。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/sync_types.png" alt=""></p>
<h1 id="0x2-Details"><a href="#0x2-Details" class="headerlink" title="0x2 Details"></a>0x2 Details</h1><h2 id="0x21-Pipeline-Barrier"><a href="#0x21-Pipeline-Barrier" class="headerlink" title="0x21 Pipeline Barrier"></a>0x21 Pipeline Barrier</h2><p>Barrier是一种同步机制，用来管理内存访问和同步Vulkan pipeline中各个阶段里的资源状态变化。通过这种机制来fine-grained控制command buffer执行过程中资源在pipeline的各个阶段中的流动。</p>
<p>Vulkan通过API vkCmdPipelineBarrier()来控制三种barrier操作，Memory barrier, Buffer Memory barrier和Image Memory barrier。</p>
<p>其中Memory barrier, Buffer Memory barrier会控制资源在pipeline各个阶段的执行次序。其作用有两个，<br>一个作用是控制执行顺序，对写后读(WaR)，读后写(RaW)，写后写(WaW)三种情况提供保护。另外一个作用是保证pipeline不同部分中数据的视图的一致性，因为pipeline不同stage之间可能有cache，在插入了barrier的地方需要flush cache。<br>Image Memory barrier的作用是控制对图像的访问。</p>
<p>三种barrier的数据结构如下所示<br><img src="/2019/03/09/Synchronization-in-Vulkan/pipelinebarrier.png" alt=""></p>
<p>Vulkan的pipeline包括下面这几种,Command的执行从top开始，然后执行类似VS，FS之类的pipeline，最后是bottom。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">TOP_OF_PIPE_BIT</div><div class="line">DRAW_INDIRECT_BIT</div><div class="line">VERTEX_INPUT_BIT</div><div class="line">VERTEX_SHADER_BIT</div><div class="line">TESSELLATION_CONTROL_SHADER_BIT</div><div class="line">TESSELLATION_EVALUATION_SHADER_BIT</div><div class="line">GEOMETRY_SHADER_BIT</div><div class="line">FRAGMENT_SHADER_BIT</div><div class="line">EARLY_FRAGMENT_TESTS_BIT</div><div class="line">LATE_FRAGMENT_TESTS_BIT</div><div class="line">COLOR_ATTACHMENT_OUTPUT_BIT</div><div class="line">TRANSFER_BIT</div><div class="line">COMPUTE_SHADER_BIT</div><div class="line">BOTTOM_OF_PIPE_BIT</div></pre></td></tr></table></figure>
<p>但是如何设置vkCmdPipelineBarrier中source stage和dest stage呢？ </p>
<p>最简单的方式是把source stage设置为VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT，dest stage设置为VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT。<br>这种设置会等待前面command buffer的所有pipeline都执行结束了，后面command buffer才能开始，很明显这种设置多个command buffer没有并行执行，command buffer之间只是串行的，performance应该会受到影响。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/slow-barrier.png" alt=""></p>
<p>如果希望能在多个command buffer之间并行执行，需要根据实际情况设置source stage和dest stage。</p>
<p>假如vertex shader后面接了一个compute shader, compute shader执行的时候需要读取vertex shader的执行结果，<br>我们可以把source stage设置为VK_PIPELINE_STAGE_VERTEX_SHADER_BIT，dest stage设置为VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT。<br>更详细的介绍，请参考后面的代码说明。</p>
<p>原则上source stage和dest stage的设置应该尽量使下图中的ubblocked pipeline(green stages)尽可能地多，这样并行度会越高。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/good-barrier.png" alt=""></p>
<p>Memory barrier示例代码</p>
<p>根据需要，创建两个queue(graphics queue和compute queue)和对应的command buffer.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建graphics queue和command pool</span></div><div class="line">vkGetDeviceQueue(device, vulkanDevice-&gt;queueFamilyIndices.graphics, <span class="number">0</span>, &amp;<span class="built_in">queue</span>);</div><div class="line"></div><div class="line">VkCommandPoolCreateInfo cmdPoolInfo = &#123;&#125;;</div><div class="line">cmdPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</div><div class="line">cmdPoolInfo.queueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics;</div><div class="line">cmdPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</div><div class="line">VK_CHECK_RESULT(vkCreateCommandPool(device, &amp;cmdPoolInfo, <span class="literal">nullptr</span>, &amp;cmdPool));</div><div class="line"></div><div class="line"><span class="comment">// 创建compute queue和command pool</span></div><div class="line">vkGetDeviceQueue(device, vulkanDevice-&gt;queueFamilyIndices.compute, <span class="number">0</span>, &amp;compute.<span class="built_in">queue</span>);</div><div class="line">VkCommandPoolCreateInfo cmdPoolInfo = &#123;&#125;;</div><div class="line">cmdPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</div><div class="line">cmdPoolInfo.queueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute;</div><div class="line">cmdPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</div><div class="line">VK_CHECK_RESULT(vkCreateCommandPool(device, &amp;cmdPoolInfo, <span class="literal">nullptr</span>, &amp;compute.commandPool));</div></pre></td></tr></table></figure></p>
<p>下面的代码说明了如何在这两个command buffer执行的过程中插入barrier, 从而实现资源访问的控制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildComputeCommandBuffer</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	VkCommandBufferBeginInfo cmdBufInfo = vks::initializers::commandBufferBeginInfo();</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkBeginCommandBuffer(compute.commandBuffer, &amp;cmdBufInfo));</div><div class="line"></div><div class="line">	<span class="comment">// Compute particle movement</span></div><div class="line"></div><div class="line">	<span class="comment">// Add memory barrier to ensure that the (graphics) vertex shader has fetched attributes before compute starts to write to the buffer</span></div><div class="line">	VkBufferMemoryBarrier bufferBarrier = vks::initializers::bufferMemoryBarrier();</div><div class="line">	bufferBarrier.buffer = compute.storageBuffer.buffer;</div><div class="line">	bufferBarrier.size = compute.storageBuffer.descriptor.range;</div><div class="line">	bufferBarrier.srcAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;	<span class="comment">// Vertex shader invocations have finished reading from the buffer</span></div><div class="line">	bufferBarrier.dstAccessMask = VK_ACCESS_SHADER_WRITE_BIT; <span class="comment">// Compute shader wants to write to the buffer</span></div><div class="line">	<span class="comment">// Compute and graphics queue may have different queue families (see VulkanDevice::createLogicalDevice)</span></div><div class="line">	<span class="comment">// For the barrier to work across different queues, we need to set their family indices</span></div><div class="line">	bufferBarrier.srcQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics; <span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line">	bufferBarrier.dstQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute; <span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line"></div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		compute.commandBuffer,</div><div class="line">		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;bufferBarrier,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">	vkCmdBindPipeline(compute.commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline);</div><div class="line">	vkCmdBindDescriptorSets(compute.commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;compute.descriptorSet, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Dispatch the compute job</span></div><div class="line">	vkCmdDispatch(compute.commandBuffer, PARTICLE_COUNT / <span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Add memory barrier to ensure that compute shader has finished writing to the buffer</span></div><div class="line">	<span class="comment">// Without this the (rendering) vertex shader may display incomplete results (partial data from last frame) </span></div><div class="line">	bufferBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;  <span class="comment">// Compute shader has finished writes to the buffer</span></div><div class="line">	bufferBarrier.dstAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;	<span class="comment">// Vertex shader invocations want to read from the buffer</span></div><div class="line">	bufferBarrier.buffer = compute.storageBuffer.buffer;</div><div class="line">	bufferBarrier.size = compute.storageBuffer.descriptor.range;</div><div class="line">	<span class="comment">// Compute and graphics queue may have different queue families (see VulkanDevice::createLogicalDevice)</span></div><div class="line">	<span class="comment">// For the barrier to work across different queues, we need to set their family indices</span></div><div class="line">	bufferBarrier.srcQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute;	<span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line">	bufferBarrier.dstQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics;	<span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line"></div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		compute.commandBuffer,</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;bufferBarrier,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">	vkEndCommandBuffer(compute.commandBuffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Image barrier示例代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; drawCmdBuffers.size(); ++i)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// Set target frame buffer</span></div><div class="line">	renderPassBeginInfo.framebuffer = frameBuffers[i];</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkBeginCommandBuffer(drawCmdBuffers[i], &amp;cmdBufInfo));</div><div class="line"></div><div class="line">	<span class="comment">// Image memory barrier to make sure that compute shader writes are finished before sampling from the texture</span></div><div class="line">	VkImageMemoryBarrier imageMemoryBarrier = &#123;&#125;;</div><div class="line">	imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;</div><div class="line">	<span class="comment">// We won't be changing the layout of the image</span></div><div class="line">	imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_GENERAL;</div><div class="line">	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_GENERAL;</div><div class="line">	imageMemoryBarrier.image = textureComputeTarget.image;</div><div class="line">	imageMemoryBarrier.subresourceRange = &#123; VK_IMAGE_ASPECT_COLOR_BIT, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</div><div class="line">	imageMemoryBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;</div><div class="line">	imageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;</div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		drawCmdBuffers[i],</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;imageMemoryBarrier);</div><div class="line">	vkCmdBeginRenderPass(drawCmdBuffers[i], &amp;renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);</div><div class="line"></div><div class="line">	VkViewport viewport = vks::initializers::viewport((<span class="keyword">float</span>)width * <span class="number">0.5f</span>, (<span class="keyword">float</span>)height, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">	vkCmdSetViewport(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;viewport);</div><div class="line"></div><div class="line">	VkRect2D scissor = vks::initializers::rect2D(width, height, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">	vkCmdSetScissor(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;scissor);</div><div class="line"></div><div class="line">	VkDeviceSize offsets[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">	vkCmdBindVertexBuffers(drawCmdBuffers[i], VERTEX_BUFFER_BIND_ID, <span class="number">1</span>, &amp;vertexBuffer.buffer, offsets);</div><div class="line">	vkCmdBindIndexBuffer(drawCmdBuffers[i], indexBuffer.buffer, <span class="number">0</span>, VK_INDEX_TYPE_UINT32);</div><div class="line"></div><div class="line">	<span class="comment">// Left (pre compute)</span></div><div class="line">	vkCmdBindDescriptorSets(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;graphics.descriptorSetPreCompute, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	vkCmdBindPipeline(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline);</div><div class="line"></div><div class="line">	vkCmdDrawIndexed(drawCmdBuffers[i], indexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Right (post compute)</span></div><div class="line">	vkCmdBindDescriptorSets(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;graphics.descriptorSetPostCompute, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	vkCmdBindPipeline(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline);</div><div class="line"></div><div class="line">	viewport.x = (<span class="keyword">float</span>)width / <span class="number">2.0f</span>;</div><div class="line">	vkCmdSetViewport(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;viewport);</div><div class="line">	vkCmdDrawIndexed(drawCmdBuffers[i], indexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	vkCmdEndRenderPass(drawCmdBuffers[i]);</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkEndCommandBuffer(drawCmdBuffers[i]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x22-Semaphore-Event-Fence"><a href="#0x22-Semaphore-Event-Fence" class="headerlink" title="0x22 Semaphore/Event/Fence"></a>0x22 Semaphore/Event/Fence</h2><p>下面说明并行渲染多帧时采用的同步机制。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/frame_sync.png" alt=""></p>
<p>如上图所示，当swap chain中的image可用时，vkAcquireNextImageKHR会触发一个semaphore a，vkQueueSubmit拿到这个semaphore b以后开始执行command buffer的命令，执行command buffer的过程中会往vkAcquireNextImageKHR得到的image(这个image类似于frame buffer的概念)中写内容，执行完毕以后会触发semaphore b, vkQueuePresentKHR等待这个semaphore b触发以后就把image的内容绘制到display上。<br>当第N frame在Submit任务到GPU上执行的时候， (N+1)frame同时在CPU上开启多线程往多个command buffer中生成command，这样CPU和GPU相互配合，提升performance。</p>
<p>下面说明渲染一帧时内部采用的同步机制。<br><img src="/2019/03/09/Synchronization-in-Vulkan/sync-example.png" alt=""></p>
<p>上图中第一个vkQueueSubmit的参数如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</div><div class="line">   <span class="comment">// 执行vkQueueSubmit的wait semaphore，等待其触发，其已经在vkAcquireNextImageKHR中触发</span></div><div class="line">submitInfo.pWaitSemaphores = &amp;semaphores.presentComplete;</div><div class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</div><div class="line">   <span class="comment">// vkQueueSubmit执行完以后的signal semaphore</span></div><div class="line">submitInfo.pSignalSemaphores = &amp;semaphores.renderComplete;</div><div class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</div><div class="line">submitInfo.pCommandBuffers = &amp;primaryCommandBuffer;</div><div class="line"></div><div class="line">VK_CHECK_RESULT(vkQueueSubmit(<span class="built_in">queue</span>, <span class="number">1</span>, &amp;submitInfo, renderFence));</div></pre></td></tr></table></figure></p>
<p>然后执行vKQueuePresentKHR，这边的wait semaphore是前面一步的renderComplete, 表明只有renderComplete被触发以后vKQueuePresentKHR才能被执行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VK_CHECK_RESULT(swapChain.queuePresent(<span class="built_in">queue</span>, currentBuffer, submitTextOverlay ? semaphores.textOverlayComplete : semaphores.renderComplete));</div></pre></td></tr></table></figure></p>
<p>上面虚线部分表明在执行vKQueuePresentKHR之间，还有一个text overlay command buffer需要执行。<br>这个command buffer的wait semaphore为renderComplete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set semaphores</span></div><div class="line"><span class="comment">// Wait for render complete semaphore</span></div><div class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</div><div class="line">submitInfo.pWaitSemaphores = &amp;semaphores.renderComplete;</div><div class="line"><span class="comment">// Signal ready with text overlay complete semaphpre</span></div><div class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</div><div class="line">submitInfo.pSignalSemaphores = &amp;semaphores.textOverlayComplete;</div><div class="line"></div><div class="line"><span class="comment">// Submit current text overlay command buffer</span></div><div class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</div><div class="line">submitInfo.pCommandBuffers = &amp;textOverlay-&gt;cmdBuffers[currentBuffer];</div><div class="line">VK_CHECK_RESULT(vkQueueSubmit(<span class="built_in">queue</span>, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE));</div></pre></td></tr></table></figure>
<h1 id="0x3-References"><a href="#0x3-References" class="headerlink" title="0x3 References"></a>0x3 References</h1><p><a href="https://gpuopen.com/vulkan-barriers-explained/" target="_blank" rel="external">Vulkan barriers explained</a><br><a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/multi-threading-in-vulkan" target="_blank" rel="external">Multi-Threading in Vulkan</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/The-overview-of-AV1-coding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/The-overview-of-AV1-coding/" itemprop="url">The overview of AV1 coding</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T20:00:10+09:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/02/The-overview-of-AV1-coding/" class="leancloud_visitors" data-flag-title="The overview of AV1 coding">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Overview"><a href="#0x1-Overview" class="headerlink" title="0x1 Overview"></a>0x1 Overview</h1><p>AOMedia Video 1 (AV1) is an open, royalty-free video coding format, it was in particular motivated by the high cost and uncertainty of HEVC patent licensing, it aims to provide royalty-free and high compression ratio video codec.</p>
<p>This blog will give us the overview of AV1 codec, this material is from the internet, you can find the link url in the reference part.</p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/The_Technology_Inside_Av1.svg" alt="ovewview"></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/codec_overview.png" alt="ovewview"></p>
<h1 id="0x2-Partition"><a href="#0x2-Partition" class="headerlink" title="0x2 Partition"></a>0x2 Partition</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/partition1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/partition2.png" alt=""></p>
<h1 id="0x3-Intra-Prediction"><a href="#0x3-Intra-Prediction" class="headerlink" title="0x3 Intra Prediction"></a>0x3 Intra Prediction</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/intra_preditction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/smooth_intra_prediction_modes.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/chroma_from_luma.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/palette_mode.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/intra_block_copying.png" alt=""></p>
<h1 id="0x04-Inter-Prediction"><a href="#0x04-Inter-Prediction" class="headerlink" title="0x04 Inter Prediction"></a>0x04 Inter Prediction</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/inter_prediction1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/inter_prediction2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/extended_reference_frames.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/motion_vector_prediction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/dynamic_motion_vector_referencing.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/obmc.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/masked_compound_prediction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/warped_mc.png" alt=""></p>
<h1 id="0x05-Transform-coding"><a href="#0x05-Transform-coding" class="headerlink" title="0x05 Transform coding"></a>0x05 Transform coding</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/transform1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform_kernel.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform_block_partitioning.png" alt=""></p>
<h1 id="0x06-Quantization"><a href="#0x06-Quantization" class="headerlink" title="0x06 Quantization"></a>0x06 Quantization</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/quantization.png" alt=""></p>
<h1 id="0x7-Entropy-coding"><a href="#0x7-Entropy-coding" class="headerlink" title="0x7 Entropy coding"></a>0x7 Entropy coding</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/entropy_coding1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/entropy_coding2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/av1_symbol_coding.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/level-map coefficient coding.png" alt=""></p>
<h1 id="0x8-Filter"><a href="#0x8-Filter" class="headerlink" title="0x8 Filter"></a>0x8 Filter</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/filtering1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/filtering2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/cdef.png.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_filter.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_filter1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_sp.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/film_grain_synthesis.png" alt=""></p>
<h1 id="0x8-Efficiency-and-Complexity"><a href="#0x8-Efficiency-and-Complexity" class="headerlink" title="0x8 Efficiency and Complexity"></a>0x8 Efficiency and Complexity</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/compression_efficiency.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/coding_complexity.png" alt=""></p>
<h1 id="0x9-Reference"><a href="#0x9-Reference" class="headerlink" title="0x9 Reference"></a>0x9 Reference</h1><p><a href="https://www.youtube.com/watch?v=04lXWMcwdXA&amp;t=822s" target="_blank" rel="external">a technial overview of the AV1</a><br><a href="https://www.youtube.com/watch?v=qubPzBcYCTw&amp;t=1957s" target="_blank" rel="external">The AV1 Video Codec</a><br><a href="https://en.wikipedia.org/wiki/AV1" target="_blank" rel="external">AV1 wiki</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Kevin Wen" />
          <p class="site-author-name" itemprop="name">Kevin Wen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Wen</span>
</div>


<div> <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
访问量 <span id="busuanzi_value_site_pv"></span>
访问人数 <span id="busuanzi_value_site_uv"></span>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("orq8xxsDQDXKiHdqSRcjlflB-gzGzoHsz", "ecCFdIcWDfbJKQOCiLFf1EBm");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
