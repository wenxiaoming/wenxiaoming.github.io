<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Kevin Wen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Kevin Wen&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kevin Wen&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Kevin Wen's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kevin Wen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/Graphics buffer Summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/Graphics buffer Summary/" itemprop="url">Graphics buffer总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T18:20:31+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/06/01/Graphics buffer Summary/" class="leancloud_visitors" data-flag-title="Graphics buffer总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-GPU系统Buffer介绍"><a href="#0x1-GPU系统Buffer介绍" class="headerlink" title="0x1 GPU系统Buffer介绍"></a>0x1 GPU系统Buffer介绍</h1><p>  本文对GPU系统中的buffer管理进行了总结。<br>  简单说来GPU系统使用到的buffer主要包括两部分，其中一部分是GPU绘制输出的frame buffer， 另外一部分是GPU driver中内部运行所需的各种buffer。<br>  这些buffer在CPU和GPU之间的pipeline如下图所示。<br>  从图中可知，Graphics程序运行的时候首先需要CPU先准备好各种数据，如纹理，顶点数据等。另外很大一块是Command，这个是用来驱动GPU硬件执行图形流水线的指令。另外Shader指的是用来执行GPU可编程pileine(如vertex shader，fragment shader等)的GPU指令。<br>  CPU把数据准备好了以后，驱动GPU硬件根据前面buffer里的数据和指令执行绘制工作，绘制的结果需要输出到一个地方，这个就是frame buffer。当然我们知道frame buffer也是可以被GPU再读进来。图中的Bin List部分指的是在Tile Based Render架构特有的buffer，这个buffer用来存储Tile划分(一般称为Binning阶段)以后每个Tile需要绘制的信息。</p>
<p>  <img src="/2019/06/01/Graphics buffer Summary/gpu bufer pileline.svg" alt=""></p>
<h1 id="0x2-Frame-Buffer"><a href="#0x2-Frame-Buffer" class="headerlink" title="0x2 Frame Buffer"></a>0x2 Frame Buffer</h1><p>  下面先来介绍一下Android系统中Graphics Buffer管理模块，后续再介绍一下DRM结构下Buffer分配的流程。<br>  Android系统中Graphics Buffer的架构图如下所示。<br>  <img src="/2019/06/01/Graphics buffer Summary/android buffer management.svg" alt=""></p>
<p>  Android系统中Graphics框架或应用通过Gralloc模块调用到ION driver，再通过ION driver分配出相应的frame buffer。如上图所示，ION driver中提供多种不同的heap。Carveout heap一般是指系统启动的时候预分配好的物理连续地址空间，缺点是这部分内存属于特定驱动独占式的，不能和其他模块共享，目前已经很少使用了。CMA(contiguous memory allocation) heap分配出来的buffer的物理地址也是连续的，但是它是在系统运行过程中通过内核中CMA框架来动态分配的。system heap分配出来的buffer其物理地址一般不是连续的。这三种类型的buffer适用于不同的硬件类型。对没有MMU的硬件来说，一般需要要求其访问的物理地址空间是连续的，所以这种硬件一般要求分配的buffer是CMA heap。对包含MMU的硬件来说，由于可以通过MMU(也称为IOMMU)来做虚拟地址到物理地址的转换，所以可以不需要保证其分配的buffer的物理地址空间是连续的。</p>
<p>  下面来介绍一下DRM架构下buffer分配的流程。<br>  传统的Linux系统如Ubuntu系统采用的是DRM架构图形系统，这个时候通过DRM kernel driver中的GEM模块来分配buffer。GEM是DRM kernel driver的buffer管理模块。其分配出来的buffer一般称为GEM buffer。其buffer分配过程简单说明如下。<br>  <img src="/2019/06/01/Graphics buffer Summary/drm buffer management.svg" alt=""></p>
<p>  为了简化DRM架构下GEM buffer的分配工作，其提供了libgbm模块作为管理kernel driver和图形应用之间的buffer分配的桥梁。<br>  libgbm的功能类似于Android上的gralloc+libion。mesa中包括了libgbm的实现代码。libgbm提供了底层DRM driver中buffer管理的封装。一般包括分配(DRM_IOCTL_MODE_CREATE_DUMB)，释放(DRM_IOCTL_MODE_DESTROY_DUMB)和mmap操作(DRM_IOCTL_MODE_MAP_DUMB)等操作。各种采用Linux作为内核的操作系统的HAL模块都提供了类似libgbm功能的buffer管理模块。</p>
<p>  下面来简单介绍一下为什么要执行 DRM_IOCTL_MODE_MAP_DUMB? DRM_IOCTL_MODE_MAP_DUMB的输入是一个 gem handle，返回结果是一个 offset，通过 offset 可以知道 mmap 当前要操作的dumb buffer。所以对 drm device 进行 mmap 操作时，其参数offset 并不是真正的内存偏移量，而是一个 gem object 的索引值。通过该索引值，drm 驱动就可以准确确定当前要操作的是哪个 gem对象，然后可以获取到与该 object 相对应的物理 buffer，并对完成真正的 mmap 操作。</p>
<p>   libgbm中DRM_IOCTL_MODE_MAP_DUMB的使用如下所示。可以看到和前面的解析是可以对应起来的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">map_arg.handle = bo-&gt;handle;</div><div class="line"></div><div class="line">ret = drmIoctl(bo-&gt;base.gbm-&gt;fd, DRM_IOCTL_MODE_MAP_DUMB, &amp;map_arg);</div><div class="line"><span class="keyword">if</span> (ret)</div><div class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">bo-&gt;<span class="built_in">map</span> = mmap(<span class="number">0</span>, bo-&gt;size, PROT_WRITE,</div><div class="line">               MAP_SHARED, bo-&gt;base.gbm-&gt;fd, map_arg.offset);</div></pre></td></tr></table></figure></p>
<p>   下面来说一下mesa driver中frame buffer分配过程。<br>   调用eglCreateWindowSurface之类的函数会指明需要创建Suface。这个时候一般不会真正分配buffer，而是会创建类似buffer的占位符的Suface对象。然后等真正需要使用这个buffer的时候才完成分配工作，这里面体现了defer分配的思想。<br>   下面介绍一下真正需要分配buffer的时候buffer是如何分配出来的。<br>   首先通过eglMakeCurrent分配，具体流程如下。这个分配出来的buffer供给后续的eglSwapBuffer使用。<br>    <img src="/2019/06/01/Graphics buffer Summary/eglMakeCurrent.svg" alt=""></p>
<p>   eglSwapBuffer在前面分配好的buffer执行完绘制工作以后，对应的buffer可能送去合成模块继续执行合成动作了。如果后面再调用glClear，需要分配新的buffer，具体流程如下。<br>   <img src="/2019/06/01/Graphics buffer Summary/glClear.svg" alt=""></p>
<p>   在eglMakeCurrent和glClear调用执行buffer分配工作的时候，需要找到一块目标buffer执行clear操作，如果这个时候没有可用的buffer，或者buffer大小不符合要求，则需要重新分配一块新的buffer。</p>
<p>   前面看到，不同的Graphics API函数都可能触发buffer的分配，但是每个egl context可以分配buffer的数量是有限制的，一般是2~3个。如果buffer用完了，这个时候可能就需要等待一个空的可用的buffer从其他的pipeline中释放出来。如我们可能在systrace上看到glClear函数占用很长时间，这个时候就会感觉很奇怪，因为glClear按理说不应该占用GPU太长时间，这个时候大概率是在等待一个空的buffer变成可用，并不是在GPU在执行繁重的绘制任务。</p>
<h1 id="0x3-GPU-driver中内部使用的buffer"><a href="#0x3-GPU-driver中内部使用的buffer" class="headerlink" title="0x3 GPU driver中内部使用的buffer"></a>0x3 GPU driver中内部使用的buffer</h1><p>   这里介绍的buffer一般是指GPU driver运行过程中内部需要的各种buffer，如常见的texture buffer,vertex buffer,shader buffer, command buffer。这种buffer一般用来保存GPU需要读取的各种数据, 这种buffer的使用一般流程是先通过kernel driver分配出来，然后mmap到CPU端，CPU完成写入以后，GPU开始读取。GPU读取的时候会涉及到GPU MMU的动作，需要完成GPU虚拟地址到GPU物理地址的转换。</p>
<p>   Andorid的GPU驱动架构下，其内部使用的buffer管理一般是char kernel driver+闭源User space library的架构来实现。kernel driver通过alloc_pages之类的底层API直接分配buffer，然后mmap到User space给CPU写入，写入完成通过ioctl通知GPU硬件开始使用这些buffer。</p>
<p>   下面来简单介绍一下Intel Gen i915 kernel driver中GEM buffer实现。<br>    i915 kernel driver提供了下面三种gem buffer实现。<br>    其中shmem_region_ops采用的是shmem机制来分配内存，shmem是一套ipc，通过相应的ipc系统调用shmget能够以指定key创建一块的共享内存。需要使用这块内存的进程可以通过shmat系统调用来获得它。<br>    stolen buffer指的通过GTT(Graphics translation table)来管理的buffer，这里面类似GTT,PPGTT的概念都是很大的一块技术，这里就不深入介绍了。<br>    下面直接贴出i915 kernel driver中三种gem buffer定义和初始化的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> intel_region_id &#123;</div><div class="line">    INTEL_REGION_SMEM = <span class="number">0</span>,</div><div class="line">    INTEL_REGION_LMEM,</div><div class="line">    INTEL_REGION_STOLEN,</div><div class="line">    INTEL_REGION_UNKNOWN, <span class="comment">/* Should be last */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">intel_memory_region_ops</span> <span class="title">shmem_region_ops</span> = &#123;</span></div><div class="line">    .init = init_shmem,</div><div class="line">    .release = release_shmem,</div><div class="line">    .create_object = create_shmem,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">intel_memory_region_ops</span> <span class="title">i915_region_stolen_ops</span> = &#123;</span></div><div class="line">    .init = init_stolen,</div><div class="line">    .release = release_stolen,</div><div class="line">    .create_object = _i915_gem_object_create_stolen,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">intel_memory_region_ops</span> <span class="title">intel_region_lmem_ops</span> = &#123;</span></div><div class="line">    .init = region_lmem_init,</div><div class="line">    .release = region_lmem_release,</div><div class="line">    .create_object = __i915_gem_lmem_object_create,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">intel_memory_regions_hw_probe</span><span class="params">(struct drm_i915_private *i915)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> err, i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(i915-&gt;mm.regions); i++) &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">intel_memory_region</span> *<span class="title">mem</span> = <span class="title">ERR_PTR</span>(-<span class="title">ENODEV</span>);</span></div><div class="line">        u32 type;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!HAS_REGION(i915, BIT(i)))</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        type = MEMORY_TYPE_FROM_REGION(intel_region_map[i]);</div><div class="line">        <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="keyword">case</span> INTEL_MEMORY_SYSTEM:</div><div class="line">            mem = i915_gem_shmem_setup(i915);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> INTEL_MEMORY_STOLEN:</div><div class="line">            mem = i915_gem_stolen_setup(i915);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> INTEL_MEMORY_LOCAL:</div><div class="line">            mem = intel_setup_fake_lmem(i915);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (IS_ERR(mem)) &#123;</div><div class="line">            err = PTR_ERR(mem);</div><div class="line">            drm_err(&amp;i915-&gt;drm,</div><div class="line">                <span class="string">"Failed to setup region(%d) type=%d\n"</span>,</div><div class="line">                err, type);</div><div class="line">            <span class="keyword">goto</span> out_cleanup;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mem-&gt;id = intel_region_map[i];</div><div class="line">        mem-&gt;type = type;</div><div class="line">        mem-&gt;instance = MEMORY_INSTANCE_FROM_REGION(intel_region_map[i]);</div><div class="line"></div><div class="line">        i915-&gt;mm.regions[i] = mem;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  另外我们知道buffer的分配是很heavy的操作，gpu驱动一般都提供了cache机制来缓存使用过的buffer，也就是说延迟释放这些使用过的buffer。mesa和broadcom gpu驱动中实现了用户态驱动的cache机制，mali早期gpu(mali400/450)在kernel space driver中加了cache机制。从性能的角度的来说，用户态驱动的cache应该更好一些，毕竟少了从用户态到内核态的调用，但是用户态驱动的cache实现复杂一些。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/06/Use AI to speed up AV1 encoder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/06/Use AI to speed up AV1 encoder/" itemprop="url">Use AI to speed up AV1 encoder</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-06T17:00:10+08:00">
                2019-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/06/Use AI to speed up AV1 encoder/" class="leancloud_visitors" data-flag-title="Use AI to speed up AV1 encoder">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-AV1的编码复杂性"><a href="#0x1-AV1的编码复杂性" class="headerlink" title="0x1 AV1的编码复杂性"></a>0x1 AV1的编码复杂性</h1><p>我们知道AV1的官方参考实现是libaom，由于AV1的编码复杂度高，如果采用libaom编码器来生成AV1的码流离实时编码还有很大的距离。我们知道传统视频编码器中有宏块的概念，宏块是16x16的亮度块 + 2个 8x8的色度快。从HEVC开始，到现在的AV1进一步引入了partiton的概念，也就是树形编码的概念，也就是说把先规定好最大的编码单元，这个最大的编码单元称为super block，在HEVC一般是64x64，在AV1中为128x128。然后进行四叉树划分，AV1中直至划分成4x4，HEVC中直至划分成8x8。而且这种划分进一步扩展到预测单元和变换单元。据统计，AV1编码中的复杂度80%是因为partiton引入的，所以要是能有一个快速方法来加速partiton的判断的话，AV1的编码速度能大幅提升。</p>
<p>AV1中的partiton划分如下图所示。<br><img src="https://wenxiaoming.github.io/2019/03/02/The-overview-of-AV1-coding/partition2.png" alt=""></p>
<h1 id="0x2-AI加速partiton划分"><a href="#0x2-AI加速partiton划分" class="headerlink" title="0x2 AI加速partiton划分"></a>0x2 AI加速partiton划分</h1><pre><code>在libaom目前的实现中，AI加速主要用在intra frame的partition划分优化上。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">av1_intra_mode_cnn_partition(</div><div class="line">    &amp;cpi-&gt;common, x, bsize, x-&gt;quad_tree_idx, &amp;partition_none_allowed,</div><div class="line">    &amp;partition_horz_allowed, &amp;partition_vert_allowed, &amp;do_rectangular_split,</div><div class="line">    &amp;do_square_split);</div></pre></td></tr></table></figure>
<p>该函数的输入是图像的像素值，可以理解为图像对应的纹理。并且需要把对应亮度/色度值转换成0~1之间的浮点数。如下代码所示，c为亮度或色度分量的index，这里c为0，为亮度分量。max_val为亮度/色度分量的最大值255(假设为8bit yuv)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i)</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</div><div class="line">      input[i * in_stride + j] = (<span class="keyword">float</span>)dgd[c][i * stride + j] / max_val;</div></pre></td></tr></table></figure>
<p>输出是这几个变量partition_none_allowed，partition_horz_allowed，partition_vert_allowed，do_rectangular_split，do_square_split。用来对后续的partition的划分进行优化，从变量的名称可以看到这些变量会对后续的partition划分进行限制，也就是减少了partition的数目。</p>
<p>推理采用的网络是CNN + DNN的结合。<br>CNN是5层网络结构，网络定义如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> CNN_CONFIG av1_intra_mode_cnn_partition_cnn_config = &#123;</div><div class="line">    NUM_CNN_LAYERS,  <span class="comment">// num_layers</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// is_residue</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// ext_width</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// ext_height</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// strict_bounds</span></div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_0_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_0_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_0_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_0_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_0_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_0_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_0_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_0_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">-1</span>,                <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_1_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_1_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_1_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_1_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_1_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_1_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_1_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_1_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">3</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_2_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_2_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_2_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_2_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_2_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_2_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_2_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_2_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">2</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_3_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_3_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_3_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_3_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_3_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_3_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_3_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_3_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">1</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_4_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_4_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_4_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_4_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_4_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_4_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_4_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_4_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">0</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>DNN是两层网络结构，网络定义如下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> NN_CONFIG av1_intra_mode_cnn_partition_branch_0_dnn_config = &#123;</div><div class="line">    BRANCH_0_NUM_DNN_FEATURES,</div><div class="line">    BRANCH_0_NUM_LOGITS,</div><div class="line">    BRANCH_0_NUM_DNN_LAYERS,</div><div class="line">    &#123;</div><div class="line">        BRANCH_0_NUM_DNN_LAYER_0_UNITS,</div><div class="line">        BRANCH_0_NUM_DNN_LAYER_1_UNITS,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_0_kernel,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_1_kernel,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_logits_kernel,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_0_bias,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_1_bias,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_logits_bias,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="0x3-推理模型的训练"><a href="#0x3-推理模型的训练" class="headerlink" title="0x3 推理模型的训练"></a>0x3 推理模型的训练</h1><p>以上编码过程中采用的CNN + DNN的网络是经过训练的，在libaom的代码中并没有提供这个网络结构的训练过程代码。参考<a href="https://zhuanlan.zhihu.com/p/40034222" target="_blank" rel="external">HEVC partition优化</a>可以大体知道其训练过程。应该是设计好网络以后，通过大量样本数据来训练得到该推理网络的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/Buffer sharing in Weston/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/Buffer sharing in Weston/" itemprop="url">Buffer sharing in Weston</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T19:30:00+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/30/Buffer sharing in Weston/" class="leancloud_visitors" data-flag-title="Buffer sharing in Weston">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Weston简介"><a href="#0x1-Weston简介" class="headerlink" title="0x1 Weston简介"></a>0x1 Weston简介</h1><h2 id="0x11-X系统"><a href="#0x11-X系统" class="headerlink" title="0x11 X系统"></a>0x11 X系统</h2><p>X即X11、X Window System，是用于在类UNIX的操作系统上的位图显示的窗口系统，提供了GUI环境的基本框架，可以在显示设备上绘制、移动窗口，通过鼠标、键盘、触摸屏与用户交互. X Server是X显示服务的一种开源实现，其系统结构如下图所示<br><img src="/2019/03/30/Buffer sharing in Weston/x-architecture.png" alt=""></p>
<h2 id="0x12-Wayland系统"><a href="#0x12-Wayland系统" class="headerlink" title="0x12 Wayland系统"></a>0x12 Wayland系统</h2><p>Wayland是一个显示服务协议，服务端为Wayland Compositor，服务端把把X系统中的X Server和Compositor合二为一，作为类Unix操作系统上更现代、简洁的窗口系统，旨在替换X系统。Weston是Wayland Compositor的参考实现。下面是Wayland官网文档给出的架构简图.<br><img src="/2019/03/30/Buffer sharing in Weston/wayland-architecture.png" alt=""></p>
<p>Wayland协议为Client/Server模式，客户端为图形应用程序，发送绘制命令，请求在各自输出缓冲区的显示，服务器为Compositor，控制各个客户端输出缓冲区的合成和显示。</p>
<p>Wayland参考实现Weston包括两层协议。</p>
<p>一个为底层IPC协议。采用Linux Domain Socket实现的IPC，这部分采用手动写的C语言实现。</p>
<p>另一个是上层消息协议。这部分采用libffi来实现，从规定格式的XML文件中自动生成，可以灵活地动态扩展或者用于错误验证。处理客户端和Weston之间的上层交互流程，以实现窗口系统的基本功能。</p>
<p>Wayland参考实现包括两部分，libwayland-client和libwayland-server，其架构简图如下所示。<br><img src="/2019/03/30/Buffer sharing in Weston/Wayland_protocol_architecture.svg" alt=""></p>
<h1 id="0x2-Buffer管理"><a href="#0x2-Buffer管理" class="headerlink" title="0x2 Buffer管理"></a>0x2 Buffer管理</h1><p>在Weston的实现中，客户端先把内容绘制到一个buffer中，然后weston把多个客户端绘制的buffer通过compositor模块合成在一起。这里面涉及到buffer在各个模块之间的传递，从性能的角度考虑，我们很自然地想到如何避免memory copy的问题。下来我们来看一下如何实现zero memory copy的。</p>
<p>Weston中的buffer用wl_buffer对象来描述。这个buffer需要在客户端和Compositor之间共享。目前有两种buffer的管理模式。</p>
<ol>
<li>wl_shm<br>这种方式是通过共享内存的方式来实现客户端和Compositor之间的共享，通过这种方式分配的内存是物理不连续的，这种方式一般用于采用软件绘制的情况，当buffer在客户端绘制完成以后，Compositor得到通知开始合成的时候，需要通过glTexImage2D()函数把buffer作为纹理上传到GPU中，这样的话性能是会受到影响的，因为纹理上传一般是比较耗时的操作。</li>
<li><p>wl_drm<br>这种方式通过Wayland EGL中的相关机制来保证，客户端通过wayland-egl.h的相关接口EGLSurface来创建GPU的输出buffer，然后客户端开始绘制，绘制完成以后，客户端的GPU输出buffer通过eglCreateImageKHR()接口创建EGLImage，这个EGLImage可以直接作为Compositor的输入纹理来使用，不需要额外的拷贝工作。</p>
<p>开源的mesa drm实现定义了drm Wayland扩展, 这个时候客户端和Compositor之间可以共享drm (GEM) buffers。</p>
<p>下面介绍一下基于KMS BO buffer type的mesa wl_drm共享流程<br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_1.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_2.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_3.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_4.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_5.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_6.png" alt=""></p>
</li>
</ol>
<h1 id="0x3-与Android上图形系统的比较"><a href="#0x3-与Android上图形系统的比较" class="headerlink" title="0x3 与Android上图形系统的比较"></a>0x3 与Android上图形系统的比较</h1><ol>
<li><p>Buffer的分配<br>Android上的buffer是在服务端（SurfaceFlinger）分配的，然后通过ION机制实现buffer的共享。<br>而Wayland系统中buffer是在客户端分配的，通过底层EGL驱动提供的buffer共享管理机制，再配合IPC机制实现客户端和服务端之间的buffer共享。</p>
</li>
<li><p>Window管理器的实现<br>Android上有单独的WMS(Window Manager Service)模块来做窗口管理的工作。而Wayland系统中在Weston中实现了窗口管理的工作，也就是是窗口管理和合成是在同一个进程中完成的。</p>
</li>
<li><p>Android on Wayland<br>把Android上的SurfaceFlinger作为一个Wayland Client，然后参与Weston的合成。架构图如下<br><img src="/2019/03/30/Buffer sharing in Weston/AndroidOnWayland.png" alt=""></p>
<p>上图的架构有点类似于把X Server作为一个Wayland Client，如下图所示<br><img src="/2019/03/30/Buffer sharing in Weston/xwayland.png" alt=""></p>
</li>
</ol>
<h1 id="0x4-Run-Weston-on-Ubuntu"><a href="#0x4-Run-Weston-on-Ubuntu" class="headerlink" title="0x4 Run Weston on Ubuntu"></a>0x4 Run Weston on Ubuntu</h1><p>   把Wayland protocol和Weston相关实现porting到Ubuntu上，Weston加载X11-backend，也就是说Weston作为X Server的一个Client，把Weston的合成输出在接入到Ubuntu的X Server系统中来输出。</p>
<p>   绘制和合成流程如下图所示<br>   <img src="/2019/03/30/Buffer sharing in Weston/Draw &amp; Composition.png" alt=""></p>
<p>   测试效果如下图所示<br>   <img src="/2019/03/30/Buffer sharing in Weston/demo.png" alt=""></p>
<h1 id="0x5-参考"><a href="#0x5-参考" class="headerlink" title="0x5 参考"></a>0x5 参考</h1><p><a href="https://wayland.freedesktop.org/architecture.html" target="_blank" rel="external">Wayland architecture</a><br><a href="https://events.static.linuxfound.org/sites/events/files/slides/als2015_wayland_weston_v2.pdf" target="_blank" rel="external">Wayland/Weston Renderer</a><br><a href="https://at.projects.genivi.org/wiki/display/DIRO/Android+display+subsystem+as+a+wayland+client" target="_blank" rel="external">Android display subsystem as a wayland client</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/23/How escher support physically based render/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/How escher support physically based render/" itemprop="url">How escher support physically based render</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-23T12:00:00+08:00">
                2019-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/23/How escher support physically based render/" class="leancloud_visitors" data-flag-title="How escher support physically based render">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-物理渲染和光栅化渲染"><a href="#0x1-物理渲染和光栅化渲染" class="headerlink" title="0x1 物理渲染和光栅化渲染"></a>0x1 物理渲染和光栅化渲染</h1><h2 id="0x21-传统光栅化渲染器的特点"><a href="#0x21-传统光栅化渲染器的特点" class="headerlink" title="0x21 传统光栅化渲染器的特点"></a>0x21 传统光栅化渲染器的特点</h2><p>光栅化是指把3D空间的几何图形及其色彩信息转换至2D计算机屏幕上像素的过程。光栅化渲染器的pipeline包括Vertex Shader,Rasterization,Fragment Shader等阶段，目前GPU硬件也是采用这种高效率的光栅化架构。基于这些GPU硬件设计的渲染API有Windows上的DirectX,跨平台的OpenGL和Vulkan，已经Apple的Metal等。应用程序可以基于这些渲染API开发出酷炫的3D效果。但是这种光栅化的缺点也很明显，那就是无法完全模拟真实场景下的光线传播，导致绘制效果失真。</p>
<p>下图说明了光栅化渲染器的流水线。</p>
<p><img src="/2019/03/23/How escher support physically based render/pipeline.png" alt=""></p>
<p>现代GPU中vertex shader和fragment shader一般是逻辑的概念，当时比较早的GPU是采用两种独立的硬件单元(不是Unified Shader)来实现的，如ARM Mali-400就是这种架构，这种架构的缺点是vertex shader和fragment shader的负载没办法平衡，极端情况下会出现其中一种硬件Shader满负荷运行，另外一种硬件Shader空闲的情况。后来的架构一般是基于通用可编程计算单元实现这些功能。也就是我们常说的Unified Shader架构。如树莓派中的Soc VideoCore采用了BroadCom V3D GPU, 其中的Unified Shader中采用QPU这种通用可编程计算单元来实现。</p>
<p>移动GPU相对桌面GPU的架构也有差别，因为移动平台上对带宽及功耗的要求都比较高。<br>桌面GPU一般采用IMR(Immediate Mode Rendering)架构, 这种架构需要同时对该次渲染的全部物体进行处理，需要频繁访问系统帧缓存（位于系统内存里），故对带宽要求较高。</p>
<p>移动GPU一般采用TBR架构(Tile Based Rendering)。TBR架构包括两个阶段Tiling和Binning。Tiling阶段把整个画面分成小块，然后计算每个小块中有哪些三角形需要处理。Binning阶段每次只对一个小块中包括的三角形进行处理，这种方式避免了对帧缓存（位于系统内存里）的频繁读写和修改，因为这些小块中的三角形的渲染是在GPU上的高速缓存里进行，所以能节约带宽，同时也减少了功耗。</p>
<p>Imagination在TBR架构的基础上又提出了TBDR(Tile Based Deferred Rendering), 在执行shading之前加入HSR(Hidded Surface Remove), 这个模块利用vertex shader/rasterization之后的fragment的深度值来优化掉不必要的计算。</p>
<h2 id="0x22-物理渲染器的特点"><a href="#0x22-物理渲染器的特点" class="headerlink" title="0x22 物理渲染器的特点"></a>0x22 物理渲染器的特点</h2><p>物理渲染器PBR(Physically Based Rendering),也称光线跟踪器(Ray tracer)。采用该算法渲染的结果看起来更真实，因为它基于物理参数的方法来编写材质，而且考虑了光线的发射和折射，材质对光线的吸收等。</p>
<p>光线跟踪算法描述如下，沿着到达视点的光线的反方向跟踪，经过屏幕上每一个象素，找出与视线相交的物体表面点，并继续跟踪，找出影响点光强的所有光源，从而算出点上精确的光线强度。这种算法计算量极大，一般用于离线渲染。</p>
<p>一个典型的物理渲染器包括如下模块。<br>相机<br>光线-对象相交测试<br>光照分布/光线传播<br>递归光线跟踪机制</p>
<p>考虑到PBR的计算量太大，只适合离线渲染，后来基于全局光照Global Illuslaton技术的来实现实时PBR，因为考虑到了速度的提升，在渲染质量上会有损失。</p>
<p>早期Ray tracing的硬件有德国萨尔兰大学计算机图形小组在2005年的SIGGRAPH上展示了第一个实时光线追踪加速硬件——RPU（Ray Processing Unit），最近有NVIDIA在GPU硬件中加入了Ray tracing。</p>
<p>下图是采用Blender中的cycles物理渲染器渲染的坦克效果图，如果完全用CPU来计算，速度很慢，大概需要几十分钟。<br><img src="/2019/03/23/How escher support physically based render/tank.png" alt=""></p>
<h1 id="0x2-Escher是如何做到物理渲染的？"><a href="#0x2-Escher是如何做到物理渲染的？" class="headerlink" title="0x2 Escher是如何做到物理渲染的？"></a>0x2 Escher是如何做到物理渲染的？</h1><p>Escher是Google下一代操作系统Fuchsia上内置的基于物理的真实感渲染引擎，它和Scenic一起提供了Fuchsia上的合成及进一步特效处理功能。</p>
<p>Escher目前看来主要采用光照和阴影技术来达到物理渲染的效果。</p>
<p>阴影是真实感渲染的一个重要组成部分，它对增加渲染物体的表面细节，帮助观察者增加对场景的空间感，从而更好地来判断物体的位置关系以及形状等有很大的帮助。可以说没有了阴影，3D场景中的真实感和吸引力将降低。</p>
<p>Escher中包括了如下几种阴影技术，ShadowMap、ShadowVolume等。</p>
<p>从Escher的实现代码可知，Escher还只是实现了部分物理渲染的功能，主要是通过light和shadow来体现真实感效果，后续要支持AR/VR中更多酷炫效果的话，需要进一步开发。</p>
<h1 id="0x03-展望"><a href="#0x03-展望" class="headerlink" title="0x03 展望"></a>0x03 展望</h1><p>随着GPU硬件中增加了Ray tracing的功能，主流API都增加了对Ray tracing的支持，未来Escher中可能会直接调用这些API(目前Escher中是调用了Vulkan，也就是说会调用Vulkan的Ray tracing支持)来加速Ray tracing的处理。</p>
<p>下来介绍一种主流API对 ray tracing的支持</p>
<h2 id="0x31-Directx-raytracing"><a href="#0x31-Directx-raytracing" class="headerlink" title="0x31 Directx raytracing"></a>0x31 Directx raytracing</h2><p>DirectX Raytracing在DirectX 12 API的基础上引入了下面这些概念<br><a href="https://devblogs.microsoft.com/directx/announcing-microsoft-directx-raytracing/" target="_blank" rel="external">DirectX Raytracing</a></p>
<p>What is DirectX Raytracing?<br>At the highest level, DirectX Raytracing (DXR) introduces four, new concepts to the DirectX 12 API:</p>
<p>The acceleration structure is an object that represents a full 3D environment in a format optimal for traversal by the GPU.  Represented as a two-level hierarchy, the structure affords both optimized ray traversal by the GPU, as well as efficient modification by the application for dynamic objects.</p>
<p>A new command list method, DispatchRays, which is the starting point for tracing rays into the scene.  This is how the game actually submits DXR workloads to the GPU.</p>
<p>A set of new HLSL shader types including ray-generation, closest-hit, any-hit, and miss shaders.  These specify what the DXR workload actually does computationally.  When DispatchRays is called, the ray-generation shader runs.  Using the new TraceRay intrinsic function in HLSL, the ray generation shader causes rays to be traced into the scene.  Depending on where the ray goes in the scene, one of several hit or miss shaders may be invoked at the point of intersection.  This allows a game to assign each object its own set of shaders and textures, resulting in a unique material.</p>
<p>The raytracing pipeline state, a companion in spirit to today’s Graphics and Compute pipeline state objects, encapsulates the raytracing shaders and other state relevant to raytracing workloads.</p>
<h2 id="0x32-Vulkan-ray-tracing"><a href="#0x32-Vulkan-ray-tracing" class="headerlink" title="0x32 Vulkan ray tracing"></a>0x32 Vulkan ray tracing</h2><p>NVIDIA提供了Vulkan的扩展了支持ray tracing。<br><a href="https://devblogs.nvidia.com/vulkan-raytracing/" target="_blank" rel="external">Vulkan ray tracing</a></p>
<h2 id="0x33-Metal-ray-tracing"><a href="#0x33-Metal-ray-tracing" class="headerlink" title="0x33 Metal ray tracing"></a>0x33 Metal ray tracing</h2><p>Metal提供了ray tracing的支持。<br><img src="/2019/03/23/How escher support physically based render/metal_ray_tracing.png" alt=""></p>
<p>详细信息请参考<br><a href="https://developer.apple.com/videos/play/wwdc2018/606/" target="_blank" rel="external">Metal ray tracing</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/16/AV1-syntax-explanation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/AV1-syntax-explanation/" itemprop="url">AV1-syntax-explanation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T17:00:10+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/16/AV1-syntax-explanation/" class="leancloud_visitors" data-flag-title="AV1-syntax-explanation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-解码流程介绍"><a href="#0x1-解码流程介绍" class="headerlink" title="0x1 解码流程介绍"></a>0x1 解码流程介绍</h1><p><img src="/2019/03/16/AV1-syntax-explanation/av1 syntax description.png" alt=""><br>解码流程说明如下</p>
<h2 id="0x11-tile-group-obu"><a href="#0x11-tile-group-obu" class="headerlink" title="0x11 tile_group_obu"></a>0x11 tile_group_obu</h2><p>   对tile group的每个tile调用decode_tile()进行解码，直至tile group中包括的tile都解码完成.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( TileNum = tg_start; TileNum &lt;= tg_end; TileNum++ ) &#123;</div><div class="line">    tileRow = TileNum / TileCols</div><div class="line">    tileCol = TileNum % TileCols</div><div class="line">    ......</div><div class="line">    decode_tile( )</div><div class="line">    exit_symbol( )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x12-decode-tile"><a href="#0x12-decode-tile" class="headerlink" title="0x12 decode_tile"></a>0x12 decode_tile</h2><p>   对tile中包含的每个partition进行解码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( r = MiRowStart; r &lt; MiRowEnd; r += sbSize4 ) &#123;</div><div class="line">    <span class="keyword">for</span> ( c = MiColStart; c &lt; MiColEnd; c += sbSize4 ) &#123;</div><div class="line">        ......</div><div class="line">        decode_partition( r, c, sbSize )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x13-decode-partition"><a href="#0x13-decode-partition" class="headerlink" title="0x13 decode_partition"></a>0x13 decode_partition</h2><p>   每个partition的解码过程就是对一个super block(super block的定义参考0x2)进行解码的过程.<br>   根据partition类型对进一步split, 不能split的类型调用decode_block().</p>
<pre><code>partition类型的定义如下

| Partition index | Type of partition  |
|:-------:|:------------- |
| 0 |PARTITION_NONE|
| 1 |PARTITION_HORZ|
| 2 |PARTITION_VERT|
| 3 |PARTITION_SPLIT|
| 4 |PARTITION_HORZ_A|
| 5 |PARTITION_HORZ_B|
| 6 |PARTITION_VERT_A|
| 7 |PARTITION_VERT_B|
| 8 |PARTITION_HORZ_4|
| 9 |PARTITION_VERT_4|
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( partition == PARTITION_NONE ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line"><span class="keyword">if</span> ( hasRows )</div><div class="line">    decode_block( r + halfBlock4x4, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    <span class="keyword">if</span> ( hasCols )</div><div class="line">       decode_block( r, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_SPLIT ) &#123;</div><div class="line">    decode_partition( r, c, subSize )</div><div class="line">    decode_partition( r, c + halfBlock4x4, subSize )</div><div class="line">    decode_partition( r + halfBlock4x4, c, subSize )</div><div class="line">    decode_partition( r + halfBlock4x4, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_A ) &#123;</div><div class="line">    decode_block( r, c, splitSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_B ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c + halfBlock4x4, splitSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT_A ) &#123;</div><div class="line">    decode_block( r, c, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, splitSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT_B ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c + halfBlock4x4, splitSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_4 ) &#123;</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">0</span>, c, subSize )</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">1</span>, c, subSize )</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">2</span>, c, subSize )</div><div class="line">    <span class="keyword">if</span> ( r + quarterBlock4x4 * <span class="number">3</span> &lt; MiRows )</div><div class="line">        decode_block( r + quarterBlock4x4 * <span class="number">3</span>, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//PARTITION_VERT_4</span></div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">0</span>, subSize )</div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">1</span>, subSize )</div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">2</span>, subSize )</div><div class="line">    <span class="keyword">if</span> ( c + quarterBlock4x4 * <span class="number">3</span> &lt; MiCols )</div><div class="line">        decode_block( r, c + quarterBlock4x4 * <span class="number">3</span>, subSize )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x14-decode-block"><a href="#0x14-decode-block" class="headerlink" title="0x14 decode_block"></a>0x14 decode_block</h2><p>   对一个block进行解码，进一步调用residual对残差进行解码.</p>
<h2 id="0x15-transform-tree"><a href="#0x15-transform-tree" class="headerlink" title="0x15 transform_tree"></a>0x15 transform_tree</h2><p>   对不同size的transform块进行解码，它是一个递归函数，递归退出函数是transform_block.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">transform_tree( startX, startY, w, h ) &#123; Type</div><div class="line">    maxX = MiCols * MI_SIZE</div><div class="line">    maxY = MiRows * MI_SIZE</div><div class="line">    <span class="keyword">if</span> ( startX &gt;= maxX || startY &gt;= maxY ) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    row = startY &gt;&gt; MI_SIZE_LOG2</div><div class="line">    col = startX &gt;&gt; MI_SIZE_LOG2</div><div class="line">    lumaTxSz = InterTxSizes[ row ][ col ]</div><div class="line">    lumaW = Tx_Width[ lumaTxSz ]</div><div class="line">    lumaH = Tx_Height[ lumaTxSz ]</div><div class="line">    <span class="keyword">if</span> ( w &lt;= lumaW &amp;&amp; h &lt;= lumaH ) &#123;</div><div class="line">        txSz = find_tx_size( w, h )</div><div class="line">        transform_block( <span class="number">0</span>, startX, startY, txSz, <span class="number">0</span>, <span class="number">0</span> )</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ( w &gt; h ) &#123;</div><div class="line">            transform_tree( startX, startY, w/<span class="number">2</span>, h )</div><div class="line">            transform_tree( startX + w / <span class="number">2</span>, startY, w/<span class="number">2</span>, h )</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( w &lt; h ) &#123;</div><div class="line">            transform_tree( startX, startY, w, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX, startY + h/<span class="number">2</span>, w, h/<span class="number">2</span> )</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            transform_tree( startX, startY, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX + w/<span class="number">2</span>, startY, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX, startY + h/<span class="number">2</span>, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX + w/<span class="number">2</span>, startY + h/<span class="number">2</span>, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x16-Reconstruct中包括具体的反量化，反dct-重建像素和loop-filter等过程"><a href="#0x16-Reconstruct中包括具体的反量化，反dct-重建像素和loop-filter等过程" class="headerlink" title="0x16 Reconstruct中包括具体的反量化，反dct,重建像素和loop filter等过程."></a>0x16 Reconstruct中包括具体的反量化，反dct,重建像素和loop filter等过程.</h2><h1 id="0x2-super-block"><a href="#0x2-super-block" class="headerlink" title="0x2 super block"></a>0x2 super block</h1><p>下图说明了一个frame由许多super block组成，super block的定义稍后说明.<br><img src="/2019/03/16/AV1-syntax-explanation/super_block.png" alt=""></p>
<p>Super block的定义如下<br>The top level of the block quadtree within a tile. All superblocks within a frame are the same size and are square. The<br>superblocks may be 128x128 luma samples or 64x64 luma samples. A superblock may contain 1 or 2 or 4 mode info<br>blocks, or may be bisected in each direction to create 4 sub-blocks, which may themselves be further subpartitioned,<br>forming the block quadtree.</p>
<p>通过在sequence_header_obu中的use_128x128_superblock来控制superblock的大小是128x128还是64x64.<br>sequence_header_obu( ) {<br>    ……<br>    use_128x128_superblock f(1)<br>    ……<br>}</p>
<p>use_128x128_superblock的定义如下<br>when equal to 1, indicates that superblocks contain 128x128 luma samples. When equal to 0,<br>it indicates that superblocks contain 64x64 luma samples.</p>
<h1 id="0x3-split划分"><a href="#0x3-split划分" class="headerlink" title="0x3 split划分"></a>0x3 split划分</h1><p>下图显示了super block(64x64)的split状态, 从图中可以看到，64x64的block会被split到32x32，再进一步split到16x16.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/split_.png" alt=""></p>
<h1 id="0x4-Intra-Y-mode"><a href="#0x4-Intra-Y-mode" class="headerlink" title="0x4 Intra Y mode"></a>0x4 Intra Y mode</h1><p>下图显示了Intra Prediction中Y分量的mode，不同的颜色代码不同的mode.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/mode.png" alt=""></p>
<h1 id="0x5-Intra-UV-mode"><a href="#0x5-Intra-UV-mode" class="headerlink" title="0x5 Intra UV mode"></a>0x5 Intra UV mode</h1><p>下图显示了Intra Prediction中UV分量的mode，不同的颜色代码不同的mode，其中显示数字的块表示该mode为chroma from luma prediction, 其中显示的数字表示chroma需要从哪个位置的luma预测.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/uv_mode.png" alt=""></p>
<h1 id="0x6-Motion-vector"><a href="#0x6-Motion-vector" class="headerlink" title="0x6 Motion vector"></a>0x6 Motion vector</h1><p>下图显示了Inter frame帧间预测的运动向量.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/motion_vector.png" alt=""></p>
<h1 id="0x7-Reference"><a href="#0x7-Reference" class="headerlink" title="0x7 Reference"></a>0x7 Reference</h1><p><a href="https://people.xiph.org/~mbebenita/analyzer/" target="_blank" rel="external">AV1 analyzer</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/Synchronization-in-Vulkan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/Synchronization-in-Vulkan/" itemprop="url">Synchronization-in-Vulkan</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T17:00:10+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/09/Synchronization-in-Vulkan/" class="leancloud_visitors" data-flag-title="Synchronization-in-Vulkan">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Overview"><a href="#0x1-Overview" class="headerlink" title="0x1 Overview"></a>0x1 Overview</h1><p>Vulkan的一大优势是能通过多线程来提升CPU bounding场景的performance，这依赖于其提供了下面几种同步机制。</p>
<p>Semaphores，用于多个queue之间的同步或者是一个queue的任务提交同步。<br>Events，用于一个command buffer内部的同步或在同一个queue内部多个command buffer的同步。<br>Fences，用于提供devive和host之间的同步。<br>barriers，用于精确控制pipeline中各个pipeline阶段的资源流动。<br>下图说明了这几种同步机制适用的场景。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/sync_types.png" alt=""></p>
<h1 id="0x2-Details"><a href="#0x2-Details" class="headerlink" title="0x2 Details"></a>0x2 Details</h1><h2 id="0x21-Pipeline-Barrier"><a href="#0x21-Pipeline-Barrier" class="headerlink" title="0x21 Pipeline Barrier"></a>0x21 Pipeline Barrier</h2><p>Barrier是一种同步机制，用来管理内存访问和同步Vulkan pipeline中各个阶段里的资源状态变化。通过这种机制来fine-grained控制command buffer执行过程中资源在pipeline的各个阶段中的流动。</p>
<p>Vulkan通过API vkCmdPipelineBarrier()来控制三种barrier操作，Memory barrier, Buffer Memory barrier和Image Memory barrier。</p>
<p>其中Memory barrier, Buffer Memory barrier会控制资源在pipeline各个阶段的执行次序。其作用有两个，<br>一个作用是控制执行顺序，对写后读(WaR)，读后写(RaW)，写后写(WaW)三种情况提供保护。另外一个作用是保证pipeline不同部分中数据的视图的一致性，因为pipeline不同stage之间可能有cache，在插入了barrier的地方需要flush cache。<br>Image Memory barrier的作用是控制对图像的访问。</p>
<p>三种barrier的数据结构如下所示<br><img src="/2019/03/09/Synchronization-in-Vulkan/pipelinebarrier.png" alt=""></p>
<p>Vulkan的pipeline包括下面这几种,Command的执行从top开始，然后执行类似VS，FS之类的pipeline，最后是bottom。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">TOP_OF_PIPE_BIT</div><div class="line">DRAW_INDIRECT_BIT</div><div class="line">VERTEX_INPUT_BIT</div><div class="line">VERTEX_SHADER_BIT</div><div class="line">TESSELLATION_CONTROL_SHADER_BIT</div><div class="line">TESSELLATION_EVALUATION_SHADER_BIT</div><div class="line">GEOMETRY_SHADER_BIT</div><div class="line">FRAGMENT_SHADER_BIT</div><div class="line">EARLY_FRAGMENT_TESTS_BIT</div><div class="line">LATE_FRAGMENT_TESTS_BIT</div><div class="line">COLOR_ATTACHMENT_OUTPUT_BIT</div><div class="line">TRANSFER_BIT</div><div class="line">COMPUTE_SHADER_BIT</div><div class="line">BOTTOM_OF_PIPE_BIT</div></pre></td></tr></table></figure>
<p>但是如何设置vkCmdPipelineBarrier中source stage和dest stage呢？ </p>
<p>最简单的方式是把source stage设置为VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT，dest stage设置为VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT。<br>这种设置会等待前面command buffer的所有pipeline都执行结束了，后面command buffer才能开始，很明显这种设置多个command buffer没有并行执行，command buffer之间只是串行的，performance应该会受到影响。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/slow-barrier.png" alt=""></p>
<p>如果希望能在多个command buffer之间并行执行，需要根据实际情况设置source stage和dest stage。</p>
<p>假如vertex shader后面接了一个compute shader, compute shader执行的时候需要读取vertex shader的执行结果，<br>我们可以把source stage设置为VK_PIPELINE_STAGE_VERTEX_SHADER_BIT，dest stage设置为VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT。<br>更详细的介绍，请参考后面的代码说明。</p>
<p>原则上source stage和dest stage的设置应该尽量使下图中的ubblocked pipeline(green stages)尽可能地多，这样并行度会越高。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/good-barrier.png" alt=""></p>
<p>Memory barrier示例代码</p>
<p>根据需要，创建两个queue(graphics queue和compute queue)和对应的command buffer.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建graphics queue和command pool</span></div><div class="line">vkGetDeviceQueue(device, vulkanDevice-&gt;queueFamilyIndices.graphics, <span class="number">0</span>, &amp;<span class="built_in">queue</span>);</div><div class="line"></div><div class="line">VkCommandPoolCreateInfo cmdPoolInfo = &#123;&#125;;</div><div class="line">cmdPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</div><div class="line">cmdPoolInfo.queueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics;</div><div class="line">cmdPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</div><div class="line">VK_CHECK_RESULT(vkCreateCommandPool(device, &amp;cmdPoolInfo, <span class="literal">nullptr</span>, &amp;cmdPool));</div><div class="line"></div><div class="line"><span class="comment">// 创建compute queue和command pool</span></div><div class="line">vkGetDeviceQueue(device, vulkanDevice-&gt;queueFamilyIndices.compute, <span class="number">0</span>, &amp;compute.<span class="built_in">queue</span>);</div><div class="line">VkCommandPoolCreateInfo cmdPoolInfo = &#123;&#125;;</div><div class="line">cmdPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</div><div class="line">cmdPoolInfo.queueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute;</div><div class="line">cmdPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</div><div class="line">VK_CHECK_RESULT(vkCreateCommandPool(device, &amp;cmdPoolInfo, <span class="literal">nullptr</span>, &amp;compute.commandPool));</div></pre></td></tr></table></figure></p>
<p>下面的代码说明了如何在这两个command buffer执行的过程中插入barrier, 从而实现资源访问的控制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildComputeCommandBuffer</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	VkCommandBufferBeginInfo cmdBufInfo = vks::initializers::commandBufferBeginInfo();</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkBeginCommandBuffer(compute.commandBuffer, &amp;cmdBufInfo));</div><div class="line"></div><div class="line">	<span class="comment">// Compute particle movement</span></div><div class="line"></div><div class="line">	<span class="comment">// Add memory barrier to ensure that the (graphics) vertex shader has fetched attributes before compute starts to write to the buffer</span></div><div class="line">	VkBufferMemoryBarrier bufferBarrier = vks::initializers::bufferMemoryBarrier();</div><div class="line">	bufferBarrier.buffer = compute.storageBuffer.buffer;</div><div class="line">	bufferBarrier.size = compute.storageBuffer.descriptor.range;</div><div class="line">	bufferBarrier.srcAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;	<span class="comment">// Vertex shader invocations have finished reading from the buffer</span></div><div class="line">	bufferBarrier.dstAccessMask = VK_ACCESS_SHADER_WRITE_BIT; <span class="comment">// Compute shader wants to write to the buffer</span></div><div class="line">	<span class="comment">// Compute and graphics queue may have different queue families (see VulkanDevice::createLogicalDevice)</span></div><div class="line">	<span class="comment">// For the barrier to work across different queues, we need to set their family indices</span></div><div class="line">	bufferBarrier.srcQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics; <span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line">	bufferBarrier.dstQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute; <span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line"></div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		compute.commandBuffer,</div><div class="line">		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;bufferBarrier,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">	vkCmdBindPipeline(compute.commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline);</div><div class="line">	vkCmdBindDescriptorSets(compute.commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;compute.descriptorSet, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Dispatch the compute job</span></div><div class="line">	vkCmdDispatch(compute.commandBuffer, PARTICLE_COUNT / <span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Add memory barrier to ensure that compute shader has finished writing to the buffer</span></div><div class="line">	<span class="comment">// Without this the (rendering) vertex shader may display incomplete results (partial data from last frame) </span></div><div class="line">	bufferBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;  <span class="comment">// Compute shader has finished writes to the buffer</span></div><div class="line">	bufferBarrier.dstAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;	<span class="comment">// Vertex shader invocations want to read from the buffer</span></div><div class="line">	bufferBarrier.buffer = compute.storageBuffer.buffer;</div><div class="line">	bufferBarrier.size = compute.storageBuffer.descriptor.range;</div><div class="line">	<span class="comment">// Compute and graphics queue may have different queue families (see VulkanDevice::createLogicalDevice)</span></div><div class="line">	<span class="comment">// For the barrier to work across different queues, we need to set their family indices</span></div><div class="line">	bufferBarrier.srcQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute;	<span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line">	bufferBarrier.dstQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics;	<span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line"></div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		compute.commandBuffer,</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;bufferBarrier,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">	vkEndCommandBuffer(compute.commandBuffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Image barrier示例代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; drawCmdBuffers.size(); ++i)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// Set target frame buffer</span></div><div class="line">	renderPassBeginInfo.framebuffer = frameBuffers[i];</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkBeginCommandBuffer(drawCmdBuffers[i], &amp;cmdBufInfo));</div><div class="line"></div><div class="line">	<span class="comment">// Image memory barrier to make sure that compute shader writes are finished before sampling from the texture</span></div><div class="line">	VkImageMemoryBarrier imageMemoryBarrier = &#123;&#125;;</div><div class="line">	imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;</div><div class="line">	<span class="comment">// We won't be changing the layout of the image</span></div><div class="line">	imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_GENERAL;</div><div class="line">	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_GENERAL;</div><div class="line">	imageMemoryBarrier.image = textureComputeTarget.image;</div><div class="line">	imageMemoryBarrier.subresourceRange = &#123; VK_IMAGE_ASPECT_COLOR_BIT, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</div><div class="line">	imageMemoryBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;</div><div class="line">	imageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;</div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		drawCmdBuffers[i],</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;imageMemoryBarrier);</div><div class="line">	vkCmdBeginRenderPass(drawCmdBuffers[i], &amp;renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);</div><div class="line"></div><div class="line">	VkViewport viewport = vks::initializers::viewport((<span class="keyword">float</span>)width * <span class="number">0.5f</span>, (<span class="keyword">float</span>)height, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">	vkCmdSetViewport(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;viewport);</div><div class="line"></div><div class="line">	VkRect2D scissor = vks::initializers::rect2D(width, height, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">	vkCmdSetScissor(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;scissor);</div><div class="line"></div><div class="line">	VkDeviceSize offsets[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">	vkCmdBindVertexBuffers(drawCmdBuffers[i], VERTEX_BUFFER_BIND_ID, <span class="number">1</span>, &amp;vertexBuffer.buffer, offsets);</div><div class="line">	vkCmdBindIndexBuffer(drawCmdBuffers[i], indexBuffer.buffer, <span class="number">0</span>, VK_INDEX_TYPE_UINT32);</div><div class="line"></div><div class="line">	<span class="comment">// Left (pre compute)</span></div><div class="line">	vkCmdBindDescriptorSets(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;graphics.descriptorSetPreCompute, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	vkCmdBindPipeline(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline);</div><div class="line"></div><div class="line">	vkCmdDrawIndexed(drawCmdBuffers[i], indexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Right (post compute)</span></div><div class="line">	vkCmdBindDescriptorSets(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;graphics.descriptorSetPostCompute, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	vkCmdBindPipeline(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline);</div><div class="line"></div><div class="line">	viewport.x = (<span class="keyword">float</span>)width / <span class="number">2.0f</span>;</div><div class="line">	vkCmdSetViewport(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;viewport);</div><div class="line">	vkCmdDrawIndexed(drawCmdBuffers[i], indexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	vkCmdEndRenderPass(drawCmdBuffers[i]);</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkEndCommandBuffer(drawCmdBuffers[i]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x22-Semaphore-Event-Fence"><a href="#0x22-Semaphore-Event-Fence" class="headerlink" title="0x22 Semaphore/Event/Fence"></a>0x22 Semaphore/Event/Fence</h2><p>下面说明并行渲染多帧时采用的同步机制。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/frame_sync.png" alt=""></p>
<p>如上图所示，当swap chain中的image可用时，vkAcquireNextImageKHR会触发一个semaphore a，vkQueueSubmit拿到这个semaphore b以后开始执行command buffer的命令，执行command buffer的过程中会往vkAcquireNextImageKHR得到的image(这个image类似于frame buffer的概念)中写内容，执行完毕以后会触发semaphore b, vkQueuePresentKHR等待这个semaphore b触发以后就把image的内容绘制到display上。<br>当第N frame在Submit任务到GPU上执行的时候， (N+1)frame同时在CPU上开启多线程往多个command buffer中生成command，这样CPU和GPU相互配合，提升performance。</p>
<p>下面说明渲染一帧时内部采用的同步机制。<br><img src="/2019/03/09/Synchronization-in-Vulkan/sync-example.png" alt=""></p>
<p>上图中第一个vkQueueSubmit的参数如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</div><div class="line">   <span class="comment">// 执行vkQueueSubmit的wait semaphore，等待其触发，其已经在vkAcquireNextImageKHR中触发</span></div><div class="line">submitInfo.pWaitSemaphores = &amp;semaphores.presentComplete;</div><div class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</div><div class="line">   <span class="comment">// vkQueueSubmit执行完以后的signal semaphore</span></div><div class="line">submitInfo.pSignalSemaphores = &amp;semaphores.renderComplete;</div><div class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</div><div class="line">submitInfo.pCommandBuffers = &amp;primaryCommandBuffer;</div><div class="line"></div><div class="line">VK_CHECK_RESULT(vkQueueSubmit(<span class="built_in">queue</span>, <span class="number">1</span>, &amp;submitInfo, renderFence));</div></pre></td></tr></table></figure></p>
<p>然后执行vKQueuePresentKHR，这边的wait semaphore是前面一步的renderComplete, 表明只有renderComplete被触发以后vKQueuePresentKHR才能被执行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VK_CHECK_RESULT(swapChain.queuePresent(<span class="built_in">queue</span>, currentBuffer, submitTextOverlay ? semaphores.textOverlayComplete : semaphores.renderComplete));</div></pre></td></tr></table></figure></p>
<p>上面虚线部分表明在执行vKQueuePresentKHR之间，还有一个text overlay command buffer需要执行。<br>这个command buffer的wait semaphore为renderComplete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set semaphores</span></div><div class="line"><span class="comment">// Wait for render complete semaphore</span></div><div class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</div><div class="line">submitInfo.pWaitSemaphores = &amp;semaphores.renderComplete;</div><div class="line"><span class="comment">// Signal ready with text overlay complete semaphpre</span></div><div class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</div><div class="line">submitInfo.pSignalSemaphores = &amp;semaphores.textOverlayComplete;</div><div class="line"></div><div class="line"><span class="comment">// Submit current text overlay command buffer</span></div><div class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</div><div class="line">submitInfo.pCommandBuffers = &amp;textOverlay-&gt;cmdBuffers[currentBuffer];</div><div class="line">VK_CHECK_RESULT(vkQueueSubmit(<span class="built_in">queue</span>, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE));</div></pre></td></tr></table></figure>
<h1 id="0x3-References"><a href="#0x3-References" class="headerlink" title="0x3 References"></a>0x3 References</h1><p><a href="https://gpuopen.com/vulkan-barriers-explained/" target="_blank" rel="external">Vulkan barriers explained</a><br><a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/multi-threading-in-vulkan" target="_blank" rel="external">Multi-Threading in Vulkan</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/The-overview-of-AV1-coding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/The-overview-of-AV1-coding/" itemprop="url">The overview of AV1 coding</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T20:00:10+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/02/The-overview-of-AV1-coding/" class="leancloud_visitors" data-flag-title="The overview of AV1 coding">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Overview"><a href="#0x1-Overview" class="headerlink" title="0x1 Overview"></a>0x1 Overview</h1><p>AOMedia Video 1 (AV1) is an open, royalty-free video coding format, it was in particular motivated by the high cost and uncertainty of HEVC patent licensing, it aims to provide royalty-free and high compression ratio video codec.</p>
<p>This blog will give us the overview of AV1 codec, this material is from the internet, you can find the link url in the reference part.</p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/The_Technology_Inside_Av1.svg" alt="ovewview"></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/codec_overview.png" alt="ovewview"></p>
<h1 id="0x2-Partition"><a href="#0x2-Partition" class="headerlink" title="0x2 Partition"></a>0x2 Partition</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/partition1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/partition2.png" alt=""></p>
<h1 id="0x3-Intra-Prediction"><a href="#0x3-Intra-Prediction" class="headerlink" title="0x3 Intra Prediction"></a>0x3 Intra Prediction</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/intra_preditction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/smooth_intra_prediction_modes.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/chroma_from_luma.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/palette_mode.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/intra_block_copying.png" alt=""></p>
<h1 id="0x04-Inter-Prediction"><a href="#0x04-Inter-Prediction" class="headerlink" title="0x04 Inter Prediction"></a>0x04 Inter Prediction</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/inter_prediction1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/inter_prediction2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/extended_reference_frames.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/motion_vector_prediction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/dynamic_motion_vector_referencing.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/obmc.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/masked_compound_prediction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/warped_mc.png" alt=""></p>
<h1 id="0x05-Transform-coding"><a href="#0x05-Transform-coding" class="headerlink" title="0x05 Transform coding"></a>0x05 Transform coding</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/transform1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform_kernel.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform_block_partitioning.png" alt=""></p>
<h1 id="0x06-Quantization"><a href="#0x06-Quantization" class="headerlink" title="0x06 Quantization"></a>0x06 Quantization</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/quantization.png" alt=""></p>
<h1 id="0x7-Entropy-coding"><a href="#0x7-Entropy-coding" class="headerlink" title="0x7 Entropy coding"></a>0x7 Entropy coding</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/entropy_coding1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/entropy_coding2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/av1_symbol_coding.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/level-map coefficient coding.png" alt=""></p>
<h1 id="0x8-Filter"><a href="#0x8-Filter" class="headerlink" title="0x8 Filter"></a>0x8 Filter</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/filtering1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/filtering2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/cdef.png.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_filter.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_filter1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_sp.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/film_grain_synthesis.png" alt=""></p>
<h1 id="0x8-Efficiency-and-Complexity"><a href="#0x8-Efficiency-and-Complexity" class="headerlink" title="0x8 Efficiency and Complexity"></a>0x8 Efficiency and Complexity</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/compression_efficiency.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/coding_complexity.png" alt=""></p>
<h1 id="0x9-Reference"><a href="#0x9-Reference" class="headerlink" title="0x9 Reference"></a>0x9 Reference</h1><p><a href="https://www.youtube.com/watch?v=04lXWMcwdXA&amp;t=822s" target="_blank" rel="external">a technial overview of the AV1</a><br><a href="https://www.youtube.com/watch?v=qubPzBcYCTw&amp;t=1957s" target="_blank" rel="external">The AV1 Video Codec</a><br><a href="https://en.wikipedia.org/wiki/AV1" target="_blank" rel="external">AV1 wiki</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/" itemprop="url">How stencil buffer work in graphics pipeline</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T20:15:30+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/" class="leancloud_visitors" data-flag-title="How stencil buffer work in graphics pipeline">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-总体介绍"><a href="#0x1-总体介绍" class="headerlink" title="0x1 总体介绍"></a>0x1 总体介绍</h1><p>下图是Stencil Test在在post fragment pipeline中的位置。<br><img src="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/post_shader_fragment_pipeline.png" alt="post_shader_fragment_pipeline"></p>
<p>Stencil Test的作用可以把绘制限定在特定的区域，这点和scissor test类似，但是stencil test支持不规则的区域，而scissor test做不到这一点。</p>
<p>Stencil Test是通过stencil buffer中记录的模板信息来完成的，stencil buffer中保存着每个位置的fragment对应的mask值，当graphics pipeline执行stencil test的时候，把通过api设定的模板参考值与相应位置的fragment对应的mask值进行比较，如果不符合条件则被丢弃，反之则进行绘制。</p>
<p>Stencil Test的使用可以看成两步操作，第一步是生成stencil buffer，通过渲染几何体并指定stencil buffer的更新方式来实现。第二步是使用stencil buffer中的内容来控制最终颜色缓存区的渲染。</p>
<h1 id="0x2-从GPU硬件的角度理解Stencil-test"><a href="#0x2-从GPU硬件的角度理解Stencil-test" class="headerlink" title="0x2 从GPU硬件的角度理解Stencil test"></a>0x2 从GPU硬件的角度理解Stencil test</h1><p>下面介绍Stencil test是如何在gpu hardware pipeline中执行的。</p>
<p>下图是broadcom <a href="https://docs.broadcom.com/docs-and-downloads/docs/support/videocore/VideoCoreIV-AG100-R.pdf" target="_blank" rel="external">v3d</a> system block图。</p>
<p>v3d是tile buffer rendering的gpu，其渲染分成两个阶段，第一阶段是计算出每个tile中有哪些triangle需要绘制，第二阶段是遍历所有的tile，对每个tile执行真正的绘制工作。</p>
<p>如下图所示，stencil buffer是gpu hardware中tile buffer的一部分，这是gpu硬件中单独的一块buffer，用来保存当前渲染过程中使用到的stencil值。</p>
<p>在每个tile的绘制过程中，都需要根据tile坐标取得stencil buffer中对应的stencil mask, 然后执行stencil test, 执行完了以后，如果必要，还需要更新stencil buffer中对应的stencil值。</p>
<p><img src="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/v3d_system_block.png" alt="v3d system block"></p>
<h1 id="0x3-Stencil-test测试程序"><a href="#0x3-Stencil-test测试程序" class="headerlink" title="0x3 Stencil test测试程序"></a>0x3 Stencil test测试程序</h1><p>这个Stencil test测试程序分成两步操作。</p>
<p>第一步只是生成stencil buffer的内容，该过程不输出color，只更新stencil buffer的内容。</p>
<p>更新stencil buffer的策略通过下面的api来控制。<br>glStencilOp(GL_KEEP, GL_INCR, GL_INCR);</p>
<p>第一个参数是stencil test fail的时候更新stencil buffer的操作，这里的GL_KEEP表明stencil test fail时不对stencil buffer进行更新。</p>
<p>第二个参数表明stencil test pass但depth test fail的时候更新stencil buffer的操作，这里的GL_INCR表明此时对stencil buffer的相应位加1.</p>
<p>第三个参数表明stencil test pass而且depth test pass的时候更新stencil buffer的操作，这里的GL_INCR表明此时对stencil buffer的相应位加1.</p>
<p>以上的设置表明只要stencil test pass的话就对stencil buffer的相应位加1，不管depth test是pass或者fail.</p>
<p>绘制triangle1的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">glEnable(GL_STENCIL_TEST);</div><div class="line">glStencilFunc(GL_ALWAYS, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">glStencilOp(GL_KEEP, GL_INCR, GL_INCR);</div><div class="line">glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);</div><div class="line"></div><div class="line">glUseProgram(gProgram);</div><div class="line"></div><div class="line"><span class="comment">// draw triangle 1</span></div><div class="line">glVertexAttribPointer(gfPositionHandle, <span class="number">3</span>, GL_FLOAT, GL_FALSE,</div><div class="line">	TRIANGLE_VERTICES_DATA_STRIDE_BYTES, gTriangleVerticesData);</div><div class="line"></div><div class="line">glEnableVertexAttribArray(gfPositionHandle);</div><div class="line"></div><div class="line">glUniform4fv(gfColor, <span class="number">1</span>, gColor);</div><div class="line"></div><div class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>绘制triangle2的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// draw triangl2</span></div><div class="line">glVertexAttribPointer(gfPositionHandle, <span class="number">3</span>, GL_FLOAT, GL_FALSE,</div><div class="line">	TRIANGLE_VERTICES_DATA_STRIDE_BYTES, gTriangleVerticesData1);</div><div class="line"></div><div class="line">glEnableVertexAttribArray(gfPositionHandle);</div><div class="line"></div><div class="line">glUniform4fv(gfColor, <span class="number">1</span>, gColor1);</div><div class="line"></div><div class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>第二步是根据stencil buffer中的内容为mask来绘制triangle1和triangle2的重叠区域，这个时候发送给opengles的绘制区域可以设置成整个屏幕的大小，但是只有相应的位符合stencil buffer中的条件才能使stencil test通过，这个时候才能输出color。</p>
<p>这个控制相应的位符合stencil buffer中条件的代码如下所示，也就是说stencil buffer相应的位的值需要为0x02，也就是说这个点绘制过两次（triangle1和triangle2都绘制过）。</p>
<p>glStencilFunc(GL_NOTEQUAL, 0, 0xf8 | 0x02);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">glDisable(GL_DEPTH_TEST);</div><div class="line"></div><div class="line">glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);</div><div class="line"></div><div class="line">glVertexAttribPointer(gfPositionHandle, <span class="number">3</span>, GL_FLOAT, GL_FALSE,</div><div class="line">	TRIANGLE_VERTICES_DATA_STRIDE_BYTES, gTriangleVerticesData2);</div><div class="line"></div><div class="line">glEnableVertexAttribArray(gfPositionHandle);</div><div class="line"></div><div class="line">glUniform4fv(gfColor, <span class="number">1</span>, gColor2);</div><div class="line"></div><div class="line"><span class="comment">// draw the area with blue color</span></div><div class="line">glColorMask(GL_FALSE, GL_FALSE, GL_TRUE, GL_FALSE);</div><div class="line">glStencilFunc(GL_NOTEQUAL, <span class="number">0</span>, <span class="number">0xf8</span> | <span class="number">0x02</span>);</div><div class="line">  </div><div class="line">glDrawArrays(GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<h1 id="0x4-程序运行效果"><a href="#0x4-程序运行效果" class="headerlink" title="0x4 程序运行效果"></a>0x4 程序运行效果</h1><p>triangle1单独绘制的效果<br><img src="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/draw_triangle1.png" alt="draw_triangle1"></p>
<p>triangle2单独绘制的效果<br><img src="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/draw_triangle2.png" alt="draw_triangle2"></p>
<p>triangle1和triangle2同时绘制的效果<br><img src="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/draw_triangle1_triangle2.png" alt="draw_triangle1_triangle2"></p>
<p>triangle1和triangle2同时绘制但不更新color buffer, 然后根据stencil buffer绘制triangle1和triangle2相交区域的效果<br><img src="/2019/02/23/How-stencil-buffer_work-in-graphics-pipeline/drawing_with_stencil_buffer.png" alt="drawing_with_stencil_buffer"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/16/Mesh-support-in-Escher/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/16/Mesh-support-in-Escher/" itemprop="url">Mesh support in escher</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-16T23:21:36+08:00">
                2019-02-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/02/16/Mesh-support-in-Escher/" class="leancloud_visitors" data-flag-title="Mesh support in escher">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-总体介绍"><a href="#0x1-总体介绍" class="headerlink" title="0x1 总体介绍"></a>0x1 总体介绍</h1><p>Graphics中各种图形的渲染是通过许多小的三角形的渲染拼接组成的，Mesh的过程是把需要渲染的图形划分成许多小三角形的过程.<br>Escher中的mesh过程需要把Rectangle, Circle, Ring, Sphere等形状的显示对象划分成小三角形，然后把小三角形的数据通过Vulkan API来驱动GPU显示.</p>
<p>下图是escher中mesh相关类的类图</p>
<p><img src="/2019/02/16/Mesh-support-in-Escher/mesh_class_diagram.png" alt="mesh_class_diagram"></p>
<p>下面简单介绍一下这些类</p>
<p>Mesh创建过程中，<br>MeshBuilder根据MeshSpec的设置生成对应的Mesh.<br>Mesh的vertex/index数据保存到CommandBuffer中，</p>
<p>Mesh渲染过程中，<br>对应的PageRenderer生成对应的Object，每一个Object都有对应的Mesh，这些Object挂接到Model下面.<br>然后根据Model中包含的Mesh生成ModelDisplayList，然后遍历这个ModelDisplayList，把Mesh中的vertex/index数据传入CommandBuffer中，从而让GPU渲染的时候能够访问到这些数据.</p>
<h1 id="0x2-各种shape的mesh过程"><a href="#0x2-各种shape的mesh过程" class="headerlink" title="0x2 各种shape的mesh过程"></a>0x2 各种shape的mesh过程</h1><h2 id="0x21-MeshBuilder介绍"><a href="#0x21-MeshBuilder介绍" class="headerlink" title="0x21 MeshBuilder介绍"></a>0x21 MeshBuilder介绍</h2><p>MeshBuilder提供接口把vertex data和index data保存起来.</p>
<p>其中保存的数据结构如下,<br>vertex_staging<em>buffer</em>保存vertex数据，index_staging<em>buffer</em>保存index数据.<br>vertex_staging<em>buffer</em>和index_staging<em>buffer</em>的内存空间是通过GpuUploader::Writer来分配的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> max_vertex_count_;</div><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> max_index_count_;</div><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> vertex_stride_;</div><div class="line"><span class="keyword">uint8_t</span>* vertex_staging_buffer_;</div><div class="line"><span class="keyword">uint32_t</span>* index_staging_buffer_;</div><div class="line"><span class="keyword">size_t</span> vertex_count_ = <span class="number">0</span>;</div><div class="line"><span class="keyword">size_t</span> index_count_ = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>下面是其提供设置vertex data和index data的接口.<br>注意下面的接口都返回 *this， 这是为了链式表达式的需要.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> MeshBuilder&amp; MeshBuilder::AddIndex(<span class="keyword">uint32_t</span> index) &#123;</div><div class="line">  FXL_DCHECK(index_count_ &lt; max_index_count_);</div><div class="line">  index_staging_buffer_[index_count_++] = index;</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> MeshBuilder&amp; MeshBuilder::AddVertexData(<span class="keyword">const</span> <span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size) &#123;</div><div class="line">  FXL_DCHECK(vertex_count_ &lt; max_vertex_count_);</div><div class="line">  FXL_DCHECK(size &lt;= vertex_stride_);</div><div class="line">  <span class="keyword">size_t</span> offset = vertex_stride_ * vertex_count_++;</div><div class="line">  <span class="built_in">memcpy</span>(vertex_staging_buffer_ + offset, ptr, size);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VertexT&gt;</div><div class="line">MeshBuilder&amp; MeshBuilder::AddVertex(<span class="keyword">const</span> VertexT&amp; v) &#123;</div><div class="line">  AddVertexData(&amp;v, <span class="keyword">sizeof</span>(VertexT));</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后调用Build()接口生成mesh对象.</p>
<h2 id="0x22-SimpleRectangle"><a href="#0x22-SimpleRectangle" class="headerlink" title="0x22 SimpleRectangle"></a>0x22 SimpleRectangle</h2><p>下面是生成SimpleRectangle的mesh的代码，SimpleRectangle是普通的非圆角Rectangle.<br>从这个代码中可以看到，该mesh过程会生成4个vertex数据，生成6个index数据(因为是2个三角形).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">MeshPtr <span class="title">NewSimpleRectangleMesh</span><span class="params">(MeshBuilderFactory* factory)</span> </span>&#123;</div><div class="line">  MeshSpec spec&#123;MeshAttribute::kPosition2D | MeshAttribute::kUV&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// In each vertex, the first two floats represent the position and the second</span></div><div class="line">  <span class="comment">// two are UV coordinates.</span></div><div class="line">  <span class="function">vec4 <span class="title">v0</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</div><div class="line">  <span class="function">vec4 <span class="title">v1</span><span class="params">(<span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>)</span></span>;</div><div class="line">  <span class="function">vec4 <span class="title">v2</span><span class="params">(<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>)</span></span>;</div><div class="line">  <span class="function">vec4 <span class="title">v3</span><span class="params">(<span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>)</span></span>;</div><div class="line"></div><div class="line">  MeshBuilderPtr builder = factory-&gt;NewMeshBuilder(spec, <span class="number">4</span>, <span class="number">6</span>);</div><div class="line">  <span class="keyword">return</span> builder-&gt;AddVertex(v0)</div><div class="line">      .AddVertex(v1)</div><div class="line">      .AddVertex(v2)</div><div class="line">      .AddVertex(v3)</div><div class="line">      .AddIndex(<span class="number">0</span>)</div><div class="line">      .AddIndex(<span class="number">1</span>)</div><div class="line">      .AddIndex(<span class="number">2</span>)</div><div class="line">      .AddIndex(<span class="number">0</span>)</div><div class="line">      .AddIndex(<span class="number">2</span>)</div><div class="line">      .AddIndex(<span class="number">3</span>)</div><div class="line">      .Build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面的mesh过程计算好了一个通用的SimpleRectangle的mesh信息，<br>具体要显示Rectangle的时候根据具体的显示位置(top_left_position.x/y/z)和显示的大小(size.x/y)来绘制Rectangle.<br>指定显示的位置可以理解为平移，指定显示的大小可以理解为缩放.<br>这个平移/缩放过程通过设置transform矩阵来实现，在shader代码中把这个矩阵和通用SimpleRectangle的vertex坐标相乘.</p>
<p>transform矩阵的设置过程如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Object Object::NewRect(<span class="keyword">const</span> vec3&amp; top_left_position, <span class="keyword">const</span> vec2&amp; size,</div><div class="line">                       MaterialPtr material) &#123;</div><div class="line">  <span class="function">mat4 <span class="title">transform</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">  transform[<span class="number">0</span>][<span class="number">0</span>] = size.x;</div><div class="line">  transform[<span class="number">1</span>][<span class="number">1</span>] = size.y;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">0</span>] = top_left_position.x;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">1</span>] = top_left_position.y;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">2</span>] = top_left_position.z;</div><div class="line">  <span class="keyword">return</span> Object(transform, Shape(Shape::Type::kRect), <span class="built_in">std</span>::move(material));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x23-Rectangle"><a href="#0x23-Rectangle" class="headerlink" title="0x23 Rectangle"></a>0x23 Rectangle</h2><p>下面的代码生成普通Rectangle的Mesh，</p>
<p>下面函数的参数中，<br>subdivisions指定Rectangle的拆分数，<br>size指定Rectangle的大小，<br>top_left指定左上角的坐标，<br>生成mesh的时候把Rectangle分成(subdivisions*2-1)个小矩形，指定这些小矩形的vertex/index设置.</p>
<p>这个普通Rectangle的mesh和SimpleRectangle的mesh不同之处在于普通Rectangle的mesh是每一个Rectangle生成一个，不具有SimpleRectangle的mesh的通用性. 另外普通Rectangle的mesh会包括更多的小三角形.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function">MeshPtr <span class="title">NewRectangleMesh</span><span class="params">(MeshBuilderFactory* factory, <span class="keyword">const</span> MeshSpec&amp; spec,</span></span></div><div class="line">                         <span class="keyword">int</span> subdivisions, vec2 size, vec2 top_left,</div><div class="line">                         <span class="keyword">float</span> top_offset_magnitude,</div><div class="line">                         <span class="keyword">float</span> bottom_offset_magnitude) &#123;</div><div class="line">  <span class="comment">// Compute the number of vertices in the tessellated circle.</span></div><div class="line">  FXL_DCHECK(subdivisions &gt;= <span class="number">0</span>);</div><div class="line">  <span class="keyword">size_t</span> vertices_per_side = <span class="number">2</span>;</div><div class="line">  <span class="keyword">while</span> (subdivisions-- &gt; <span class="number">0</span>) &#123;</div><div class="line">    vertices_per_side *= <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">size_t</span> vertex_count = vertices_per_side * <span class="number">2</span>;</div><div class="line">  <span class="keyword">size_t</span> index_count = (vertices_per_side - <span class="number">1</span>) * <span class="number">6</span>;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> builder = factory-&gt;NewMeshBuilder(spec, vertex_count, index_count);</div><div class="line"></div><div class="line">  <span class="comment">// Generate vertex positions.</span></div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kMaxVertexSize = <span class="number">100</span>;</div><div class="line">  <span class="keyword">uint8_t</span> vertex[kMaxVertexSize];</div><div class="line">  <span class="keyword">auto</span> vertex_p =</div><div class="line">      GetVertexAttributePointers(vertex, kMaxVertexSize, spec, builder);</div><div class="line">  FXL_CHECK(vertex_p.pos2);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">float</span> vertices_per_side_reciprocal = <span class="number">1.f</span> / (vertices_per_side - <span class="number">1</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; vertices_per_side; ++i) &#123;</div><div class="line">    <span class="comment">// Build bottom vertex.</span></div><div class="line">    (*vertex_p.pos2) =</div><div class="line">        top_left + vec2(size.x * i * vertices_per_side_reciprocal, size.y);</div><div class="line">    <span class="keyword">if</span> (vertex_p.uv)</div><div class="line">      (*vertex_p.uv) = vec2(i * vertices_per_side_reciprocal, <span class="number">1.f</span>);</div><div class="line">    <span class="keyword">if</span> (vertex_p.pos_offset)</div><div class="line">      (*vertex_p.pos_offset) = vec2(<span class="number">0</span>, <span class="number">1.f</span> * bottom_offset_magnitude);</div><div class="line">    <span class="keyword">if</span> (vertex_p.perim)</div><div class="line">      (*vertex_p.perim) = i * vertices_per_side_reciprocal;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line"></div><div class="line">    <span class="comment">// Build top vertex.</span></div><div class="line">    (*vertex_p.pos2) =</div><div class="line">        top_left + vec2(size.x * i * vertices_per_side_reciprocal, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (vertex_p.uv)</div><div class="line">      (*vertex_p.uv) = vec2(i * vertices_per_side_reciprocal, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (vertex_p.pos_offset)</div><div class="line">      (*vertex_p.pos_offset) = vec2(<span class="number">0</span>, <span class="number">-1.f</span> * top_offset_magnitude);</div><div class="line">    <span class="keyword">if</span> (vertex_p.perim)</div><div class="line">      (*vertex_p.perim) = i * vertices_per_side_reciprocal;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate vertex indices.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">2</span>; i &lt; vertex_count; i += <span class="number">2</span>) &#123;</div><div class="line">    builder-&gt;AddIndex(i - <span class="number">2</span>);</div><div class="line">    builder-&gt;AddIndex(i - <span class="number">1</span>);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">    builder-&gt;AddIndex(i - <span class="number">1</span>);</div><div class="line">    builder-&gt;AddIndex(i + <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> mesh = builder-&gt;Build();</div><div class="line">  FXL_DCHECK(mesh-&gt;num_indices() == index_count);</div><div class="line">  <span class="keyword">return</span> mesh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x24-Circle"><a href="#0x24-Circle" class="headerlink" title="0x24 Circle"></a>0x24 Circle</h2><p>下面分析circle的mesh是如何生成的.</p>
<p>下面函数的参数中，<br>subdivisions指定Circle的拆分数目，<br>center指定Circle的中心点坐标.<br>radius指定Circle的半径大小.</p>
<p>生成mesh的时候是把Circle分成(subdivisions*4)个小扇形，然后计算这些小扇形的vertex/index设置.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">MeshPtr NewCircleMesh(MeshBuilderFactory* factory, const MeshSpec&amp; spec,</div><div class="line">                      int subdivisions, vec2 center, float radius,</div><div class="line">                      float offset_magnitude) &#123;</div><div class="line">  // Compute the number of vertices in the tessellated circle.</div><div class="line">  FXL_DCHECK(subdivisions &gt;= 0);</div><div class="line">  FXL_DCHECK(spec.IsValidOneBufferMesh());</div><div class="line">  size_t outer_vertex_count = 4;</div><div class="line">  while (subdivisions-- &gt; 0) &#123;</div><div class="line">    outer_vertex_count *= 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  size_t vertex_count = outer_vertex_count + 1;  // Add 1 for center vertex.</div><div class="line">  size_t index_count = outer_vertex_count * 3;</div><div class="line"></div><div class="line">  auto builder = factory-&gt;NewMeshBuilder(spec, vertex_count, index_count);</div><div class="line"></div><div class="line">  // Generate vertex positions.</div><div class="line">  constexpr size_t kMaxVertexSize = 100;</div><div class="line">  uint8_t vertex[kMaxVertexSize];</div><div class="line">  auto vertex_p =</div><div class="line">      GetVertexAttributePointers(vertex, kMaxVertexSize, spec, builder);</div><div class="line"></div><div class="line">  // Build center vertex.</div><div class="line">  FXL_CHECK(vertex_p.pos2);</div><div class="line">  (*vertex_p.pos2) = center;</div><div class="line">  if (vertex_p.uv)</div><div class="line">    (*vertex_p.uv) = vec2(0.5f, 0.5f);</div><div class="line">  if (vertex_p.pos_offset)</div><div class="line">    (*vertex_p.pos_offset) = vec2(0.f, 0.f);</div><div class="line">  // TODO: This is an undesirable singularity.  Perhaps it would be better to</div><div class="line">  // treat circles as a ring with inner radius of zero?</div><div class="line">  if (vertex_p.perim)</div><div class="line">    (*vertex_p.perim) = 0.f;</div><div class="line">  builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line"></div><div class="line">  // Outer vertices.</div><div class="line">  const float outer_vertex_count_reciprocal = 1.f / outer_vertex_count;</div><div class="line">  const float radian_step = 2 * M_PI / outer_vertex_count;</div><div class="line">  for (size_t i = 0; i &lt; outer_vertex_count; ++i) &#123;</div><div class="line">    float radians = i * radian_step;</div><div class="line"></div><div class="line">    // Direction of the current vertex from the center of the circle.</div><div class="line">    vec2 dir(sin(radians), cos(radians));</div><div class="line"></div><div class="line">    (*vertex_p.pos2) = dir * radius + center;</div><div class="line">    if (vertex_p.uv)</div><div class="line">      (*vertex_p.uv) = 0.5f * (dir + vec2(1.f, 1.f));</div><div class="line">    if (vertex_p.pos_offset)</div><div class="line">      (*vertex_p.pos_offset) = dir * offset_magnitude;</div><div class="line">    if (vertex_p.perim)</div><div class="line">      (*vertex_p.perim) = i * outer_vertex_count_reciprocal;</div><div class="line"></div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Vertex indices.</div><div class="line">  for (size_t i = 1; i &lt; outer_vertex_count; ++i) &#123;</div><div class="line">    builder-&gt;AddIndex(0);</div><div class="line">    builder-&gt;AddIndex(i + 1);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">  &#125;</div><div class="line">  builder-&gt;AddIndex(0);</div><div class="line">  builder-&gt;AddIndex(1);</div><div class="line">  builder-&gt;AddIndex(outer_vertex_count);</div><div class="line"></div><div class="line">  auto mesh = builder-&gt;Build();</div><div class="line">  FXL_DCHECK(mesh-&gt;num_indices() == index_count);</div><div class="line">  FXL_DCHECK(mesh-&gt;bounding_box() ==</div><div class="line">             BoundingBox(vec3(center.x - radius, center.y - radius, 0),</div><div class="line">                         vec3(center.x + radius, center.y + radius, 0)));</div><div class="line">  return mesh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面的mesh过程计算好了一个通用的Circle的mesh信息，<br>和SimpleRectangle的情况类似，具体绘制Circle的时候根据具体的显示位置(center_position.x/y/z)和显示的大小(radius)来绘制Circle.<br>指定显示的位置可以理解为平移，指定显示的大小可以理解为缩放.<br>这个平移/缩放过程也是通过设置transform矩阵来实现，在shader代码中把这个矩阵和通用Circle的vertex坐标相乘.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Object Object::NewCircle(<span class="keyword">const</span> vec3&amp; center_position, <span class="keyword">float</span> radius,</div><div class="line">                         MaterialPtr material) &#123;</div><div class="line">  <span class="function">mat4 <span class="title">transform</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">  transform[<span class="number">0</span>][<span class="number">0</span>] = radius;</div><div class="line">  transform[<span class="number">1</span>][<span class="number">1</span>] = radius;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">0</span>] = center_position.x;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">1</span>] = center_position.y;</div><div class="line">  transform[<span class="number">3</span>][<span class="number">2</span>] = center_position.z;</div><div class="line">  <span class="keyword">return</span> Object(transform, Shape(Shape::Type::kCircle), <span class="built_in">std</span>::move(material));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x25-RoundRectangle"><a href="#0x25-RoundRectangle" class="headerlink" title="0x25 RoundRectangle"></a>0x25 RoundRectangle</h2><p>下面分析生成圆角Rectangle的mesh的代码.</p>
<p>该过程把圆角矩形mesh成三角形，其中的顶点分布如下图所示,</p>
<p>其中每个圆角部分被拆分成8个小扇形.</p>
<p><img src="/2019/02/16/Mesh-support-in-Escher/roundedrect.jpg" alt="RoundedRect"></p>
<p>0 ~ 12 顶点是中间部分的矩形对应的顶点.<br>13 ~ 19 顶点是左上角部分的圆角对应的顶点.<br>20 ~ 26 顶点是右上角部分的圆角对应的顶点.<br>27 ~ 33 顶点是右下角部分的圆角对应的顶点.<br>34 ~ 40 顶点是左下角部分的圆角对应的顶点.</p>
<p>NewRoundedRect是总的入口函数，其中会调用GenerateRoundedRectIndices()来根据顶点来构造三角形，调用GenerateRoundedRectVertexUVs()生成纹理坐标，最后调用GenerateRoundedRectVertexPositionsFromUVs()来生成顶点坐标.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">MeshPtr RoundedRectFactory::NewRoundedRect(</div><div class="line">    <span class="keyword">const</span> RoundedRectSpec&amp; spec, <span class="keyword">const</span> MeshSpec&amp; mesh_spec,</div><div class="line">    BatchGpuUploader* batch_gpu_uploader) &#123;</div><div class="line">  FXL_DCHECK(batch_gpu_uploader);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> index_buffer = GetIndexBuffer(spec, mesh_spec, batch_gpu_uploader);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> counts = GetRoundedRectMeshVertexAndIndexCounts(spec);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> vertex_count = counts.first;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> index_count = counts.second;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> primary_buffer_stride = mesh_spec.stride(<span class="number">0</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> secondary_buffer_stride = mesh_spec.stride(<span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> vertex_buffer_size =</div><div class="line">      vertex_count * (primary_buffer_stride + secondary_buffer_stride);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> vertex_buffer =</div><div class="line">      buffer_factory_.NewBuffer(vertex_buffer_size,</div><div class="line">                                vk::BufferUsageFlagBits::eVertexBuffer |</div><div class="line">                                    vk::BufferUsageFlagBits::eTransferDst,</div><div class="line">                                vk::MemoryPropertyFlagBits::eDeviceLocal);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> bounding_box =</div><div class="line">      BoundingBox::NewChecked(<span class="number">-0.5f</span> * vec3(spec.width, spec.height, <span class="number">0</span>),</div><div class="line">                              <span class="number">0.5f</span> * vec3(spec.width, spec.height, <span class="number">0</span>), <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (mesh_spec.vertex_buffer_count()) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</div><div class="line">      <span class="keyword">auto</span> writer = batch_gpu_uploader-&gt;AcquireWriter(vertex_buffer_size);</div><div class="line">      GenerateRoundedRectVertices(spec, mesh_spec, writer-&gt;host_ptr(),</div><div class="line">                                  writer-&gt;size());</div><div class="line">      writer-&gt;WriteBuffer(vertex_buffer, &#123;<span class="number">0</span>, <span class="number">0</span>, vertex_buffer-&gt;size()&#125;);</div><div class="line">      batch_gpu_uploader-&gt;PostWriter(<span class="built_in">std</span>::move(writer));</div><div class="line"></div><div class="line">      <span class="keyword">return</span> fxl::MakeRefCounted&lt;Mesh&gt;(</div><div class="line">          <span class="keyword">static_cast</span>&lt;ResourceRecycler*&gt;(<span class="keyword">this</span>), mesh_spec, bounding_box,</div><div class="line">          vertex_count, index_count, vertex_buffer, <span class="built_in">std</span>::move(index_buffer));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</div><div class="line">      <span class="keyword">auto</span> writer = batch_gpu_uploader-&gt;AcquireWriter(vertex_buffer_size);</div><div class="line">      GenerateRoundedRectVertices(</div><div class="line">          spec, mesh_spec, writer-&gt;host_ptr(),</div><div class="line">          vertex_count * primary_buffer_stride,</div><div class="line">          writer-&gt;host_ptr() + vertex_count * primary_buffer_stride,</div><div class="line">          vertex_count * secondary_buffer_stride);</div><div class="line">      writer-&gt;WriteBuffer(vertex_buffer, &#123;<span class="number">0</span>, <span class="number">0</span>, vertex_buffer-&gt;size()&#125;);</div><div class="line">      batch_gpu_uploader-&gt;PostWriter(<span class="built_in">std</span>::move(writer));</div><div class="line"></div><div class="line">      <span class="keyword">return</span> fxl::MakeRefCounted&lt;Mesh&gt;(</div><div class="line">          <span class="keyword">static_cast</span>&lt;ResourceRecycler*&gt;(<span class="keyword">this</span>), mesh_spec, bounding_box,</div><div class="line">          index_count, <span class="built_in">std</span>::move(index_buffer), <span class="number">0</span>, vertex_count, vertex_buffer,</div><div class="line">          <span class="number">0</span>, <span class="built_in">std</span>::move(vertex_buffer), vertex_count * primary_buffer_stride);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      FXL_CHECK(<span class="literal">false</span>) &lt;&lt; <span class="string">"unsupported vertex buffer count: "</span></div><div class="line">                       &lt;&lt; mesh_spec.vertex_buffer_count();</div><div class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的代码是构造圆角Rectangle中的三角形的过程，indices中保存的是把这些顶点拼接成三角形的顶点索引.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateRoundedRectIndices</span><span class="params">(<span class="keyword">const</span> RoundedRectSpec&amp; spec,</span></span></div><div class="line">                                <span class="keyword">const</span> MeshSpec&amp; mesh_spec, <span class="keyword">void</span>* indices_out,</div><div class="line">                                <span class="keyword">uint32_t</span> max_bytes) &#123;</div><div class="line">  TRACE_DURATION(<span class="string">"gfx"</span>, <span class="string">"escher::GenerateRoundedRectIndices"</span>);</div><div class="line"></div><div class="line">  FXL_DCHECK(max_bytes &gt;= kIndexCount * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</div><div class="line">  <span class="keyword">uint32_t</span>* indices = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;(indices_out);</div><div class="line"></div><div class="line">  <span class="comment">// Central square triangles.</span></div><div class="line">  indices[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">  indices[<span class="number">1</span>] = <span class="number">4</span>;</div><div class="line">  indices[<span class="number">2</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">3</span>] = <span class="number">0</span>;</div><div class="line">  indices[<span class="number">4</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">5</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">6</span>] = <span class="number">0</span>;</div><div class="line">  indices[<span class="number">7</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">8</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">9</span>] = <span class="number">0</span>;</div><div class="line">  indices[<span class="number">10</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">11</span>] = <span class="number">4</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "Cross arm 1"  triangles.</span></div><div class="line">  indices[<span class="number">12</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">13</span>] = <span class="number">7</span>;</div><div class="line">  indices[<span class="number">14</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">15</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">16</span>] = <span class="number">6</span>;</div><div class="line">  indices[<span class="number">17</span>] = <span class="number">7</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "Cross arm 2"  triangles.</span></div><div class="line">  indices[<span class="number">18</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">19</span>] = <span class="number">9</span>;</div><div class="line">  indices[<span class="number">20</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">21</span>] = <span class="number">2</span>;</div><div class="line">  indices[<span class="number">22</span>] = <span class="number">8</span>;</div><div class="line">  indices[<span class="number">23</span>] = <span class="number">9</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "Cross arm 3"  triangles.</span></div><div class="line">  indices[<span class="number">24</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">25</span>] = <span class="number">11</span>;</div><div class="line">  indices[<span class="number">26</span>] = <span class="number">4</span>;</div><div class="line">  indices[<span class="number">27</span>] = <span class="number">3</span>;</div><div class="line">  indices[<span class="number">28</span>] = <span class="number">10</span>;</div><div class="line">  indices[<span class="number">29</span>] = <span class="number">11</span>;</div><div class="line"></div><div class="line">  <span class="comment">// "Cross arm 4"  triangles.</span></div><div class="line">  indices[<span class="number">30</span>] = <span class="number">4</span>;</div><div class="line">  indices[<span class="number">31</span>] = <span class="number">5</span>;</div><div class="line">  indices[<span class="number">32</span>] = <span class="number">1</span>;</div><div class="line">  indices[<span class="number">33</span>] = <span class="number">4</span>;</div><div class="line">  indices[<span class="number">34</span>] = <span class="number">12</span>;</div><div class="line">  indices[<span class="number">35</span>] = <span class="number">5</span>;</div><div class="line"></div><div class="line">  <span class="comment">// WARNING: here's where it gets confusing; the number of indices generated is</span></div><div class="line">  <span class="comment">// dependent on kCornerDivisions.</span></div><div class="line"></div><div class="line">  <span class="comment">// We've already generated output indices for the "cross triangles".</span></div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kCrossTriangles = <span class="number">12</span>;</div><div class="line">  <span class="comment">// Holds the position of the next index to output.</span></div><div class="line">  <span class="keyword">uint32_t</span> out = kCrossTriangles * <span class="number">3</span>;</div><div class="line">  <span class="comment">// Holds the highest index of any vertex used thus far (the central "cross"</span></div><div class="line">  <span class="comment">// consists of 13 vertices, whose indices are 0-12).</span></div><div class="line">  <span class="keyword">uint32_t</span> highest_index = <span class="number">12</span>;</div><div class="line"></div><div class="line">  <span class="comment">// These are the indices of the 4 triangles that would be output if</span></div><div class="line">  <span class="comment">// kCornerDivisions were zero.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> corner_tris[] = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">11</span>&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// For each corner, generate wedges in clockwise order.</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> corner = <span class="number">0</span>; corner &lt; <span class="number">4</span>; ++corner) &#123;</div><div class="line">    <span class="comment">// Index of the vertex at the center of the current corner.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> center = corner_tris[corner * <span class="number">3</span>];</div><div class="line">    <span class="comment">// As we move clockwise around the corner, this holds the index of the</span></div><div class="line">    <span class="comment">// previous perimeter vertex.</span></div><div class="line">    <span class="keyword">uint32_t</span> prev = corner_tris[corner * <span class="number">3</span> + <span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">      indices[out++] = center;</div><div class="line">      indices[out++] = prev;</div><div class="line">      indices[out++] = prev = ++highest_index;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// One last triangle (or the only one, if kCornerDivisions == 0).</span></div><div class="line">    indices[out++] = center;</div><div class="line">    indices[out++] = prev;</div><div class="line">    indices[out++] = corner_tris[corner * <span class="number">3</span> + <span class="number">1</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  FXL_DCHECK(out == kIndexCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面函数计算这些点(0 ~ 40)对应的纹理(uv)坐标.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VertT&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateRoundedRectVertexUVs</span><span class="params">(<span class="keyword">const</span> RoundedRectSpec&amp; spec, VertT* verts)</span> </span>&#123;</div><div class="line">  TRACE_DURATION(<span class="string">"gfx"</span>, <span class="string">"escher::GenerateRoundedRectVertexUVs"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">float</span> width = spec.width;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">float</span> height = spec.height;</div><div class="line"></div><div class="line">  <span class="comment">// First compute UV coordinates of the four "corner centers".</span></div><div class="line">  verts[<span class="number">1</span>].uv =</div><div class="line">      vec2(spec.top_left_radius / width, spec.top_left_radius / height);</div><div class="line">  verts[<span class="number">2</span>].uv =</div><div class="line">      vec2(<span class="number">1.f</span> - spec.top_right_radius / width, spec.top_right_radius / height);</div><div class="line">  verts[<span class="number">3</span>].uv = vec2(<span class="number">1.f</span> - spec.bottom_right_radius / width,</div><div class="line">                     <span class="number">1.f</span> - spec.bottom_right_radius / height);</div><div class="line">  verts[<span class="number">4</span>].uv = vec2(spec.bottom_left_radius / width,</div><div class="line">                     <span class="number">1.f</span> - spec.bottom_left_radius / height);</div><div class="line"></div><div class="line">  <span class="comment">// The "center" vertex is the average of the four "corner centers".</span></div><div class="line">  verts[<span class="number">0</span>].uv =</div><div class="line">      <span class="number">0.25f</span> * ((verts[<span class="number">1</span>].uv + verts[<span class="number">2</span>].uv + verts[<span class="number">3</span>].uv + verts[<span class="number">4</span>].uv));</div><div class="line"></div><div class="line">  <span class="comment">// Next, compute UV coords for the 8 vertices where the rounded corners meet</span></div><div class="line">  <span class="comment">// the straight side sections.</span></div><div class="line">  verts[<span class="number">6</span>].uv = vec2(verts[<span class="number">1</span>].uv.x, <span class="number">0.f</span>);</div><div class="line">  verts[<span class="number">7</span>].uv = vec2(verts[<span class="number">2</span>].uv.x, <span class="number">0.f</span>);</div><div class="line">  verts[<span class="number">8</span>].uv = vec2(<span class="number">1.f</span>, verts[<span class="number">2</span>].uv.y);</div><div class="line">  verts[<span class="number">9</span>].uv = vec2(<span class="number">1.f</span>, verts[<span class="number">3</span>].uv.y);</div><div class="line">  verts[<span class="number">10</span>].uv = vec2(verts[<span class="number">3</span>].uv.x, <span class="number">1.f</span>);</div><div class="line">  verts[<span class="number">11</span>].uv = vec2(verts[<span class="number">4</span>].uv.x, <span class="number">1.f</span>);</div><div class="line">  verts[<span class="number">12</span>].uv = vec2(<span class="number">0.f</span>, verts[<span class="number">4</span>].uv.y);</div><div class="line">  verts[<span class="number">5</span>].uv = vec2(<span class="number">0.f</span>, verts[<span class="number">1</span>].uv.y);</div><div class="line"></div><div class="line">  <span class="comment">// Next, compute UV coords for the vertices that make up the rounded corners.</span></div><div class="line">  <span class="comment">// We start at index 13; indices 0-12 were computed above.</span></div><div class="line">  <span class="keyword">uint32_t</span> out = <span class="number">13</span>;</div><div class="line"></div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">float</span> kPI = <span class="number">3.14159265f</span>;</div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">float</span> kAngleStep = kPI / <span class="number">2</span> / (kCornerDivisions + <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Generate UV coordinates for top-left corner.</span></div><div class="line">  <span class="keyword">float</span> angle = kPI + kAngleStep;</div><div class="line">  vec2 scale =</div><div class="line">      vec2(spec.top_left_radius / width, spec.top_left_radius / height);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">    verts[out++].uv = verts[<span class="number">1</span>].uv + vec2(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle)) * scale;</div><div class="line">    angle += kAngleStep;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate UV coordinates for top-right corner.</span></div><div class="line">  angle = <span class="number">1.5f</span> * kPI + kAngleStep;</div><div class="line">  scale = vec2(spec.top_right_radius / width, spec.top_right_radius / height);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">    verts[out++].uv = verts[<span class="number">2</span>].uv + vec2(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle)) * scale;</div><div class="line">    angle += kAngleStep;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate UV coordinates for bottom-right corner.</span></div><div class="line">  angle = kAngleStep;</div><div class="line">  scale =</div><div class="line">      vec2(spec.bottom_right_radius / width, spec.bottom_right_radius / height);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">    verts[out++].uv = verts[<span class="number">3</span>].uv + vec2(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle)) * scale;</div><div class="line">    angle += kAngleStep;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate UV coordinates for bottom-right corner.</span></div><div class="line">  angle = <span class="number">0.5f</span> * kPI + kAngleStep;</div><div class="line">  scale =</div><div class="line">      vec2(spec.bottom_left_radius / width, spec.bottom_left_radius / height);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kCornerDivisions; ++i) &#123;</div><div class="line">    verts[out++].uv = verts[<span class="number">4</span>].uv + vec2(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle)) * scale;</div><div class="line">    angle += kAngleStep;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面函数计算这些点(0 ~ 40)对应的顶点坐标，根据对应的纹理坐标来计算得到.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Helper for GenerateRoundedRectVertices().</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> UvVertT, <span class="keyword">typename</span> PosVertT&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateRoundedRectVertexPositionsFromUVs</span><span class="params">(<span class="keyword">const</span> RoundedRectSpec&amp; spec,</span></span></div><div class="line">                                               UvVertT* uv_verts,</div><div class="line">                                               PosVertT* pos_verts) &#123;</div><div class="line">  TRACE_DURATION(<span class="string">"gfx"</span>, <span class="string">"escher::GenerateRoundedRectVertexPositionsFromUVs"</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">const</span> vec2 <span class="title">extent</span><span class="params">(spec.width, spec.height)</span></span>;</div><div class="line">  <span class="keyword">const</span> vec2 offset = <span class="number">-0.5f</span> * extent;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kVertexCount; ++i) &#123;</div><div class="line">    pos_verts[i].pos = uv_verts[i].uv * extent + offset;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x26-Sphere"><a href="#0x26-Sphere" class="headerlink" title="0x26 Sphere"></a>0x26 Sphere</h2><p>下面是构造Sphere的mesh的代码.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">MeshPtr <span class="title">NewSphereMesh</span><span class="params">(MeshBuilderFactory* factory, <span class="keyword">const</span> MeshSpec&amp; spec,</span></span></div><div class="line">                      <span class="keyword">int</span> subdivisions, vec3 center, <span class="keyword">float</span> radius) &#123;</div><div class="line">  FXL_DCHECK(subdivisions &gt;= <span class="number">0</span>);</div><div class="line">  FXL_DCHECK(spec.IsValidOneBufferMesh());</div><div class="line">  <span class="keyword">size_t</span> vertex_count = <span class="number">9</span>;</div><div class="line">  <span class="keyword">size_t</span> triangle_count = <span class="number">8</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subdivisions; ++i) &#123;</div><div class="line">    <span class="comment">// At each level of subdivision, an additional vertex is added for each</span></div><div class="line">    <span class="comment">// triangle, and each triangle is split into three.</span></div><div class="line">    vertex_count += triangle_count;</div><div class="line">    triangle_count *= <span class="number">3</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Populate initial octahedron.</span></div><div class="line">  <span class="keyword">auto</span> builder =</div><div class="line">      factory-&gt;NewMeshBuilder(spec, vertex_count, triangle_count * <span class="number">3</span>);</div><div class="line">  <span class="keyword">constexpr</span> <span class="keyword">size_t</span> kMaxVertexSize = <span class="number">100</span>;</div><div class="line">  <span class="keyword">uint8_t</span> vertex[kMaxVertexSize];</div><div class="line">  <span class="keyword">auto</span> vertex_p =</div><div class="line">      GetVertexAttributePointers(vertex, kMaxVertexSize, spec, builder);</div><div class="line">  FXL_CHECK(vertex_p.pos3);</div><div class="line"></div><div class="line">  <span class="comment">// Positions and UV-coordinates for the initial octahedron.  The vertex with</span></div><div class="line">  <span class="comment">// position (-radius, 0, 0) is replicated 4 times, with different UV-coords</span></div><div class="line">  <span class="comment">// each time.  This is a consequence of surface parameterization that is</span></div><div class="line">  <span class="comment">// described in the header file.</span></div><div class="line">  <span class="keyword">const</span> vec3 positions[] = &#123;vec3(radius, <span class="number">0.f</span>, <span class="number">0.f</span>),  vec3(<span class="number">0.f</span>, <span class="number">0.f</span>, radius),</div><div class="line">                            vec3(<span class="number">0.f</span>, -radius, <span class="number">0.f</span>), vec3(<span class="number">0.f</span>, <span class="number">0.f</span>, -radius),</div><div class="line">                            vec3(<span class="number">0.f</span>, radius, <span class="number">0.f</span>),  vec3(-radius, <span class="number">0.f</span>, <span class="number">0.f</span>),</div><div class="line">                            vec3(-radius, <span class="number">0.f</span>, <span class="number">0.f</span>), vec3(-radius, <span class="number">0.f</span>, <span class="number">0.f</span>),</div><div class="line">                            vec3(-radius, <span class="number">0.f</span>, <span class="number">0.f</span>)&#125;;</div><div class="line">  <span class="keyword">const</span> vec2 uv_coords[] = &#123;vec2(<span class="number">.5</span>f, <span class="number">.5</span>f), vec2(<span class="number">1.f</span>, <span class="number">.5</span>f), vec2(<span class="number">.5</span>f, <span class="number">0.f</span>),</div><div class="line">                            vec2(<span class="number">0.f</span>, <span class="number">.5</span>f), vec2(<span class="number">.5</span>f, <span class="number">1.f</span>), vec2(<span class="number">0.f</span>, <span class="number">0.f</span>),</div><div class="line">                            vec2(<span class="number">1.f</span>, <span class="number">0.f</span>), vec2(<span class="number">1.f</span>, <span class="number">1.f</span>), vec2(<span class="number">0.f</span>, <span class="number">1.f</span>)&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</div><div class="line">    (*vertex_p.pos3) = positions[i] + center;</div><div class="line">    <span class="keyword">if</span> (vertex_p.uv) &#123;</div><div class="line">      (*vertex_p.uv) = uv_coords[i];</div><div class="line">    &#125;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line">  &#125;</div><div class="line">  builder-&gt;AddTriangle(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">      .AddTriangle(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">      .AddTriangle(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">      .AddTriangle(<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>)</div><div class="line">      .AddTriangle(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>)</div><div class="line">      .AddTriangle(<span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>)</div><div class="line">      .AddTriangle(<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>)</div><div class="line">      .AddTriangle(<span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line">  <span class="comment">// TODO(ES-32): this is a hack to ease implementation.  We don't currently</span></div><div class="line">  <span class="comment">// need any tessellated spheres; this is just a way to verify that 3D meshes</span></div><div class="line">  <span class="comment">// are working properly.</span></div><div class="line">  FXL_DCHECK(spec.attributes[<span class="number">0</span>] ==</div><div class="line">             (MeshAttribute::kPosition3D | MeshAttribute::kUV))</div><div class="line">      &lt;&lt; <span class="string">"Tessellated sphere must have UV-coordinates."</span>;</div><div class="line">  <span class="keyword">size_t</span> position_offset = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(vertex_p.pos3) - vertex;</div><div class="line">  <span class="keyword">size_t</span> uv_offset = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(vertex_p.uv) - vertex;</div><div class="line">  <span class="keyword">while</span> (subdivisions-- &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// For each level of subdivision, iterate over all existing triangles and</span></div><div class="line">    <span class="comment">// split them into three.</span></div><div class="line">    <span class="comment">// TODO(ES-32): see comment in header file... this approach is broken, but</span></div><div class="line">    <span class="comment">// sufficient for our current purpose.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> subdiv_triangle_count = builder-&gt;index_count() / <span class="number">3</span>;</div><div class="line">    FXL_DCHECK(subdiv_triangle_count * <span class="number">3</span> == builder-&gt;index_count());</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> tri_ind = <span class="number">0</span>; tri_ind &lt; subdiv_triangle_count; ++tri_ind) &#123;</div><div class="line">      <span class="comment">// Obtain indices for the current triangle, and the position/UV coords for</span></div><div class="line">      <span class="comment">// the corresponding vertices.</span></div><div class="line">      <span class="keyword">uint32_t</span>* tri = builder-&gt;GetIndex(tri_ind * <span class="number">3</span>);</div><div class="line">      <span class="keyword">uint32_t</span> ind0 = tri[<span class="number">0</span>];</div><div class="line">      <span class="keyword">uint32_t</span> ind1 = tri[<span class="number">1</span>];</div><div class="line">      <span class="keyword">uint32_t</span> ind2 = tri[<span class="number">2</span>];</div><div class="line">      <span class="keyword">uint8_t</span>* vert0 = builder-&gt;GetVertex(ind0);</div><div class="line">      <span class="keyword">uint8_t</span>* vert1 = builder-&gt;GetVertex(ind1);</div><div class="line">      <span class="keyword">uint8_t</span>* vert2 = builder-&gt;GetVertex(ind2);</div><div class="line">      vec3 pos0 = *<span class="keyword">reinterpret_cast</span>&lt;vec3*&gt;(vert0 + position_offset);</div><div class="line">      vec3 pos1 = *<span class="keyword">reinterpret_cast</span>&lt;vec3*&gt;(vert1 + position_offset);</div><div class="line">      vec3 pos2 = *<span class="keyword">reinterpret_cast</span>&lt;vec3*&gt;(vert2 + position_offset);</div><div class="line">      vec2 uv0 = *<span class="keyword">reinterpret_cast</span>&lt;vec2*&gt;(vert0 + uv_offset);</div><div class="line">      vec2 uv1 = *<span class="keyword">reinterpret_cast</span>&lt;vec2*&gt;(vert1 + uv_offset);</div><div class="line">      vec2 uv2 = *<span class="keyword">reinterpret_cast</span>&lt;vec2*&gt;(vert2 + uv_offset);</div><div class="line"></div><div class="line">      <span class="comment">// Create a new vertex by averaging the existing vertex attributes.</span></div><div class="line">      (*vertex_p.pos3) =</div><div class="line">          center + radius * glm::normalize((pos0 + pos1 + pos2) / <span class="number">3.f</span> - center);</div><div class="line">      (*vertex_p.uv) = (uv0 + uv1 + uv2) / <span class="number">3.f</span>;</div><div class="line">      builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line"></div><div class="line">      <span class="comment">// Replace the current triangle in-place with a new triangle that refers</span></div><div class="line">      <span class="comment">// to the new vertex.  Then, add two new triangles that also refer to the</span></div><div class="line">      <span class="comment">// new vertex.</span></div><div class="line">      <span class="keyword">uint32_t</span> new_ind = builder-&gt;vertex_count() - <span class="number">1</span>;</div><div class="line">      tri[<span class="number">2</span>] = new_ind;</div><div class="line">      builder-&gt;AddTriangle(ind1, ind2, new_ind)</div><div class="line">          .AddTriangle(ind2, ind0, new_ind);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> builder-&gt;Build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x27-Ring"><a href="#0x27-Ring" class="headerlink" title="0x27 Ring"></a>0x27 Ring</h2><p>下面分析Ring的mesh是如何生成的, Ring是由内圈和外圈包含的区域组成, 内圈区域内是透明的, 实际上Ring的mesh没有包括内圈，也就是说渲染的时候不会去绘制内圈区域, 所以mesh生成的绘制区域只需要包括内圈和外圈组成的区域，mesh的过程也就是把内圈和外圈之间的区域拆分成许多小三角形.</p>
<p>下面函数的参数中，<br>subdivisions指定Ring的拆分数.<br>center指定Circle的中心点坐标.<br>outer_radius指定Ring的外圈半径.<br>inner_radius指定Ring的内圈半径.</p>
<p>生成mesh的时候把Ring分成(subdivisions*4)个小扇形，这些小扇形会和Ring的内圈和外圈相交,<br>指定相交点的vertex值，然后把这些vertex组成的triangle，vertex的index值指定给mesh的index.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">MeshPtr NewRingMesh(MeshBuilderFactory* factory, const MeshSpec&amp; spec,</div><div class="line">                    int subdivisions, vec2 center, float outer_radius,</div><div class="line">                    float inner_radius, float outer_offset_magnitude,</div><div class="line">                    float inner_offset_magnitude) &#123;</div><div class="line">  // Compute the number of vertices in the tessellated circle.</div><div class="line">  FXL_DCHECK(subdivisions &gt;= 0);</div><div class="line">  FXL_DCHECK(spec.IsValidOneBufferMesh());</div><div class="line">  size_t outer_vertex_count = 4;</div><div class="line">  while (subdivisions-- &gt; 0) &#123;</div><div class="line">    outer_vertex_count *= 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  size_t vertex_count = outer_vertex_count * 2;</div><div class="line">  size_t index_count = outer_vertex_count * 6;</div><div class="line"></div><div class="line">  auto builder = factory-&gt;NewMeshBuilder(spec, vertex_count, index_count);</div><div class="line"></div><div class="line">  // Generate vertex positions.</div><div class="line">  constexpr size_t kMaxVertexSize = 100;</div><div class="line">  uint8_t vertex[kMaxVertexSize];</div><div class="line">  auto vertex_p =</div><div class="line">      GetVertexAttributePointers(vertex, kMaxVertexSize, spec, builder);</div><div class="line">  FXL_CHECK(vertex_p.pos2);</div><div class="line"></div><div class="line">  const float outer_vertex_count_reciprocal = 1.f / outer_vertex_count;</div><div class="line">  const float radian_step = 2 * M_PI / outer_vertex_count;</div><div class="line">  for (size_t i = 0; i &lt; outer_vertex_count; ++i) &#123;</div><div class="line">    float radians = i * radian_step;</div><div class="line"></div><div class="line">    // Direction of the current vertex from the center of the circle.</div><div class="line">    vec2 dir(sin(radians), cos(radians));</div><div class="line"></div><div class="line">    // Build outer-ring vertex.</div><div class="line">    (*vertex_p.pos2) = dir * outer_radius + center;</div><div class="line">    if (vertex_p.uv) &#123;</div><div class="line">      // Munge the texcoords slightly to avoid wrapping artifacts.  This matters</div><div class="line">      // when both:</div><div class="line">      //   - the vk::SamplerAddressMode is eRepeat</div><div class="line">      //   - the vk::Filter is eLinear</div><div class="line">      (*vertex_p.uv) = 0.49f * (dir + vec2(1.f, 1.02f));</div><div class="line">      // TODO(ES-108): once we can specify a SamplerAddressMode of eClampToEdge,</div><div class="line">      // remove the hack above and replace it with the code below:</div><div class="line">      // (*vertex_p.uv) = 0.5f * (dir + vec2(1.f, 1.f));</div><div class="line">    &#125;</div><div class="line">    if (vertex_p.pos_offset)</div><div class="line">      (*vertex_p.pos_offset) = dir * outer_offset_magnitude;</div><div class="line">    if (vertex_p.perim)</div><div class="line">      (*vertex_p.perim) = i * outer_vertex_count_reciprocal;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line"></div><div class="line">    // Build inner-ring vertex.  Only the position and offset may differ from</div><div class="line">    // the corresponding outer-ring vertex.</div><div class="line">    (*vertex_p.pos2) = dir * inner_radius + center;</div><div class="line">    if (vertex_p.pos_offset) &#123;</div><div class="line">      // Positive offsets point inward, toward the center of the circle.</div><div class="line">      (*vertex_p.pos_offset) = dir * -inner_offset_magnitude;</div><div class="line">    &#125;</div><div class="line">    builder-&gt;AddVertexData(vertex, builder-&gt;vertex_stride());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Generate vertex indices.</div><div class="line">  for (size_t i = 2; i &lt; vertex_count; i += 2) &#123;</div><div class="line">    builder-&gt;AddIndex(i - 2);</div><div class="line">    builder-&gt;AddIndex(i - 1);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">    builder-&gt;AddIndex(i);</div><div class="line">    builder-&gt;AddIndex(i - 1);</div><div class="line">    builder-&gt;AddIndex(i + 1);</div><div class="line">  &#125;</div><div class="line">  builder-&gt;AddIndex(vertex_count - 2);</div><div class="line">  builder-&gt;AddIndex(vertex_count - 1);</div><div class="line">  builder-&gt;AddIndex(0);</div><div class="line">  builder-&gt;AddIndex(0);</div><div class="line">  builder-&gt;AddIndex(vertex_count - 1);</div><div class="line">  builder-&gt;AddIndex(1);</div><div class="line"></div><div class="line">  auto mesh = builder-&gt;Build();</div><div class="line">  FXL_DCHECK(mesh-&gt;num_indices() == index_count);</div><div class="line">  FXL_DCHECK(</div><div class="line">      mesh-&gt;bounding_box() ==</div><div class="line">      BoundingBox(vec3(center.x - outer_radius, center.y - outer_radius, 0),</div><div class="line">                  vec3(center.x + outer_radius, center.y + outer_radius, 0)));</div><div class="line">  return mesh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/" itemprop="url">How vulkan benefit from multithead on cpu</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-08T12:59:57+08:00">
                2019-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/" class="leancloud_visitors" data-flag-title="How vulkan benefit from multithead on cpu">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Vulkan-mechansim-for-multithread-cpu"><a href="#0x1-Vulkan-mechansim-for-multithread-cpu" class="headerlink" title="0x1 Vulkan mechansim for multithread cpu"></a>0x1 Vulkan mechansim for multithread cpu</h1><p>Vulkan uses command buffer to record the gpu states, then execute the command buffer. on opengl, we have only one command buffer to record the gpu states, but on vulkan, we can have several command buffers to record gpu states in parallel.</p>
<p>If the draw task is cpu bounding, which means the loading is cpu heavy, and these tasks can be splitted into several threads to execute in parallel, then we can assign different command buffers to threads, and record the gpu states into these command buffers in parallel, after all threads are ready, we can submit these command buffers to gpu driver, then gpu driver executes it.</p>
<p>Here is the vulkan command buffer execution models.</p>
<p><img src="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/vulkan_multithread.png" alt="vulkan_multithread"></p>
<p>Is it possible for every graphics draw pipeline can be benefit from the multithread command buffer mechansim?</p>
<p>It is case by case.</p>
<p>If the drawing data preparing task on cpu can’t be splited into several parallel tasks, likes it has dependency each other(one draw has to be drawed before another one), it can’t be benefited from the mulithread command buffer mechansim.</p>
<p>Otherwise it can benefit from it.</p>
<h1 id="0x2-Test-case-analysis"><a href="#0x2-Test-case-analysis" class="headerlink" title="0x2 Test case analysis"></a>0x2 Test case analysis</h1><p>We use <a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/multisampling/multisampling.cpp" target="_blank" rel="external">SaschaWillems’s Vulkan example</a> as the test case to check how vulkan can be benefited from multithread.</p>
<p>This test generates command buffers in parallel using multithreaded mechansim. these generation command buffers are configured as the vulkan secondary command buffers, they are executed and submitted together with the primary buffer once all threads have finished.</p>
<p>Here is the sequence about how it works.</p>
<p><img src="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/draw_sequence.png" alt="draw_sequence"></p>
<p>Let’s discuss the detail sequence of this test case.</p>
<h2 id="0x21-Prepare"><a href="#0x21-Prepare" class="headerlink" title="0x21 Prepare"></a>0x21 Prepare</h2><p>It prepares the vulkan initialization, load the mesh, create the multithread for command buffer execution.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">VulkanExampleBase::prepare();</div><div class="line"><span class="comment">// Create a fence for synchronization</span></div><div class="line">VkFenceCreateInfo fenceCreateInfo = vks::initializers::fenceCreateInfo(VK_FLAGS_NONE);</div><div class="line">vkCreateFence(device, &amp;fenceCreateInfo, <span class="literal">NULL</span>, &amp;renderFence);</div><div class="line">loadMeshes();</div><div class="line">setupVertexDescriptions();</div><div class="line">setupPipelineLayout();</div><div class="line">preparePipelines();</div><div class="line">prepareMultiThreadedRenderer();</div><div class="line">updateMatrices();</div><div class="line">prepared = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<p>Here is the code of VulkanExampleBase::prepare(), it does vulkan initialization.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">createCommandPool();</div><div class="line">setupSwapChain();</div><div class="line">createCommandBuffers();</div><div class="line">setupDepthStencil();</div><div class="line">setupRenderPass();</div><div class="line">createPipelineCache();</div><div class="line">setupFrameBuffer();</div></pre></td></tr></table></figure></p>
<p>createCommandPool() creates command buffer through vkCreateCommandPool().</p>
<p>setupSwapChain() creates the swapchain.</p>
<p>createCommandBuffers() creates one command buffer for each swap chain image and reuse for rendering.</p>
<p>setupDepthStencil() steups depth and stencil setting.</p>
<p>setupRenderPass() create render pass through vkCreateRenderPass().</p>
<p>createPipelineCache() create pipeline cache through vkCreatePipelineCache().</p>
<p>setupFrameBuffer() creates frame buffers for every swap chain image through vkCreateFramebuffer().</p>
<h2 id="0x22-Command-buffer-generation"><a href="#0x22-Command-buffer-generation" class="headerlink" title="0x22 Command buffer generation"></a>0x22 Command buffer generation</h2><p>It creates primary/secondary command buffer through vkAllocateCommandBuffers.</p>
<p>It will create thread data for each thread, the thread’s number depends on its core’s number.</p>
<p>For each thread, it will create a command pool for it, then create one secondary command buffer, then create command buffers for each objects.</p>
<p>The buffer number for objcts is numObjectsPerThread, it is the number of animated objects to be rendered per thread, in this test case, the total animated objects is 512, so numObjectsPerThread is 512/numThreads, numThreads is core’s number.</p>
<p>Then it initializes push constants for each object.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create a primar command buffer</span></div><div class="line">VK_CHECK_RESULT(vkAllocateCommandBuffers(device, &amp;cmdBufAllocateInfo, &amp;primaryCommandBuffer));</div><div class="line"></div><div class="line"><span class="comment">// create a secondary command buffer for rendering the star sphere</span></div><div class="line">cmdBufAllocateInfo.level = VK_COMMAND_BUFFER_LEVEL_SECONDARY;</div><div class="line">VK_CHECK_RESULT(vkAllocateCommandBuffers(device, &amp;cmdBufAllocateInfo, &amp;secondaryCommandBuffer));</div><div class="line">......		</div><div class="line">threadData.resize(numThreads);</div><div class="line">......</div><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; numThreads; i++)</div><div class="line">&#123;</div><div class="line">	ThreadData *thread = &amp;threadData[i];</div><div class="line">		</div><div class="line">	<span class="comment">// create one command pool for each thread</span></div><div class="line">	VK_CHECK_RESULT(vkCreateCommandPool(device, &amp;cmdPoolInfo, <span class="literal">nullptr</span>, &amp;thread-&gt;commandPool));</div><div class="line"></div><div class="line">	<span class="comment">// one secondary command buffer per object that is updated by this thread</span></div><div class="line">	thread-&gt;commandBuffer.resize(numObjectsPerThread);</div><div class="line">	<span class="comment">// generate secondary command buffers for each thread</span></div><div class="line">	VkCommandBufferAllocateInfo secondaryCmdBufAllocateInfo =</div><div class="line">		vks::initializers::commandBufferAllocateInfo(</div><div class="line">			thread-&gt;commandPool,</div><div class="line">			VK_COMMAND_BUFFER_LEVEL_SECONDARY,</div><div class="line">			thread-&gt;commandBuffer.size());</div><div class="line">	VK_CHECK_RESULT(vkAllocateCommandBuffers(device, &amp;secondaryCmdBufAllocateInfo, thread-&gt;commandBuffer.data()));</div><div class="line"></div><div class="line">	thread-&gt;pushConstBlock.resize(numObjectsPerThread);</div><div class="line">	thread-&gt;objectData.resize(numObjectsPerThread);</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; numObjectsPerThread; j++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">float</span> theta = <span class="number">2.0f</span> * <span class="keyword">float</span>(M_PI) * uniformDist(rndGenerator);</div><div class="line">		<span class="keyword">float</span> phi = <span class="built_in">acos</span>(<span class="number">1.0f</span> - <span class="number">2.0f</span> * uniformDist(rndGenerator));</div><div class="line">		thread-&gt;objectData[j].pos = glm::vec3(<span class="built_in">sin</span>(phi) * <span class="built_in">cos</span>(theta), <span class="number">0.0f</span>, <span class="built_in">cos</span>(phi)) * <span class="number">35.0f</span>;</div><div class="line"></div><div class="line">		thread-&gt;objectData[j].rotation = glm::vec3(<span class="number">0.0f</span>, rnd(<span class="number">360.0f</span>), <span class="number">0.0f</span>);</div><div class="line">		thread-&gt;objectData[j].deltaT = rnd(<span class="number">1.0f</span>);</div><div class="line">		thread-&gt;objectData[j].rotationDir = (rnd(<span class="number">100.0f</span>) &lt; <span class="number">50.0f</span>) ? <span class="number">1.0f</span> : <span class="number">-1.0f</span>;</div><div class="line">		thread-&gt;objectData[j].rotationSpeed = (<span class="number">2.0f</span> + rnd(<span class="number">4.0f</span>)) * thread-&gt;objectData[j].rotationDir;</div><div class="line">		thread-&gt;objectData[j].scale = <span class="number">0.75f</span> + rnd(<span class="number">0.5f</span>);</div><div class="line"></div><div class="line">		thread-&gt;pushConstBlock[j].color = glm::vec3(rnd(<span class="number">1.0f</span>), rnd(<span class="number">1.0f</span>), rnd(<span class="number">1.0f</span>));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x23-Draw"><a href="#0x23-Draw" class="headerlink" title="0x23 Draw"></a>0x23 Draw</h2><p>Here is the code about drawing.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">VulkanExampleBase::prepareFrame();</div><div class="line">updateCommandBuffers(frameBuffers[currentBuffer]);</div><div class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</div><div class="line">submitInfo.pCommandBuffers = &amp;primaryCommandBuffer;</div><div class="line"></div><div class="line">VK_CHECK_RESULT(vkQueueSubmit(<span class="built_in">queue</span>, <span class="number">1</span>, &amp;submitInfo, renderFence));</div><div class="line"></div><div class="line"><span class="comment">// wait for fence to signal that all command buffers are ready</span></div><div class="line">VkResult fenceRes;</div><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line">	fenceRes = vkWaitForFences(device, <span class="number">1</span>, &amp;renderFence, VK_TRUE, <span class="number">100000000</span>);</div><div class="line">&#125; <span class="keyword">while</span> (fenceRes == VK_TIMEOUT);</div><div class="line">VK_CHECK_RESULT(fenceRes);</div><div class="line">vkResetFences(device, <span class="number">1</span>, &amp;renderFence);</div><div class="line">VulkanExampleBase::submitFrame();</div></pre></td></tr></table></figure>
<p>The main update function is updateCommandBuffers().</p>
<p>It uses a thread pool to generate drawing command in each thread, the thread function is threadRenderCode.</p>
<p>Firstly, it start to queue command to primary command buffer through vkBeginCommandBuffer().<br>The primary command buffer didn’t contain any rendering commands, the rendering command are stored (and retrieved) from the secondary command buffers.<br>Then it calls vkCmdBeginRenderPass() to start a new RenderPass.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Updates the secondary command buffers using a thread pool </span></div><div class="line"><span class="comment">// and puts them into the primary command buffer that's </span></div><div class="line"><span class="comment">// lat submitted to the queue for rendering</span></div><div class="line">VkCommandBufferBeginInfo cmdBufInfo = vks::initializers::commandBufferBeginInfo();</div><div class="line">......</div><div class="line"><span class="comment">// Set target frame buffer</span></div><div class="line">VK_CHECK_RESULT(vkBeginCommandBuffer(primaryCommandBuffer, &amp;cmdBufInfo));</div><div class="line"></div><div class="line"><span class="comment">// The primary command buffer does not contain any rendering commands</span></div><div class="line"><span class="comment">// These are stored (and retrieved) from the secondary command buffers</span></div><div class="line">vkCmdBeginRenderPass(primaryCommandBuffer, &amp;renderPassBeginInfo, VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS);</div></pre></td></tr></table></figure>
<p>Once the setup for primary command buffer is ready, it starts to config secondary command buffers.</p>
<p>The secondary command buffer is for star background sphere rendering.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Inheritance info for the secondary command buffers</span></div><div class="line">VkCommandBufferInheritanceInfo inheritanceInfo = vks::initializers::commandBufferInheritanceInfo();</div><div class="line">inheritanceInfo.renderPass = renderPass;</div><div class="line"><span class="comment">// Secondary command buffer also use the currently active framebuffer</span></div><div class="line">inheritanceInfo.framebuffer = frameBuffer;</div><div class="line"></div><div class="line"><span class="comment">// Contains the list of secondary command buffers to be executed</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;VkCommandBuffer&gt; commandBuffers;</div><div class="line"></div><div class="line"><span class="comment">// Secondary command buffer with star background sphere</span></div><div class="line">updateSecondaryCommandBuffer(inheritanceInfo);</div><div class="line">commandBuffers.push_back(secondaryCommandBuffer);</div></pre></td></tr></table></figure>
<p>Now we will see how command buffer generation through multithread.</p>
<p>Each object is executed in one thread.</p>
<p>After secondary command buffer is ready, it executes render commands from the secondary command buffer through vkCmdExecuteCommands()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Add a job to the thread's queue for each object to be rendered</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> t = <span class="number">0</span>; t &lt; numThreads; t++)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; numObjectsPerThread; i++)</div><div class="line">	&#123;</div><div class="line">		threadPool.threads[t]-&gt;addJob([=] &#123; threadRenderCode(t, i, inheritanceInfo); &#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">		</div><div class="line">threadPool.wait();</div><div class="line"></div><div class="line"><span class="comment">// Only submit if object is within the current view frustum</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> t = <span class="number">0</span>; t &lt; numThreads; t++)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; numObjectsPerThread; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (threadData[t].objectData[i].visible)</div><div class="line">		&#123;</div><div class="line">			commandBuffers.push_back(threadData[t].commandBuffer[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Execute render commands from the secondary command buffer</span></div><div class="line">vkCmdExecuteCommands(primaryCommandBuffer, commandBuffers.size(), commandBuffers.data());</div><div class="line"></div><div class="line">vkCmdEndRenderPass(primaryCommandBuffer);</div><div class="line"></div><div class="line">VK_CHECK_RESULT(vkEndCommandBuffer(primaryCommandBuffer));</div></pre></td></tr></table></figure>
<h2 id="0x24-Multithread-comand-buffer-generation"><a href="#0x24-Multithread-comand-buffer-generation" class="headerlink" title="0x24 Multithread comand buffer generation"></a>0x24 Multithread comand buffer generation</h2><p>Let’s see how the multithread function threadRenderCode work.</p>
<p>It builds the secondary command buffer for one object of each thread.</p>
<p>threadIndex is thread index.<br>cmdBufferIndex is the command buffer index.</p>
<p>It begin to push command buffer to gpu driver through vkBeginCommandBuffer().</p>
<p>Then it prepares the data for push constant. </p>
<p>And push the data to gpu driver through vkCmdPushConstants().</p>
<p>Then it pass vertex data and index data through vkCmdBindVertexBuffers() and vkCmdDrawIndexed().</p>
<p>Then it issues draw operation through vkCmdDrawIndexed().</p>
<p>Then it stops the recording of command buffer through vkEndCommandBuffer().</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Builds the secondary command buffer for each thread</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadRenderCode</span><span class="params">(<span class="keyword">uint32_t</span> threadIndex, <span class="keyword">uint32_t</span> cmdBufferIndex, VkCommandBufferInheritanceInfo inheritanceInfo)</span></span></div><div class="line">&#123;</div><div class="line">	ThreadData *thread = &amp;threadData[threadIndex];</div><div class="line">	ObjectData *objectData = &amp;thread-&gt;objectData[cmdBufferIndex];</div><div class="line"></div><div class="line">	<span class="comment">// Check visibility against view frustum</span></div><div class="line">	objectData-&gt;visible = frustum.checkSphere(objectData-&gt;pos, objectSphereDim * <span class="number">0.5f</span>); </div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!objectData-&gt;visible)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	VkCommandBufferBeginInfo commandBufferBeginInfo = vks::initializers::commandBufferBeginInfo();</div><div class="line">	commandBufferBeginInfo.flags = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT;</div><div class="line">	commandBufferBeginInfo.pInheritanceInfo = &amp;inheritanceInfo;</div><div class="line"></div><div class="line">	VkCommandBuffer cmdBuffer = thread-&gt;commandBuffer[cmdBufferIndex];</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkBeginCommandBuffer(cmdBuffer, &amp;commandBufferBeginInfo));</div><div class="line"></div><div class="line">	VkViewport viewport = vks::initializers::viewport((<span class="keyword">float</span>)width, (<span class="keyword">float</span>)height, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">	vkCmdSetViewport(cmdBuffer, <span class="number">0</span>, <span class="number">1</span>, &amp;viewport);</div><div class="line"></div><div class="line">	VkRect2D scissor = vks::initializers::rect2D(width, height, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">	vkCmdSetScissor(cmdBuffer, <span class="number">0</span>, <span class="number">1</span>, &amp;scissor);</div><div class="line"></div><div class="line">	vkCmdBindPipeline(cmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelines.phong);</div><div class="line"></div><div class="line">	<span class="comment">// Update objectData</span></div><div class="line">	objectData-&gt;rotation.y += <span class="number">2.5f</span> * objectData-&gt;rotationSpeed * frameTimer;</div><div class="line">	......</div><div class="line">	objectData-&gt;model = glm::scale(objectData-&gt;model, glm::vec3(objectData-&gt;scale));</div><div class="line"></div><div class="line">	thread-&gt;pushConstBlock[cmdBufferIndex].mvp = matrices.projection * matrices.view * objectData-&gt;model;</div><div class="line"></div><div class="line">	<span class="comment">// Update shader push constant block</span></div><div class="line">	<span class="comment">// Contains model view matrix</span></div><div class="line">	vkCmdPushConstants(</div><div class="line">		cmdBuffer,</div><div class="line">		pipelineLayout,</div><div class="line">		VK_SHADER_STAGE_VERTEX_BIT,</div><div class="line">		<span class="number">0</span>,</div><div class="line">		<span class="keyword">sizeof</span>(ThreadPushConstantBlock),</div><div class="line">		&amp;thread-&gt;pushConstBlock[cmdBufferIndex]);</div><div class="line"></div><div class="line">	VkDeviceSize offsets[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">	vkCmdBindVertexBuffers(cmdBuffer, <span class="number">0</span>, <span class="number">1</span>, &amp;models.ufo.vertices.buffer, offsets);</div><div class="line">	vkCmdBindIndexBuffer(cmdBuffer, models.ufo.indices.buffer, <span class="number">0</span>, VK_INDEX_TYPE_UINT32);</div><div class="line">	vkCmdDrawIndexed(cmdBuffer, models.ufo.indexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkEndCommandBuffer(cmdBuffer));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="0x3-Performance-analysis"><a href="#0x3-Performance-analysis" class="headerlink" title="0x3 Performance analysis"></a>0x3 Performance analysis</h1><p>Here we will compare the performance with/without multithread support using vulkan.</p>
<p>And then check the thread profiling data of them.</p>
<h2 id="0x31-With-multithread"><a href="#0x31-With-multithread" class="headerlink" title="0x31  With multithread"></a>0x31  With multithread</h2><p>Here is the performance of using vulkan with multithread support(4 threads), the fps is 28.</p>
<p><img src="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/test_result_4cores.png" alt="multithread-4cores"></p>
<p>Here is the cpu profiling data of it, we can see the cpu loading is balanced to 5 threads, one is main thread, other 4 threads are working thread for generating object for vulkan command buffer, the working thread number 4 is the number of cpu cores.</p>
<p><img src="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/profiling_4cores.png" alt="profiling-4cores"></p>
<h2 id="0x32-Without-multithread"><a href="#0x32-Without-multithread" class="headerlink" title="0x32  Without multithread"></a>0x32  Without multithread</h2><p>Here is the performance of using vulkan without multithread support(1 thread), the fps is 17.</p>
<p>We can see the fps gain from 1 thread to 4 threads is 65%(17 -&gt; 28).</p>
<p><img src="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/test_result_1core.png" alt="multithread-1core"></p>
<p>Here is the cpu profiling data of it, we can see the cpu loading is only bounded to two threads, one is the main thread, another is the working thread.</p>
<p><img src="/2019/02/08/How-vulkan-benefit-from-multithread-on-cpu/profiling_1core.png" alt="profiling-1core"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Kevin Wen" />
          <p class="site-author-name" itemprop="name">Kevin Wen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Wen</span>
</div>


<div> <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
访问量 <span id="busuanzi_value_site_pv"></span>
访问人数 <span id="busuanzi_value_site_uv"></span>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("orq8xxsDQDXKiHdqSRcjlflB-gzGzoHsz", "ecCFdIcWDfbJKQOCiLFf1EBm");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
